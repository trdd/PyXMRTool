
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Module SampleRepresentation &#8212; PyXMRTool 0.9 documentation</title>
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Module Experiment" href="experiment.html" />
    <link rel="prev" title="Module Parameters" href="parameters.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="experiment.html" title="Module Experiment"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="parameters.html" title="Module Parameters"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PyXMRTool 0.9 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../api.html" accesskey="U">API</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h3><a href="../index.html">Table of Contents</a></h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html">PyXMRTool’s documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">Overview</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../api.html">API</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="parameters.html">Module <cite>Parameters</cite></a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Module <cite>SampleRepresentation</cite></a></li>
<li class="toctree-l2"><a class="reference internal" href="experiment.html">Module <cite>Experiment</cite></a></li>
<li class="toctree-l2"><a class="reference internal" href="fitters.html">Module <cite>Fitters</cite></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../hints.html">Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../definitions.html">Terms and Definitions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../development.html">Developement</a></li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="parameters.html"
                        title="previous chapter">Module <cite>Parameters</cite></a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="experiment.html"
                        title="next chapter">Module <cite>Experiment</cite></a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/modules-api/samplerepresentation.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-SampleRepresentation">
<span id="module-samplerepresentation"></span><h1>Module <cite>SampleRepresentation</cite><a class="headerlink" href="#module-SampleRepresentation" title="Permalink to this headline">¶</a></h1>
<p>Deals with the sample representation for simulation of the reflectivity.</p>
<p>A multilayer sample is represented by a <a class="reference internal" href="#SampleRepresentation.Heterostructure" title="SampleRepresentation.Heterostructure"><code class="xref py py-class docutils literal notranslate"><span class="pre">Heterostructure</span></code></a> object. Its main pupose is to deliver the list of layers (Layer type of the <code class="xref py py-mod docutils literal notranslate"><span class="pre">Pythonreflectivity</span></code> package from Martin Zwiebler) with defined susceptibilities at certain energies via :meth.`Heterostructure.getSingleEnergyStructure`. The layers within this heterostructure are represented by instances of <a class="reference internal" href="#SampleRepresentation.LayerObject" title="SampleRepresentation.LayerObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">LayerObject</span></code></a> or of derived classes, which alows for a very flexibel modelling of the sample.</p>
<p>So far the following layer types are implemented:</p>
<ul class="simple">
<li><a class="reference internal" href="#SampleRepresentation.LayerObject" title="SampleRepresentation.LayerObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">LayerObject</span></code></a>: Layer with a constant (over energy) but fittable electric susceptibility tensor.</li>
<li><a class="reference internal" href="#SampleRepresentation.ModelChiLayerObject" title="SampleRepresentation.ModelChiLayerObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">ModelChiLayerObject</span></code></a>: This layer type holds the electric susceptibility tensor as a user-defined function of energy.</li>
<li><a class="reference internal" href="#SampleRepresentation.MagneticLayerObject" title="SampleRepresentation.MagneticLayerObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">MagneticLayerObject</span></code></a>: This layer type deals with a magnetic layer and therefor creates the off-diagonal elements of the susceptibitlity tensor from a magnetic term and two angles.</li>
<li><a class="reference internal" href="#SampleRepresentation.AtomLayerObject" title="SampleRepresentation.AtomLayerObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">AtomLayerObject</span></code></a>: This layer deals with compositions of atoms with different formfactors. The densities of the atoms can be varied during fitting procedures and plotted with using <a class="reference internal" href="#SampleRepresentation.plotAtomDensity" title="SampleRepresentation.plotAtomDensity"><code class="xref py py-func docutils literal notranslate"><span class="pre">plotAtomDensity()</span></code></a>. The formfactors are represented by instances of classes which are derived from <a class="reference internal" href="#SampleRepresentation.Formfactor" title="SampleRepresentation.Formfactor"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formfactor</span></code></a> (the base class is abstract and cannot be used directly).</li>
</ul>
<p>So far the following formfactor types are implemented:</p>
<ul class="simple">
<li><a class="reference internal" href="#SampleRepresentation.FFfromFile" title="SampleRepresentation.FFfromFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">FFfromFile</span></code></a>: Reads an energy-dependent formfactor as data points from a textfile. For energies between the data points the formfactor is linearly interpolated.</li>
<li><a class="reference internal" href="#SampleRepresentation.FFfromScaledAbsorption" title="SampleRepresentation.FFfromScaledAbsorption"><code class="xref py py-class docutils literal notranslate"><span class="pre">FFfromScaledAbsorption</span></code></a>: Reads an absorption measurement (fitted to off-resonant tabulated values) and a theoretical/tabulated energy-dependen formfactor from textfiles. Within a given energy-range, the absorption is scaled with a fittable factor and the real part is obtained by a Kramers-Kronig transformation. See section 3.3 of Martin Zwiebler PhD-Thesis for details.</li>
<li><a class="reference internal" href="#SampleRepresentation.FFfromFitableModel" title="SampleRepresentation.FFfromFitableModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">FFfromFitableModel</span></code></a>: Formfactor from user-defined fitable model functions. Can be used to implement e.g. a Kramers-Kronig variational approach.</li>
<li><a class="reference internal" href="#SampleRepresentation.MagneticFormfactor" title="SampleRepresentation.MagneticFormfactor"><code class="xref py py-class docutils literal notranslate"><span class="pre">MagneticFormfactor</span></code></a>: Basic formfactor class to deal with a magnetic formfactor, i.e. only the off-diagonal elements of a formfactor tensor. Magnetic terms are defined by the user as instances of <a class="reference internal" href="parameters.html#Parameters.ParametrizedFunction" title="Parameters.ParametrizedFunction"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters.ParametrizedFunction</span></code></a>.</li>
<li><a class="reference internal" href="#SampleRepresentation.MFFfromXMCD" title="SampleRepresentation.MFFfromXMCD"><code class="xref py py-class docutils literal notranslate"><span class="pre">MFFfromXMCD</span></code></a>: A magnetic formfactor which is created from an XMCD measurement.</li>
</ul>
<p>To allow for atomic slicing you can create density profiles with class <a class="reference internal" href="#SampleRepresentation.DensityProfile" title="SampleRepresentation.DensityProfile"><code class="xref py py-class docutils literal notranslate"><span class="pre">DensityProfile</span></code></a> or the specialized <a class="reference internal" href="#SampleRepresentation.DensityProfile_erf" title="SampleRepresentation.DensityProfile_erf"><code class="xref py py-class docutils literal notranslate"><span class="pre">DensityProfile_erf</span></code></a>. Once created, they can provide atomic densities used in <a class="reference internal" href="#SampleRepresentation.AtomLayerObject" title="SampleRepresentation.AtomLayerObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">AtomLayerObject</span></code></a> for the different layers (which are used as slices).</p>
<p>The function <a class="reference internal" href="#SampleRepresentation.plotAtomDensity" title="SampleRepresentation.plotAtomDensity"><code class="xref py py-func docutils literal notranslate"><span class="pre">plotAtomDensity()</span></code></a> can be used to plot the variation of atom densities between the layers.</p>
<dl class="class">
<dt id="SampleRepresentation.Heterostructure">
<em class="property">class </em><code class="descclassname">SampleRepresentation.</code><code class="descname">Heterostructure</code><span class="sig-paren">(</span><em>number_of_layers=0</em>, <em>multilayer_structure=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#Heterostructure"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.Heterostructure" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Represents a heterostructure as a stack of instances of <a class="reference internal" href="#SampleRepresentation.LayerObject" title="SampleRepresentation.LayerObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">LayerObject</span></code></a> or of derived classes.
Its main pupose is to model the sample in a very flexibel way and to get the list of layers (Layer type of the <code class="xref py py-mod docutils literal notranslate"><span class="pre">Pythonreflectivity</span></code> package from Martin Zwiebler) with defined susceptibilities at certain energies.</p>
<p>In contrast to Martin’s list of Layer-type objects, this class contains all information also for different energies.</p>
<dl class="method">
<dt id="SampleRepresentation.Heterostructure.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>number_of_layers=0</em>, <em>multilayer_structure=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#Heterostructure.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.Heterostructure.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create heterostructructure object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>number_of_layers</strong> (<em>int</em>) – gives the number of different layers</li>
<li><strong>multilayer_structure</strong> (<em>list</em>) – Makes it possible to define multilayers which contain identical layers several times.
This can be done by passing a list containing the indices of layers from the lowest (e.g. substrate) to the highest (top layer, hit first by the beam).
Default is <code class="docutils literal notranslate"><span class="pre">[0,1,2,3,</span> <span class="pre">...,number_of_layers-1]</span></code>. Multilayer syntax is e.g.``[0,1,2,[100,[3,4,5,6]],7,.,1,..]`` which repeats 100 times the sequence of
layers 3,4,5,6 in between 2 and 7 and later on layer 1 is repeated once.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="SampleRepresentation.Heterostructure.setLayout">
<code class="descname">setLayout</code><span class="sig-paren">(</span><em>number_of_layers</em>, <em>multilayer_structure=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#Heterostructure.setLayout"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.Heterostructure.setLayout" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the layout of the heterostructure.</p>
<p>See <a class="reference internal" href="#SampleRepresentation.Heterostructure.__init__" title="SampleRepresentation.Heterostructure.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> for details. Only difference is: you cannot make changes which would remove layers.</p>
</dd></dl>

<dl class="method">
<dt id="SampleRepresentation.Heterostructure.setLayer">
<code class="descname">setLayer</code><span class="sig-paren">(</span><em>index</em>, <em>layer</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#Heterostructure.setLayer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.Heterostructure.setLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Place <strong>layer</strong> (instance of <a class="reference internal" href="#SampleRepresentation.LayerObject" title="SampleRepresentation.LayerObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">LayerObject</span></code></a>) at position <strong>index</strong> (counting from 0, starting from the bottom or according to indices defined by <strong>multilayer_structure</strong>).</p>
</dd></dl>

<dl class="method">
<dt id="SampleRepresentation.Heterostructure.getLayer">
<code class="descname">getLayer</code><span class="sig-paren">(</span><em>index</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#Heterostructure.getLayer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.Heterostructure.getLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the instance of <a class="reference internal" href="#SampleRepresentation.LayerObject" title="SampleRepresentation.LayerObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">LayerObject</span></code></a> which is placed at position <strong>index</strong> (counting from 0, starting from the bottom or according to indices defined by <strong>multilayer_structure</strong>).</p>
</dd></dl>

<dl class="method">
<dt id="SampleRepresentation.Heterostructure.getTotalLayer">
<code class="descname">getTotalLayer</code><span class="sig-paren">(</span><em>index</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#Heterostructure.getTotalLayer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.Heterostructure.getTotalLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the instance of <a class="reference internal" href="#SampleRepresentation.LayerObject" title="SampleRepresentation.LayerObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">LayerObject</span></code></a> which is placed at position <strong>index</strong> (counting from 0, starting from the bottom, repeated layers are counted repeatedly).</p>
</dd></dl>

<dl class="method">
<dt id="SampleRepresentation.Heterostructure.removeLayer">
<code class="descname">removeLayer</code><span class="sig-paren">(</span><em>index</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#Heterostructure.removeLayer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.Heterostructure.removeLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the instance of <a class="reference internal" href="#SampleRepresentation.LayerObject" title="SampleRepresentation.LayerObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">LayerObject</span></code></a> which is placed at position <strong>index</strong> (counting from 0, starting from the bottom or according to indices defined by <strong>multilayer_structure</strong>).</p>
<p><strong>index</strong> can also be a list of indices.
BEWARE: The instance of <a class="reference internal" href="#SampleRepresentation.LayerObject" title="SampleRepresentation.LayerObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">LayerObject</span></code></a> itself and the corresdonding instances of <a class="reference internal" href="parameters.html#Parameters.Fitparameter" title="Parameters.Fitparameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters.Fitparameter</span></code></a> are not deleted! So in a following fitting procedure, these parameters might still be varied even though they don’t have any effect on the result.</p>
</dd></dl>

<dl class="method">
<dt id="SampleRepresentation.Heterostructure.getSingleEnergyStructure">
<code class="descname">getSingleEnergyStructure</code><span class="sig-paren">(</span><em>fitpararray</em>, <em>energy=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#Heterostructure.getSingleEnergyStructure"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.Heterostructure.getSingleEnergyStructure" title="Permalink to this definition">¶</a></dt>
<dd><p>Return list of layers (Layer type of the <code class="xref py py-mod docutils literal notranslate"><span class="pre">Pythonreflectivity</span></code> package from Martin Zwiebler) which can be directly used as input for <code class="xref py py-func docutils literal notranslate"><span class="pre">Pythonreflectivity.Reflectivity()</span></code>.</p>
<p><strong>energy</strong> in units of eV</p>
</dd></dl>

<dl class="attribute">
<dt id="SampleRepresentation.Heterostructure.N">
<code class="descname">N</code><a class="headerlink" href="#SampleRepresentation.Heterostructure.N" title="Permalink to this definition">¶</a></dt>
<dd><p>(<em>int</em>) Number of different layers. Read-only.</p>
</dd></dl>

<dl class="attribute">
<dt id="SampleRepresentation.Heterostructure.N_total">
<code class="descname">N_total</code><a class="headerlink" href="#SampleRepresentation.Heterostructure.N_total" title="Permalink to this definition">¶</a></dt>
<dd><p>(<em>int</em>) Total number of layers counting also multiple use of the same layer according to <strong>multilayer_structure</strong>. Read-only.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="SampleRepresentation.LayerObject">
<em class="property">class </em><code class="descclassname">SampleRepresentation.</code><code class="descname">LayerObject</code><span class="sig-paren">(</span><em>chitensor=None</em>, <em>d=None</em>, <em>sigma=None</em>, <em>magdir='0'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#LayerObject"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.LayerObject" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Base class for all layer objects as the common interface. Speciallized implementation should inherit from this class.</p>
<dl class="method">
<dt id="SampleRepresentation.LayerObject.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>chitensor=None</em>, <em>d=None</em>, <em>sigma=None</em>, <em>magdir='0'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#LayerObject.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.LayerObject.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>d</strong> (<a class="reference internal" href="parameters.html#Parameters.Parameter" title="Parameters.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters.Parameter</span></code></a>) – Thickness. Unit is the same as for every other length used throughout the project and is not predefined. E.g. wavelength.
<em>None</em> or <em>0</em> mean infinitively thick.</li>
<li><strong>sigma</strong> (<a class="reference internal" href="parameters.html#Parameters.Parameter" title="Parameters.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters.Parameter</span></code></a>) – The roughness of the upper surface of the layer. Has dimension of length. Unit: see <strong>d</strong>.</li>
<li><strong>chitensor</strong> (list of <a class="reference internal" href="parameters.html#Parameters.Parameter" title="Parameters.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters.Parameter</span></code></a>) – <p>Electric susceptibility tensor of the layer.</p>
<ul>
<li><em>[chi]</em> sets <em>chi_xx = chi_yy = chi_zz = chi</em></li>
<li><em>[chi_xx,chi_yy,chi_z]</em> sets <em>chi_xx,chi_yy,chi_zz</em>, others are zero</li>
<li><em>[chi_xx,chi_yy,chi_z,chi_g]</em> sets  <em>chi_xx,chi_yy,chi_zz</em> and depending on <strong>magdir</strong> <em>chi_yz=-chi_zy=chi_g</em> (if <em>x</em>), <em>chi_xz=-chi_zx=chi_g</em> (if <em>y</em>) or <em>chi_xz=-chi_zx=chi_g</em> (if <em>z</em>)</li>
<li><em>[chi_xx,chi_xy,chi_xz,chi_yx,chi_yy,chi_yz,chi_zx,chi_zy,chi_zz]</em> sets all the corresdonding elements</li>
</ul>
</li>
<li><strong>magdir</strong> (<em>str</em>) – Gives the magnetization direction for MOKE. Possible values are <em>“x”</em>, <em>“y”</em>, <em>“z”</em> and <em>“0”</em> (no magnetization).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="SampleRepresentation.LayerObject.getChi">
<code class="descname">getChi</code><span class="sig-paren">(</span><em>fitpararray</em>, <em>energy=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#LayerObject.getChi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.LayerObject.getChi" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the electric susceptibility tensor as a list of numbers for a certain <strong>energy</strong> corresponding to the parameter values in <strong>fitpararray</strong> (see <a class="reference internal" href="parameters.html#module-Parameters" title="Parameters"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Parameters</span></code></a>).</p>
<p>The returned list can be of length 1,3,4 or 9 (see <a class="reference internal" href="#SampleRepresentation.LayerObject.__init__" title="SampleRepresentation.LayerObject.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a>).
For the base implementation of <a class="reference internal" href="#SampleRepresentation.LayerObject" title="SampleRepresentation.LayerObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">LayerObject</span></code></a> the parameter <strong>energy</strong> is not used. But it may be used by derived classes like <a class="reference internal" href="#SampleRepresentation.AtomLayerObject" title="SampleRepresentation.AtomLayerObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">AtomLayerObject</span></code></a> and therefore needed for compatibility.l
<strong>energy</strong> is measured in units of eV.</p>
</dd></dl>

<dl class="method">
<dt id="SampleRepresentation.LayerObject.getD">
<code class="descname">getD</code><span class="sig-paren">(</span><em>fitpararray</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#LayerObject.getD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.LayerObject.getD" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the thickness of the layer as a number corresponding to the parameter values in <strong>fitpararray</strong> (see <a class="reference internal" href="parameters.html#module-Parameters" title="Parameters"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Parameters</span></code></a>).</p>
<p>The thickness is given in the unit of length you chose. You are free to choose whatever unit you want, but use the same for every length troughout the project.</p>
</dd></dl>

<dl class="method">
<dt id="SampleRepresentation.LayerObject.getSigma">
<code class="descname">getSigma</code><span class="sig-paren">(</span><em>fitpararray</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#LayerObject.getSigma"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.LayerObject.getSigma" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the roughness of the upper surface of the layer as a number corresponding to the parameter values in <strong>fitpararray</strong> (see <a class="reference internal" href="parameters.html#module-Parameters" title="Parameters"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Parameters</span></code></a>).</p>
<p>The thickness is given in the unit of length you chose. You are free to choose whatever unit you want, but use the same for every length troughout the project.</p>
</dd></dl>

<dl class="method">
<dt id="SampleRepresentation.LayerObject.getMagDir">
<code class="descname">getMagDir</code><span class="sig-paren">(</span><em>fitpararray=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#LayerObject.getMagDir"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.LayerObject.getMagDir" title="Permalink to this definition">¶</a></dt>
<dd><p>Return magnetization direction</p>
<p><strong>fitpararray</strong> is not used and just there to give a common interface. Maybe a derived classes will have a benefit from it.</p>
</dd></dl>

<dl class="attribute">
<dt id="SampleRepresentation.LayerObject.d">
<code class="descname">d</code><a class="headerlink" href="#SampleRepresentation.LayerObject.d" title="Permalink to this definition">¶</a></dt>
<dd><p>Thickness of the layer. Unit is the same as for every other length used throughout the project and is not predefined. E.g. wavelength.</p>
</dd></dl>

<dl class="attribute">
<dt id="SampleRepresentation.LayerObject.chitensor">
<code class="descname">chitensor</code><a class="headerlink" href="#SampleRepresentation.LayerObject.chitensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Electric susceptibility tensor of the layer. See <a class="reference internal" href="#SampleRepresentation.LayerObject.__init__" title="SampleRepresentation.LayerObject.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> for details.</p>
</dd></dl>

<dl class="attribute">
<dt id="SampleRepresentation.LayerObject.sigma">
<code class="descname">sigma</code><a class="headerlink" href="#SampleRepresentation.LayerObject.sigma" title="Permalink to this definition">¶</a></dt>
<dd><p>Roughness of the upper surface of the layer. Unit is the same as for every other length used throughout the project and is not predefined. E.g. wavelength.</p>
</dd></dl>

<dl class="attribute">
<dt id="SampleRepresentation.LayerObject.magdir">
<code class="descname">magdir</code><a class="headerlink" href="#SampleRepresentation.LayerObject.magdir" title="Permalink to this definition">¶</a></dt>
<dd><p>Magnetization direction for MOKE. Possible values are <em>“x”</em>, <em>“y”</em>, <em>“z”</em> and <em>“0”</em> (no magnetization).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="SampleRepresentation.MagneticLayerObject">
<em class="property">class </em><code class="descclassname">SampleRepresentation.</code><code class="descname">MagneticLayerObject</code><span class="sig-paren">(</span><em>chi_diag</em>, <em>m_prime</em>, <em>m_primeprime</em>, <em>theta_M</em>, <em>phi_M</em>, <em>d=None</em>, <em>sigma=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#MagneticLayerObject"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.MagneticLayerObject" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#SampleRepresentation.LayerObject" title="SampleRepresentation.LayerObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SampleRepresentation.LayerObject</span></code></a></p>
<p>Specialized layer to deal with a magnetic layer without energy-dependence.</p>
<p>The electrical suszeptibility tensor (Chi) consists of an energy-independent diagonal part and of off-diagonal elements which are given as a magnetization and their direction (angles).</p>
<dl class="method">
<dt id="SampleRepresentation.MagneticLayerObject.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>chi_diag</em>, <em>m_prime</em>, <em>m_primeprime</em>, <em>theta_M</em>, <em>phi_M</em>, <em>d=None</em>, <em>sigma=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#MagneticLayerObject.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.MagneticLayerObject.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes the MagneticLayerObject with both diagonal-elements and off-diagonal elements given as magnetic terms <strong>m_prime</strong> and <strong>m_primeprime</strong> and the angles <strong>theta_M</strong> and <strong>phi_M</strong> which describe the direction of the magnetization.</p>
<p>See <em>Macke and Goering 2014, J.Phys.: Condens. Matter 26, 363201.</em> Eq. 11-14 for details.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>chi_diag</strong> (list of <a class="reference internal" href="parameters.html#Parameters.Parameter" title="Parameters.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters.Parameter</span></code></a>) – <p>Diagonal elements of electric susceptibility tensor of the layer.</p>
<ul>
<li><em>[chi]</em> sets <em>chi_xx = chi_yy = chi_zz = chi</em></li>
<li><em>[chi_xx,chi_yy,chi_z]</em> sets <em>chi_xx,chi_yy,chi_zz</em></li>
</ul>
</li>
<li><strong>m_prime</strong> (<a class="reference internal" href="parameters.html#Parameters.Parameter" title="Parameters.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters.Parameter</span></code></a>) – </li>
<li><strong>m_primeprime</strong> (<a class="reference internal" href="parameters.html#Parameters.Parameter" title="Parameters.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters.Parameter</span></code></a>) – Real and imaginary parts of the magnetic term.</li>
<li><strong>theta_M</strong> (<a class="reference internal" href="parameters.html#Parameters.Parameter" title="Parameters.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters.Parameter</span></code></a>) – </li>
<li><strong>phi_M</strong> (<a class="reference internal" href="parameters.html#Parameters.Parameter" title="Parameters.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters.Parameter</span></code></a>) – Angles which describe the direction of the magnetization measured in degrees. See also <a class="reference internal" href="../definitions/coordinate_systems.html"><span class="doc">Geometry / Coordinate System</span></a>.</li>
<li><strong>d</strong> (<a class="reference internal" href="parameters.html#Parameters.Parameter" title="Parameters.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters.Parameter</span></code></a>) – Thickness. Unit is the same as for every other length used throughout the project and is not predefined. E.g. wavelength.
<em>None</em> or <em>0</em> mean infinitively thick.</li>
<li><strong>sigma</strong> (<a class="reference internal" href="parameters.html#Parameters.Parameter" title="Parameters.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters.Parameter</span></code></a>) – The roughness of the upper surface of the layer. Has dimension of length. Unit: see <strong>d</strong>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="SampleRepresentation.ModelChiLayerObject">
<em class="property">class </em><code class="descclassname">SampleRepresentation.</code><code class="descname">ModelChiLayerObject</code><span class="sig-paren">(</span><em>chitensorfunction</em>, <em>d=None</em>, <em>sigma=None</em>, <em>magdir='0'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#ModelChiLayerObject"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.ModelChiLayerObject" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#SampleRepresentation.LayerObject" title="SampleRepresentation.LayerObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SampleRepresentation.LayerObject</span></code></a></p>
<p>Speciallized layer to deal with an electrical suszeptibility tensor (Chi) which is modelled as function of energy.</p>
<p>BEWARE: The inherited property <a class="reference internal" href="#SampleRepresentation.ModelChiLayerObject.chitensor" title="SampleRepresentation.ModelChiLayerObject.chitensor"><code class="xref py py-attr docutils literal notranslate"><span class="pre">chitensor</span></code></a> is now a function.</p>
<dl class="method">
<dt id="SampleRepresentation.ModelChiLayerObject.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>chitensorfunction</em>, <em>d=None</em>, <em>sigma=None</em>, <em>magdir='0'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#ModelChiLayerObject.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.ModelChiLayerObject.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>d</strong> (<a class="reference internal" href="parameters.html#Parameters.Parameter" title="Parameters.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters.Parameter</span></code></a>) – Thickness. Unit is the same as for every other length used throughout the project and is not predefined. E.g. wavelength.
<em>None</em> or <em>0</em> mean infinitively thick.</li>
<li><strong>sigma</strong> (<a class="reference internal" href="parameters.html#Parameters.Parameter" title="Parameters.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters.Parameter</span></code></a>) – The roughness of the upper surface of the layer. Has dimension of length. Unit: see <strong>d</strong>.</li>
<li><strong>chitensorfunction</strong> (<a class="reference internal" href="parameters.html#Parameters.ParametrizedFunction" title="Parameters.ParametrizedFunction"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters.ParametrizedFunction</span></code></a>) – <p>Energy-dependent electric susceptibility tensor of the layer.
A parametrized function of energy (see <a class="reference internal" href="parameters.html#Parameters.ParametrizedFunction" title="Parameters.ParametrizedFunction"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters.ParametrizedFunction</span></code></a>) which reurns a list of either 1,3,4 or 9 real or complex numbers.
See also documentation of <code class="xref py py-mod docutils literal notranslate"><span class="pre">Pythonreflectivity</span></code>.</p>
<ul>
<li><em>[chi]</em> sets <em>chi_xx = chi_yy = chi_zz = chi</em></li>
<li><em>[chi_xx,chi_yy,chi_z]</em> sets <em>chi_xx,chi_yy,chi_zz</em>, others are zero</li>
<li><em>[chi_xx,chi_yy,chi_z,chi_g]</em> sets  <em>chi_xx,chi_yy,chi_zz</em> and depending on <strong>magdir</strong>
<em>chi_yz=-chi_zy=chi_g</em> (if <em>x</em>), <em>chi_xz=-chi_zx=chi_g</em> (if <em>y</em>) or <em>chi_xz=-chi_zx=chi_g</em> (if <em>z</em>)</li>
<li><em>[chi_xx,chi_xy,chi_xz,chi_yx,chi_yy,chi_yz,chi_zx,chi_zy,chi_zz]</em> sets all the corresdonding elements</li>
</ul>
</li>
<li><strong>magdir</strong> (<em>str</em>) – Gives the magnetization direction for MOKE. Possible values are <em>“x”</em>, <em>“y”</em>, <em>“z”</em> and <em>“0”</em> (no magnetization).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="SampleRepresentation.ModelChiLayerObject.getChi">
<code class="descname">getChi</code><span class="sig-paren">(</span><em>fitpararray</em>, <em>energy</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#ModelChiLayerObject.getChi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.ModelChiLayerObject.getChi" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the electric susceptibility tensor as a list of numbers for a certain <strong>energy</strong> corresponding to the parameter values in <strong>fitpararray</strong> (see <a class="reference internal" href="parameters.html#module-Parameters" title="Parameters"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Parameters</span></code></a>).</p>
<p><strong>energy</strong> is measured in units of eV.</p>
</dd></dl>

<dl class="attribute">
<dt id="SampleRepresentation.ModelChiLayerObject.chitensor">
<code class="descname">chitensor</code><a class="headerlink" href="#SampleRepresentation.ModelChiLayerObject.chitensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Electric susceptibility tensor of the layer. Is an instance of <a class="reference internal" href="parameters.html#Parameters.ParametrizedFunction" title="Parameters.ParametrizedFunction"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters.ParametrizedFunction</span></code></a>. See <a class="reference internal" href="#SampleRepresentation.ModelChiLayerObject.__init__" title="SampleRepresentation.ModelChiLayerObject.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> for details.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="SampleRepresentation.AtomLayerObject">
<em class="property">class </em><code class="descclassname">SampleRepresentation.</code><code class="descname">AtomLayerObject</code><span class="sig-paren">(</span><em>densitydict={}</em>, <em>d=None</em>, <em>sigma=None</em>, <em>magdir='0'</em>, <em>densityunitfactor=1.0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#AtomLayerObject"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.AtomLayerObject" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#SampleRepresentation.LayerObject" title="SampleRepresentation.LayerObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SampleRepresentation.LayerObject</span></code></a></p>
<p>Speciallized layer class to deal with compositions of atoms and their energy dependent formfactors (which can be obtained from absorption spectra).</p>
<p>Especially usefull to deal with atomic layers, but can also be used for bulk.
The atoms and their formfactors have to be registered a the class (with registerAtom) before they can be used to instantiate a new AtomLayerObject.
The atom density can be plotted with <a class="reference internal" href="#SampleRepresentation.plotAtomDensity" title="SampleRepresentation.plotAtomDensity"><code class="xref py py-func docutils literal notranslate"><span class="pre">plotAtomDensity()</span></code></a>.
Density is measured in mol/cm$^3$ (as long as no <strong>densityunitfactor</strong> is applied)</p>
<p>Used formfactors can also be “magnetic formfactors” which only deal with diagonal elements of a formfactor tensor and simulate magnetic moments. See <a class="reference internal" href="#SampleRepresentation.MagneticFormfactor" title="SampleRepresentation.MagneticFormfactor"><code class="xref py py-class docutils literal notranslate"><span class="pre">MagneticFormfactor</span></code></a> and derived classes.</p>
<dl class="method">
<dt id="SampleRepresentation.AtomLayerObject.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>densitydict={}</em>, <em>d=None</em>, <em>sigma=None</em>, <em>magdir='0'</em>, <em>densityunitfactor=1.0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#AtomLayerObject.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.AtomLayerObject.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>densitydict</strong> – a dictionary which contains atom names (strings, must agree with before registered atoms) and densities (must be instances of <a class="reference internal" href="parameters.html#Parameters.Parameter" title="Parameters.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters.Parameter</span></code></a> or of a derived class).</li>
<li><strong>d</strong> (<a class="reference internal" href="parameters.html#Parameters.Parameter" title="Parameters.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters.Parameter</span></code></a>) – Thickness. Unit is the same as for every other length used throughout the project and is not predefined. E.g. wavelength.
<em>None</em> or <em>0</em> mean infinitively thick.</li>
<li><strong>sigma</strong> (<a class="reference internal" href="parameters.html#Parameters.Parameter" title="Parameters.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters.Parameter</span></code></a>) – The roughness of the upper surface of the layer. Has dimension of length. Unit: see <strong>d</strong>.</li>
<li><strong>densityunitfactor</strong> (<em>float</em>) – <p>If the densities in densitydict are measured in another unit than mol/cm^3, state this value which translates your generic density to the one used internally.
I.e.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">rho_in_mol_per_cubiccm</span> <span class="o">=</span> <span class="n">densityunitfactor</span> <span class="o">*</span> <span class="n">rho_in_whateverunityouwant</span>
</pre></div>
</div>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="SampleRepresentation.AtomLayerObject.getDensitydict">
<code class="descname">getDensitydict</code><span class="sig-paren">(</span><em>fitpararray=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#AtomLayerObject.getDensitydict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.AtomLayerObject.getDensitydict" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the density dictionary either with evaluated paramters (needs <strong>fitpararray</strong>) or with the raw <a class="reference internal" href="parameters.html#Parameters.Parameter" title="Parameters.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters.Parameter</span></code></a> objects (use <strong>fitparraray</strong> = <em>None</em>).</p>
</dd></dl>

<dl class="method">
<dt id="SampleRepresentation.AtomLayerObject.getChi">
<code class="descname">getChi</code><span class="sig-paren">(</span><em>fitpararray</em>, <em>energy</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#AtomLayerObject.getChi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.AtomLayerObject.getChi" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the electric susceptibility tensor as a list of numbers for a certain <strong>energy</strong> corresponding to the parameter values in <strong>fitpararray</strong> (see <a class="reference internal" href="parameters.html#module-Parameters" title="Parameters"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Parameters</span></code></a>).</p>
<p><strong>energy</strong> is measured in units of eV.</p>
</dd></dl>

<dl class="classmethod">
<dt id="SampleRepresentation.AtomLayerObject.registerAtom">
<em class="property">classmethod </em><code class="descname">registerAtom</code><span class="sig-paren">(</span><em>name</em>, <em>formfactor=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#AtomLayerObject.registerAtom"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.AtomLayerObject.registerAtom" title="Permalink to this definition">¶</a></dt>
<dd><p>Register an atom called <strong>name</strong> for later use to instantiate an AtomLayerObject.</p>
<p><strong>formfactor</strong> as to be an instance of <a class="reference internal" href="#SampleRepresentation.Formfactor" title="SampleRepresentation.Formfactor"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formfactor</span></code></a> or of a derived class.
If no formfactor object is given, an instance of <a class="reference internal" href="#SampleRepresentation.FFfromChantler" title="SampleRepresentation.FFfromChantler"><code class="xref py py-class docutils literal notranslate"><span class="pre">FFfromChantler</span></code></a> will be created with <strong>name</strong> as element name.
This can be used for an easy registration of atoms with just their tabulated formfactors from the Chantler tables.</p>
</dd></dl>

<dl class="classmethod">
<dt id="SampleRepresentation.AtomLayerObject.getAtom">
<em class="property">classmethod </em><code class="descname">getAtom</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#AtomLayerObject.getAtom"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.AtomLayerObject.getAtom" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the <a class="reference internal" href="#SampleRepresentation.Formfactor" title="SampleRepresentation.Formfactor"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formfactor</span></code></a> object registered for atom <strong>name</strong>.</p>
</dd></dl>

<dl class="classmethod">
<dt id="SampleRepresentation.AtomLayerObject.getAtomNames">
<em class="property">classmethod </em><code class="descname">getAtomNames</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#AtomLayerObject.getAtomNames"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.AtomLayerObject.getAtomNames" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of names of registered atoms.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="SampleRepresentation.Formfactor">
<em class="property">class </em><code class="descclassname">SampleRepresentation.</code><code class="descname">Formfactor</code><a class="reference internal" href="../_modules/SampleRepresentation.html#Formfactor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.Formfactor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Base class to deal with energy-dependent atomic form-factors.</p>
<p>This base class is an abstract class an cannot be used directly.
The user should derive from this class if he wants to build his own models.</p>
<p>See <a class="reference internal" href="../definitions/formfactors.html"><span class="doc">Formfactor and Susceptibility</span></a> for sign conventions.</p>
<dl class="method">
<dt id="SampleRepresentation.Formfactor.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#Formfactor.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.Formfactor.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="SampleRepresentation.Formfactor.getFF">
<code class="descname">getFF</code><span class="sig-paren">(</span><em>energy</em>, <em>fitpararray=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#Formfactor.getFF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.Formfactor.getFF" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the formfactor for <strong>energy</strong> corresponding to <strong>fitpararray</strong> (if it depends on it) as 9-element Numpy array of complex numbers.</p>
<p><strong>energy</strong> is measured in units of eV.</p>
</dd></dl>

<dl class="method">
<dt id="SampleRepresentation.Formfactor.plotFF">
<code class="descname">plotFF</code><span class="sig-paren">(</span><em>fitpararray=None</em>, <em>energies=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#Formfactor.plotFF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.Formfactor.plotFF" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the energy-dependent formfactor with the energies (in eV) listed in the list/array <strong>energies</strong>. If this array is not given the plot covers the hole existing energy-range.
The <strong>fitpararray</strong> has only to be given in cases where the formfactor depends on a fitparamter, e.g. for class:<cite>FFfromScaledAbsorption</cite>.</p>
</dd></dl>

<dl class="attribute">
<dt id="SampleRepresentation.Formfactor.maxE">
<code class="descname">maxE</code><a class="headerlink" href="#SampleRepresentation.Formfactor.maxE" title="Permalink to this definition">¶</a></dt>
<dd><p>Upper limit of stored energy range. Read-only.</p>
</dd></dl>

<dl class="attribute">
<dt id="SampleRepresentation.Formfactor.minE">
<code class="descname">minE</code><a class="headerlink" href="#SampleRepresentation.Formfactor.minE" title="Permalink to this definition">¶</a></dt>
<dd><p>Lower limit of stored energy range. Read-only.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="SampleRepresentation.FFfromFile">
<em class="property">class </em><code class="descclassname">SampleRepresentation.</code><code class="descname">FFfromFile</code><span class="sig-paren">(</span><em>filename</em>, <em>linereaderfunction=None</em>, <em>energyshift=PyXMRTool.Parameters.Parameter</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#FFfromFile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.FFfromFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#SampleRepresentation.Formfactor" title="SampleRepresentation.Formfactor"><code class="xref py py-class docutils literal notranslate"><span class="pre">SampleRepresentation.Formfactor</span></code></a></p>
<p>Class to deal with energy-dependent atomic form-factors (entire tensor) which are tabulated in files. See <a class="reference internal" href="../definitions/formfactors.html"><span class="doc">Formfactor and Susceptibility</span></a> for sign conventions.</p>
<dl class="method">
<dt id="SampleRepresentation.FFfromFile.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>filename</em>, <em>linereaderfunction=None</em>, <em>energyshift=PyXMRTool.Parameters.Parameter</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#FFfromFile.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.FFfromFile.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes the FFfromFile object with an energy-dependent formfactor given as file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> (<em>str</em>) – Path to the text file which contains the formfactor.</li>
<li><strong>linereaderfunction</strong> (<em>callable</em>) – This function is used to convert one line from the text file to data.
It should be a function which takes a string and returns a tuple or list of 10 values: <code class="docutils literal notranslate"><span class="pre">(energy,f_xx,f_xy,f_xz,f_yx,f_yy,f_yz,f_zx,f_zy,f_zz)</span></code>,
where <cite>energy</cite> is measured in units of <cite>eV</cite> and formfactors are complex values in units of <cite>e/atom</cite> (dimensionless).
It can also return <cite>None</cite> if it detects a comment line.
You can use <a class="reference internal" href="#SampleRepresentation.FFfromFile.createLinereader" title="SampleRepresentation.FFfromFile.createLinereader"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FFfromFile.createLinereader()</span></code></a> to get a standard function, which just reads this array as whitespace seperated from the line.</li>
<li><strong>energyshift</strong> (<a class="reference internal" href="parameters.html#Parameters.Parameter" title="Parameters.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters.Parameter</span></code></a>) – Species a fittable energyshift between the energy-dependent formfactor from <strong>filename</strong> and the <cite>real</cite> one in the reflectivity measurement.
So the formfactor delivered from <a class="reference internal" href="#SampleRepresentation.FFfromFile.getFF" title="SampleRepresentation.FFfromFile.getFF"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FFfromFile.getFF()</span></code></a> will not be <cite>formfactor_from_file(E)</cite> but <cite>formfactor_from_file(E-energyshift)</cite>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="SampleRepresentation.FFfromFile.createLinereader">
<em class="property">static </em><code class="descname">createLinereader</code><span class="sig-paren">(</span><em>complex_numbers=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#FFfromFile.createLinereader"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.FFfromFile.createLinereader" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the standard linereader function for usage with <a class="reference internal" href="#SampleRepresentation.FFfromFile.__init__" title="SampleRepresentation.FFfromFile.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FFfromFile.__init__()</span></code></a>.</p>
<p>This standard linereader function reads energy and complex elements of the formfactor tensor as a whitespace-seperated list (i.e. 10 numbers) and interpretes “#” as comment sign.
If <strong>complex_numbers</strong> = <em>False</em> then the reader reads real and imaginary part of every element seperately, i.e. every line has to consist of 19 numbers seperated by whitespaces:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">energy</span> <span class="n">f_xx_real</span> <span class="n">ff_xx_im</span> <span class="o">...</span> <span class="n">f_zy_real</span> <span class="n">f_zy_im</span> <span class="n">f_zz_real</span> <span class="n">f_zz_im</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="SampleRepresentation.FFfromFile.getFF">
<code class="descname">getFF</code><span class="sig-paren">(</span><em>energy</em>, <em>fitpararray=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#FFfromFile.getFF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.FFfromFile.getFF" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the (energy-shifted )formfactor for <strong>energy</strong> as an interpolation between the stored values from file as 9-element 1-D numpy array of complex numbers.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>energy</strong> (<em>float</em>) – Measured in units of eV.</li>
<li><strong>fitpararray</strong> – Is actually only needed when an energyshift has been defined.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="SampleRepresentation.FFfromFile.maxE">
<code class="descname">maxE</code><a class="headerlink" href="#SampleRepresentation.FFfromFile.maxE" title="Permalink to this definition">¶</a></dt>
<dd><p>Upper limit of stored energy range. Read-only.</p>
</dd></dl>

<dl class="attribute">
<dt id="SampleRepresentation.FFfromFile.minE">
<code class="descname">minE</code><a class="headerlink" href="#SampleRepresentation.FFfromFile.minE" title="Permalink to this definition">¶</a></dt>
<dd><p>Lower limit of stored energy range. Read-only.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="SampleRepresentation.FFfromChantler">
<em class="property">class </em><code class="descclassname">SampleRepresentation.</code><code class="descname">FFfromChantler</code><span class="sig-paren">(</span><em>element_symbol</em>, <em>energyshift=PyXMRTool.Parameters.Parameter</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#FFfromChantler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.FFfromChantler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#SampleRepresentation.FFfromFile" title="SampleRepresentation.FFfromFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">SampleRepresentation.FFfromFile</span></code></a></p>
<p>Class to create an atomic formfactor for an element from  Database (Chantler Tables taken from <a class="reference external" href="https://dx.doi.org/10.18434/T4HS32">https://dx.doi.org/10.18434/T4HS32</a>).</p>
<dl class="method">
<dt id="SampleRepresentation.FFfromChantler.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>element_symbol</em>, <em>energyshift=PyXMRTool.Parameters.Parameter</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#FFfromChantler.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.FFfromChantler.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes the FFfromChantler object with an energy-dependent formfactor corresponding to the element given with <strong>element_symbol</strong>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>element_symbol</strong> (<em>str</em>) – Refers to the element of which the atomic formfactor should be looked up. (More specifically: name of the corresponding database file without suffix.)</li>
<li><strong>energyshift</strong> (<a class="reference internal" href="parameters.html#Parameters.Parameter" title="Parameters.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters.Parameter</span></code></a>) – Species a fittable energyshift between the energy-dependent formfactor from Chantler Tables and the <cite>real</cite> one in the reflectivity measurement.
So the formfactor delivered from <code class="xref py py-meth docutils literal notranslate"><span class="pre">FFfromChantler.getFF()</span></code> will not be <cite>formfactor_from_database(E)</cite> but <cite>formfactor_from_databayse(E-energyshift)</cite>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="SampleRepresentation.FFfromScaledAbsorption">
<em class="property">class </em><code class="descclassname">SampleRepresentation.</code><code class="descname">FFfromScaledAbsorption</code><span class="sig-paren">(</span><em>element_symbol</em>, <em>E1</em>, <em>E2</em>, <em>E3</em>, <em>scaling_factor</em>, <em>absorption_filename</em>, <em>absorption_linereaderfunction=None</em>, <em>energyshift=PyXMRTool.Parameters.Parameter</em>, <em>autofitfunction=None</em>, <em>autofitrange=None</em>, <em>tabulated_filename=None</em>, <em>tabulated_linereaderfunction=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#FFfromScaledAbsorption"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.FFfromScaledAbsorption" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#SampleRepresentation.Formfactor" title="SampleRepresentation.Formfactor"><code class="xref py py-class docutils literal notranslate"><span class="pre">SampleRepresentation.Formfactor</span></code></a></p>
<p>A formfactor class which uses the imaginary part of the formfactor (experimentally determined absorption signal which has been fitted to off-resonant values) given as a file, scales it with a fittable factor and calculates the real part by the Kramers-Kronig transformation. It realizes the procedure described in section 3.3 of Martin Zwiebler PhD-Thesis.
It thereby deals only with the diagonal elements of the formfactor tensor. For the off-diagonal elements, the magnetic formfactors classes are used.</p>
<p>See <a class="reference internal" href="../definitions/formfactors.html"><span class="doc">Formfactor and Susceptibility</span></a> for sign conventions.</p>
<dl class="method">
<dt id="SampleRepresentation.FFfromScaledAbsorption.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>element_symbol</em>, <em>E1</em>, <em>E2</em>, <em>E3</em>, <em>scaling_factor</em>, <em>absorption_filename</em>, <em>absorption_linereaderfunction=None</em>, <em>energyshift=PyXMRTool.Parameters.Parameter</em>, <em>autofitfunction=None</em>, <em>autofitrange=None</em>, <em>tabulated_filename=None</em>, <em>tabulated_linereaderfunction=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#FFfromScaledAbsorption.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.FFfromScaledAbsorption.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes the FFfromScaledAbsorption object with an energy-dependent imaginary part of the formfactor given as file.</p>
<p>To perform the Kramers-Kronig transformation without integrating to infinity, theoretical/tabulated formfactors (Chantler tabels from <a class="reference external" href="https://dx.doi.org/10.18434/T4HS32">https://dx.doi.org/10.18434/T4HS32</a>) are used. Their imaginary part differs only close to resonance from the measured absorption and should have been used before to perform the fit of the measured absorption to off-resonant values.</p>
<p>The imaginary part of each element of the formfactor is:</p>
<ul class="simple">
<li>the value given by <strong>Im_f0_E1</strong>, for energy &lt; <strong>E1</strong>.</li>
<li>the value given by the file scaled by <strong>scaling_factor</strong> (roughly, see PhD Thesis of Martin Zwiebler,section 3.3, for details), for E1 &lt;= energy &lt;= E2</li>
<li>linear inperpolation between the scaled value at E2 and the value given for E3 by <strong>Im_f0_E3</strong>, for E2 &lt; energy &lt; E3</li>
<li>the value given by <strong>Im_f0_E3</strong>, for E3 &lt; energy</li>
</ul>
<p>The Kramers-Kronig transformation to obtain the real part is done only once during instantiation. Therefore, it does not have to be repeated with every value of the <strong>scaling_factor</strong> and fitting is fast.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>element_symbol</strong> (<em>string</em>) – States the chemical element for which this formfactor is created as usual short version of its name. It is important to lookup the tabulated/theoretical reference formfactors from the Chantler tables. If you want to use your own formfactor as reference (see arguments <strong>tabulated_filename</strong> and <strong>tabulated_linereaderfunction</strong>) just enter an empty string here.</li>
<li><strong>E1</strong> (<em>float</em>) – Energy in eV. From this energy on the energy-dependent imaginary part of the formfactor given as file is used and scaled.</li>
<li><strong>E2</strong> (<em>float</em>) – Energy in eV. From this energy on the imaginary part of the formfactor is linearly interpolated.</li>
<li><strong>E3</strong> (<em>float</em>) – Energy in eV. From this energy on the imaginary part of the formactor is constant <strong>Im_f_E3</strong>.</li>
<li><strong>scaling_factor</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Parameter.Parameter</span></code>) – Specifies the fittable scaling factor (called <em>a</em> in Martin Zwiebler PhD Thesis).</li>
<li><strong>absorption_filename</strong> (<em>str</em>) – Path to the text file which contains the imaginary part of the formfactor which results from an apsorption measurement and a subsequent fit to off-resonant tabulated values.</li>
<li><strong>absorption_linereaderfunction</strong> (<em>callable</em>) – This function is used to convert one line from the <em>absorption</em> text file to data.
It should be a function which takes a string and returns a tuple or list of 4 values: <code class="docutils literal notranslate"><span class="pre">(energy,</span> <span class="pre">Im</span> <span class="pre">f_xx,</span> <span class="pre">Im</span> <span class="pre">f_yy,</span> <span class="pre">Im</span> <span class="pre">f_zz)</span></code>,
where <cite>energy</cite> is measured in units of <cite>eV</cite> and imaginary parts of formfactors are real values in units of <cite>e/atom</cite> (dimensionless).
It can also return <cite>None</cite> if it detects a comment line.
You can use <a class="reference internal" href="#SampleRepresentation.FFfromScaledAbsorption.createAbsorptionLinereader" title="SampleRepresentation.FFfromScaledAbsorption.createAbsorptionLinereader"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FFfromScaledAbsorption.createAbsorptionLinereader()</span></code></a> to get a standard function, which just reads this array as whitespace seperated from the line. This is actually the default if you give ‘None’.</li>
<li><strong>energyshift</strong> (<a class="reference internal" href="parameters.html#Parameters.Parameter" title="Parameters.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters.Parameter</span></code></a>) – Species a fittable energyshift between the energy-dependent formfactor calculated by the whole above mentioned procedure and the <cite>real</cite> one in the reflectivity measurement.
As a consequence the peak but also E1,E2 and E3 are shifted.</li>
<li><strong>autofitfunction</strong> (<em>callable</em>) – </li>
<li><strong>autofitrange</strong> (<em>float</em>) – If given together with <strong>autofitfunction</strong>, the absorbtion from <strong>absorbtion_filename</strong> will be fitted to the imaginary part of the formfactors from Chantler tables or <strong>tabulated_filename</strong> just below/above <strong>E1</strong>/<strong>E3</strong> in a range given by <strong>autofitrange</strong> in eV.
More specifically <strong>autofifunction</strong> will be fitted to the f2 of the Chantler tables.
<strong>autofitfunction</strong> must work as following <em>f2=func(energy,absorbtion,a,b,c,…)</em>. <em>absorbtion</em> is the measured absorbtion/TEY/FY/… at a certain <em>energy</em> and <em>a</em>,*b*,*c*, … are an arbitrary number of parameters.
The parameters will be fitted such that the return values fit best to the f2 of the Chantler tables in the given energy-range.
E.g. a standard fitfunction would be: <em>f2(E) = absorbtion*energy*a + b + c</em> energy. (see Martin Zwiebler PhD-Thesis, section 3.3)</li>
<li><strong>tabulated_filename</strong> (<em>str</em>) – Path to the text file which contains the tabulated/theoretical formfactor for the corresponding element.
You can use this argument if you dont’t want to use the standard Chantler tables. But therefore <strong>element_symbol</strong> has to be an empty string</li>
<li><strong>tabulated_linereaderfunction</strong> (<em>callable</em>) – This function is used to convert one line from the <em>tabulated</em> text file to data.
It should be a function which takes a string and returns a tuple or list of 2 values: <code class="docutils literal notranslate"><span class="pre">(energy,f)</span></code>,
where <cite>energy</cite> is measured in units of <cite>eV</cite> and the formfactor <cite>f</cite> is a complex value in units of <cite>e/atom</cite> (dimensionless).
It can also return <cite>None</cite> if it detects a comment line.
You can use <a class="reference internal" href="#SampleRepresentation.FFfromScaledAbsorption.createTabulatedLinereader" title="SampleRepresentation.FFfromScaledAbsorption.createTabulatedLinereader"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FFfromScaledAbsorption.createTabulatedLinereader()</span></code></a> to get a standard function, which just reads this array as whitespace separated from the line. This is actually the default if you give ‘None’.
You can use this argument if you dont’t want to use the standard Chantler tables and want to create your own linereader.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="SampleRepresentation.FFfromScaledAbsorption.createAbsorptionLinereader">
<em class="property">static </em><code class="descname">createAbsorptionLinereader</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#FFfromScaledAbsorption.createAbsorptionLinereader"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.FFfromScaledAbsorption.createAbsorptionLinereader" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the standard linereader function for absorption files for usage with <a class="reference internal" href="#SampleRepresentation.FFfromScaledAbsorption.__init__" title="SampleRepresentation.FFfromScaledAbsorption.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FFfromScaledAbsorption.__init__()</span></code></a>.</p>
<p>This standard linereader function reads energy and elements of the imaginary part of the formfactor tensor as a whitespace-seperated list (i.e. 4 numbers) and interpretes “#” as comment sign.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="SampleRepresentation.FFfromScaledAbsorption.createTabulatedLinereader">
<em class="property">static </em><code class="descname">createTabulatedLinereader</code><span class="sig-paren">(</span><em>complex_numbers=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#FFfromScaledAbsorption.createTabulatedLinereader"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.FFfromScaledAbsorption.createTabulatedLinereader" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the standard linereader function for tabulated formfactor files for usage with <a class="reference internal" href="#SampleRepresentation.FFfromScaledAbsorption.__init__" title="SampleRepresentation.FFfromScaledAbsorption.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FFfromScaledAbsorption.__init__()</span></code></a>.</p>
<p>This standard linereader function reads energy and the complex formfactor as a whitespace-seperated list (i.e. 2 numbers) and interpretes “#” as comment sign.
If <strong>complex_numbers</strong> = <em>False</em> then the reader reads real and imaginary part of the formfactor seperately, i.e. every line has to consist of 3 numbers seperated by whitespaces:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">energy</span> <span class="n">ff_real</span> <span class="n">ff_im</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="SampleRepresentation.FFfromScaledAbsorption.getFF">
<code class="descname">getFF</code><span class="sig-paren">(</span><em>energy</em>, <em>fitpararray</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#FFfromScaledAbsorption.getFF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.FFfromScaledAbsorption.getFF" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the (energy-shifted )formfactor for <strong>energy</strong> as an interpolation between the stored values from file as 9-element 1-D numpy array of complex numbers.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>energy</strong> (<em>float</em>) – Measured in units of eV.</li>
<li><strong>fitpararray</strong> – Is needed for the scaling factor ‘a’ and an energy shift if defined.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="SampleRepresentation.FFfromScaledAbsorption.maxE">
<code class="descname">maxE</code><a class="headerlink" href="#SampleRepresentation.FFfromScaledAbsorption.maxE" title="Permalink to this definition">¶</a></dt>
<dd><p>Upper limit of stored energy range. Read-only.</p>
</dd></dl>

<dl class="attribute">
<dt id="SampleRepresentation.FFfromScaledAbsorption.minE">
<code class="descname">minE</code><a class="headerlink" href="#SampleRepresentation.FFfromScaledAbsorption.minE" title="Permalink to this definition">¶</a></dt>
<dd><p>Lower limit of stored energy range. Read-only.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="SampleRepresentation.FFfromFitableModel">
<em class="property">class </em><code class="descclassname">SampleRepresentation.</code><code class="descname">FFfromFitableModel</code><span class="sig-paren">(</span><em>ff_tensor_function</em>, <em>minE</em>, <em>maxE</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#FFfromFitableModel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.FFfromFitableModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#SampleRepresentation.Formfactor" title="SampleRepresentation.Formfactor"><code class="xref py py-class docutils literal notranslate"><span class="pre">SampleRepresentation.Formfactor</span></code></a></p>
<p>Formfactor class which can used to implement a fittable model for the formfactor as e.g. a Kramers-Kronig variational approach with triangles (see Stone et al., PRB 86, 024102 (2012).</p>
<p>The class just take the complex formfactor tensor as <a class="reference internal" href="parameters.html#Parameters.ParametrizedFunction" title="Parameters.ParametrizedFunction"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters.ParametrizedFunction</span></code></a>, which is a function dependent on fitparameters.</p>
<p>See <a class="reference internal" href="../definitions/formfactors.html"><span class="doc">Formfactor and Susceptibility</span></a> for sign conventions.</p>
<dl class="method">
<dt id="SampleRepresentation.FFfromFitableModel.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>ff_tensor_function</em>, <em>minE</em>, <em>maxE</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#FFfromFitableModel.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.FFfromFitableModel.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ff_tensor_function</strong> (<a class="reference internal" href="parameters.html#Parameters.ParametrizedFunction" title="Parameters.ParametrizedFunction"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters.ParametrizedFunction</span></code></a>) – Energy-dependent complex formfactor tensor. A parametrized funtion of energy  (see <a class="reference internal" href="parameters.html#Parameters.ParametrizedFunction" title="Parameters.ParametrizedFunction"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters.ParametrizedFunction</span></code></a>) which reurns a list of 9 complex numbers.</li>
<li><strong>minE</strong> (<em>float</em>) – </li>
<li><strong>maxE</strong> (<em>float</em>) – Gives the boundaries of the valid energy-range of the given ff_tensor_function.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="SampleRepresentation.FFfromFitableModel.getFF">
<code class="descname">getFF</code><span class="sig-paren">(</span><em>energy</em>, <em>fitpararray=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#FFfromFitableModel.getFF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.FFfromFitableModel.getFF" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the formfactor for <strong>energy</strong> corresponding to <strong>fitpararray</strong> (if it depends on it) as 9-element Numpy array of complex numbers.</p>
<p><strong>energy</strong> is measured in units of eV.</p>
</dd></dl>

<dl class="attribute">
<dt id="SampleRepresentation.FFfromFitableModel.maxE">
<code class="descname">maxE</code><a class="headerlink" href="#SampleRepresentation.FFfromFitableModel.maxE" title="Permalink to this definition">¶</a></dt>
<dd><p>Upper limit of stored energy range. Read-only.</p>
</dd></dl>

<dl class="attribute">
<dt id="SampleRepresentation.FFfromFitableModel.minE">
<code class="descname">minE</code><a class="headerlink" href="#SampleRepresentation.FFfromFitableModel.minE" title="Permalink to this definition">¶</a></dt>
<dd><p>Lower limit of stored energy range. Read-only.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="SampleRepresentation.MagneticFormfactor">
<em class="property">class </em><code class="descclassname">SampleRepresentation.</code><code class="descname">MagneticFormfactor</code><span class="sig-paren">(</span><em>m_prime</em>, <em>m_primeprime</em>, <em>theta_M</em>, <em>phi_M</em>, <em>minE</em>, <em>maxE</em>, <em>energyshift=PyXMRTool.Parameters.Parameter</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#MagneticFormfactor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.MagneticFormfactor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#SampleRepresentation.Formfactor" title="SampleRepresentation.Formfactor"><code class="xref py py-class docutils literal notranslate"><span class="pre">SampleRepresentation.Formfactor</span></code></a></p>
<p>Base class to deal with energy-dependent magnetic form-factors, i.e. only off-diagonal elements of a formfactor tensor originating from the magnetization.</p>
<dl class="method">
<dt id="SampleRepresentation.MagneticFormfactor.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>m_prime</em>, <em>m_primeprime</em>, <em>theta_M</em>, <em>phi_M</em>, <em>minE</em>, <em>maxE</em>, <em>energyshift=PyXMRTool.Parameters.Parameter</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#MagneticFormfactor.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.MagneticFormfactor.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes the MagneticFormfactor with energy-dependent magnetic terms <strong>m_prime</strong> and <strong>m_primeprime</strong> and the angles <strong>theta_M</strong> and <strong>phi_M</strong> which describe the direction of the magnetization.</p>
<p>See <em>Macke and Goering 2014, J.Phys.: Condens. Matter 26, 363201.</em> Eq. 11-14 for details.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>m_prime</strong> (<a class="reference internal" href="parameters.html#Parameters.ParametrizedFunction" title="Parameters.ParametrizedFunction"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters.ParametrizedFunction</span></code></a>) – </li>
<li><strong>m_primeprime</strong> (<a class="reference internal" href="parameters.html#Parameters.ParametrizedFunction" title="Parameters.ParametrizedFunction"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters.ParametrizedFunction</span></code></a>) – Real and imaginary parts of the magnetic term. Given as parametrized functions of energy. See also <a class="reference internal" href="../definitions/coordinate_systems.html"><span class="doc">Geometry / Coordinate System</span></a>.</li>
<li><strong>theta_M</strong> (<a class="reference internal" href="parameters.html#Parameters.Parameter" title="Parameters.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters.Parameter</span></code></a>) – </li>
<li><strong>phi_M</strong> (<a class="reference internal" href="parameters.html#Parameters.Parameter" title="Parameters.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters.Parameter</span></code></a>) – Angles which describe the direction of the magnetization measured in degrees.</li>
<li><strong>minE</strong> (<em>float</em>) – </li>
<li><strong>maxE</strong> (<em>float</em>) – Lower and upper limits of the energy range for which the formfactor is defined.</li>
<li><strong>energyshift</strong> (<a class="reference internal" href="parameters.html#Parameters.Parameter" title="Parameters.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters.Parameter</span></code></a>) – Species a fittable energyshift between the energy-dependent formfactor created from the XMCD measurement and the <cite>real</cite> one in the reflectivity measurement.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="SampleRepresentation.MagneticFormfactor.getFF">
<code class="descname">getFF</code><span class="sig-paren">(</span><em>energy</em>, <em>fitpararray=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#MagneticFormfactor.getFF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.MagneticFormfactor.getFF" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the magnetic part of the formfactor for <strong>energy</strong> corresponding to <strong>fitpararray</strong> (if it depends on it) as 9-element list of complex numbers.</p>
<p>The diagonal elements are all zero here.</p>
<p><strong>energy</strong> is measured in units of eV.</p>
</dd></dl>

<dl class="attribute">
<dt id="SampleRepresentation.MagneticFormfactor.maxE">
<code class="descname">maxE</code><a class="headerlink" href="#SampleRepresentation.MagneticFormfactor.maxE" title="Permalink to this definition">¶</a></dt>
<dd><p>Upper limit of stored energy range. Read-only.</p>
</dd></dl>

<dl class="attribute">
<dt id="SampleRepresentation.MagneticFormfactor.minE">
<code class="descname">minE</code><a class="headerlink" href="#SampleRepresentation.MagneticFormfactor.minE" title="Permalink to this definition">¶</a></dt>
<dd><p>Lower limit of stored energy range. Read-only.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="SampleRepresentation.MFFfromXMCD">
<em class="property">class </em><code class="descclassname">SampleRepresentation.</code><code class="descname">MFFfromXMCD</code><span class="sig-paren">(</span><em>theta_M</em>, <em>phi_M</em>, <em>filename</em>, <em>linereaderfunction=None</em>, <em>energyshift=PyXMRTool.Parameters.Parameter</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#MFFfromXMCD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.MFFfromXMCD" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#SampleRepresentation.MagneticFormfactor" title="SampleRepresentation.MagneticFormfactor"><code class="xref py py-class docutils literal notranslate"><span class="pre">SampleRepresentation.MagneticFormfactor</span></code></a></p>
<p>Class to deal with a magnetic formfactor (MFF) derived from an XMCD measurement.</p>
<p>BEWARE: The absolut values are only correct if you scaled the XMCD signal to tabulated absorbtion data. But usually it is enough to get relative values, which can give you magnetization profiles.</p>
<dl class="method">
<dt id="SampleRepresentation.MFFfromXMCD.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>theta_M</em>, <em>phi_M</em>, <em>filename</em>, <em>linereaderfunction=None</em>, <em>energyshift=PyXMRTool.Parameters.Parameter</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#MFFfromXMCD.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.MFFfromXMCD.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes the MFF from an XMCD measurement given as textfile.</p>
<p>The XMCD values are directly used to create the <strong>m_primeprime</strong> function.</p>
<p>The <strong>m_prime</strong> function is found as Kramers-Kronig transformation of <strong>m_primeprime</strong>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>phi_M</strong> (<em>theta_M</em><em>,</em>) – Angles which describe the direction of the magnetization measured in degrees. See also <a class="reference internal" href="../definitions/coordinate_systems.html"><span class="doc">Geometry / Coordinate System</span></a>.</li>
<li><strong>filename</strong> (<em>str</em>) – Path to the text file which contains the XMCD signal as function of energy.</li>
<li><strong>linereaderfunction</strong> (<em>callable</em>) – This function is used to convert one line from the <em>xmcd</em> text file to data.
It should be a function which takes a string and returns a tuple or list of 2 values: <code class="docutils literal notranslate"><span class="pre">(energy,</span> <span class="pre">xmcd)</span></code>,
where <cite>energy</cite> is measured in units of <cite>eV</cite> and ‘xmcd’ is a real value in units of <cite>e/atom</cite> (dimensionless) (if it is scaled correctly).
It can also return <cite>None</cite> if it detects a comment line.
You can use <a class="reference internal" href="#SampleRepresentation.MFFfromXMCD.createLinereader" title="SampleRepresentation.MFFfromXMCD.createLinereader"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MFFfromXMCD.createLinereader()</span></code></a> to get a standard function, which just reads this array as whitespace seperated from the line.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="SampleRepresentation.MFFfromXMCD.createLinereader">
<em class="property">static </em><code class="descname">createLinereader</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#MFFfromXMCD.createLinereader"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.MFFfromXMCD.createLinereader" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the standard linereader function for xmcd files for usage with <a class="reference internal" href="#SampleRepresentation.MFFfromXMCD.__init__" title="SampleRepresentation.MFFfromXMCD.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MFFfromXMCD.__init__()</span></code></a>.</p>
<p>This standard linereader function reads energy and xmcd value as a whitespace-seperated list (i.e. 2 numbers) and interpretes “#” as comment sign.</p>
</dd></dl>

<dl class="attribute">
<dt id="SampleRepresentation.MFFfromXMCD.maxE">
<code class="descname">maxE</code><a class="headerlink" href="#SampleRepresentation.MFFfromXMCD.maxE" title="Permalink to this definition">¶</a></dt>
<dd><p>Upper limit of stored energy range. Read-only.</p>
</dd></dl>

<dl class="attribute">
<dt id="SampleRepresentation.MFFfromXMCD.minE">
<code class="descname">minE</code><a class="headerlink" href="#SampleRepresentation.MFFfromXMCD.minE" title="Permalink to this definition">¶</a></dt>
<dd><p>Lower limit of stored energy range. Read-only.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="SampleRepresentation.chantler_fNT_reader">
<code class="descclassname">SampleRepresentation.</code><code class="descname">chantler_fNT_reader</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#SampleRepresentation.chantler_fNT_reader" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the nuclear Thomson correction to the real part of the formfactor from the chantler table given with <strong>filename</strong>.
Re(f)=f1+f_rel+f_NT   for the forward direction. See “Chantler, Journal fo Physical and Chemical Reference Data 24,71 (1995)” Eq.3 and following.
f_rel and f_NT are small corrections for light atoms but get relevant with increasing mass.</p>
</dd></dl>

<dl class="function">
<dt id="SampleRepresentation.chantler_frel_reader">
<code class="descclassname">SampleRepresentation.</code><code class="descname">chantler_frel_reader</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#SampleRepresentation.chantler_frel_reader" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the relativistic correction to the real part of the formfactor from the chantler table given with <strong>filename</strong>.
Re(f)=f1+f_rel+f_NT   for the forward direction. See “Chantler, Journal fo Physical and Chemical Reference Data 24,71 (1995)” Eq.3 and following.
f_rel and f_NT are small corrections for light atoms but get relevant with increasing mass.</p>
</dd></dl>

<dl class="function">
<dt id="SampleRepresentation.chantler_linereader">
<code class="descclassname">SampleRepresentation.</code><code class="descname">chantler_linereader</code><span class="sig-paren">(</span><em>line</em><span class="sig-paren">)</span><a class="headerlink" href="#SampleRepresentation.chantler_linereader" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the tuple (energy, f1, f2) from one line of a Chantler Table.
BEWARE: While the imaginary part of the formfactor Im(f)=f2, the real part contains also corrections
Re(f)=f1+f_rel+f_NT   for the forward direction. See “Chantler, Journal fo Physical and Chemical Reference Data 24,71 (1995)” Eq.3 and following.
f_rel and f_NT are small corrections for light atoms but get relevant with increasing mass.
BEWARE: The sign convention differs from the one used within PyXMRTool. See also <a class="reference internal" href="../definitions/formfactors.html"><span class="doc">Formfactor and Susceptibility</span></a>. This linereader still delivers the “raw data” without sign conversion.</p>
</dd></dl>

<dl class="class">
<dt id="SampleRepresentation.DensityProfile">
<em class="property">class </em><code class="descclassname">SampleRepresentation.</code><code class="descname">DensityProfile</code><span class="sig-paren">(</span><em>start_layer_idx</em>, <em>end_layer_idx</em>, <em>layer_thickness</em>, <em>profile_function</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#DensityProfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.DensityProfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>This class can be used to generate arbitrary density profiles within a stack of several <a class="reference internal" href="#SampleRepresentation.AtomLayerObject" title="SampleRepresentation.AtomLayerObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">AtomLayerObject</span></code></a> of equal thicknesses.</p>
<p>The idea is to collect all information regarding the density profile in an object of this class and to generate entries for the <em>densitydict</em> of the single <a class="reference internal" href="#SampleRepresentation.AtomLayerObject" title="SampleRepresentation.AtomLayerObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">AtomLayerObject</span></code></a> instances from it.
This means that the class <a class="reference internal" href="#SampleRepresentation.DensityProfile" title="SampleRepresentation.DensityProfile"><code class="xref py py-class docutils literal notranslate"><span class="pre">DensityProfile</span></code></a> does not really talk to the layers, but is only a higher level convinience class to set up the interconnected densities of the atoms within the layers as instances of <a class="reference internal" href="parameters.html#Parameters.DerivedParameter" title="Parameters.DerivedParameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters.DerivedParameter</span></code></a>.</p>
<dl class="method">
<dt id="SampleRepresentation.DensityProfile.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>start_layer_idx</em>, <em>end_layer_idx</em>, <em>layer_thickness</em>, <em>profile_function</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#DensityProfile.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.DensityProfile.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>start_layer_idx</strong> (<em>int</em>) – Index of the first layer in the scope of the density profile.</li>
<li><strong>end_layer_idx</strong> (<em>int</em>) – Index of the last layer in the scope of the density profile.</li>
<li><strong>layer_thickness</strong> (<a class="reference internal" href="parameters.html#Parameters.Parameter" title="Parameters.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters.Parameter</span></code></a>) – Thickness of the individual layers. The Unit is the same as for every other length used throughout the project and is not predefined. E.g. wavelength.</li>
<li><strong>profile_function</strong> (<a class="reference internal" href="parameters.html#Parameters.ParametrizedFunction" title="Parameters.ParametrizedFunction"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters.ParametrizedFunction</span></code></a>) – The density of the corresponding atom as function of the distance <strong>z</strong> from the lower surface of start layer parametrized by arbitrary parameters (see <a class="reference internal" href="parameters.html#Parameters.ParametrizedFunction" title="Parameters.ParametrizedFunction"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters.ParametrizedFunction</span></code></a> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="SampleRepresentation.DensityProfile.getDensityPar">
<code class="descname">getDensityPar</code><span class="sig-paren">(</span><em>layer_idx</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#DensityProfile.getDensityPar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.DensityProfile.getDensityPar" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the density parameter as instance of <a class="reference internal" href="parameters.html#Parameters.DerivedParameter" title="Parameters.DerivedParameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters.DerivedParameter</span></code></a> for the layer with index <strong>idx</strong> coresponding to the defined density profile.</p>
</dd></dl>

<dl class="method">
<dt id="SampleRepresentation.DensityProfile.getDensity">
<code class="descname">getDensity</code><span class="sig-paren">(</span><em>z</em>, <em>fitpararray</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#DensityProfile.getDensity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.DensityProfile.getDensity" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the density at a certain distance <strong>z</strong> from the lower surface of start layer corresponding to the fit parameter values given by <strong>fitpararray</strong>.</p>
<p>Might be used for plotting the resulting density profile etc.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="SampleRepresentation.DensityProfile_erf">
<em class="property">class </em><code class="descclassname">SampleRepresentation.</code><code class="descname">DensityProfile_erf</code><span class="sig-paren">(</span><em>start_layer_idx</em>, <em>end_layer_idx</em>, <em>layer_thickness</em>, <em>position</em>, <em>sigma</em>, <em>maximum</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#DensityProfile_erf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.DensityProfile_erf" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#SampleRepresentation.DensityProfile" title="SampleRepresentation.DensityProfile"><code class="xref py py-class docutils literal notranslate"><span class="pre">SampleRepresentation.DensityProfile</span></code></a></p>
<p>Specialized <a class="reference internal" href="#SampleRepresentation.DensityProfile" title="SampleRepresentation.DensityProfile"><code class="xref py py-class docutils literal notranslate"><span class="pre">DensityProfile</span></code></a> class.
Realizes a density profile with the function</p>
<p><code class="docutils literal notranslate"><span class="pre">f(z)</span> <span class="pre">=</span> <span class="pre">0.5*maximum*(1+erf(</span> <span class="pre">(z-position)</span> <span class="pre">/</span> <span class="pre">(sigma*sqrt(2))</span> <span class="pre">)</span> <span class="pre">)</span></code>.</p>
<dl class="method">
<dt id="SampleRepresentation.DensityProfile_erf.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>start_layer_idx</em>, <em>end_layer_idx</em>, <em>layer_thickness</em>, <em>position</em>, <em>sigma</em>, <em>maximum</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#DensityProfile_erf.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.DensityProfile_erf.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>start_layer_idx</strong> (<em>int</em>) – Index of the first layer of the density profile.</li>
<li><strong>end_layer_idx</strong> (<em>int</em>) – Index of the last layer of the density profile.</li>
<li><strong>layer_thickness</strong> (<a class="reference internal" href="parameters.html#Parameters.Parameter" title="Parameters.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters.Parameter</span></code></a>) – Thickness of the individual layers. The Unit is the same as for every other length used throughout the project and is not predefined. E.g. wavelength.</li>
<li><strong>position</strong> (<a class="reference internal" href="parameters.html#Parameters.Parameter" title="Parameters.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters.Parameter</span></code></a>) – Center position of the transition. Measured from the bottom of the start layer. The Unit is the same as for every other length used throughout the project and is not predefined. E.g. wavelength.</li>
<li><strong>sigma</strong> (<a class="reference internal" href="parameters.html#Parameters.Parameter" title="Parameters.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters.Parameter</span></code></a>) – Width of the transition. Unit: see above.</li>
<li><strong>maximum</strong> (<a class="reference internal" href="parameters.html#Parameters.Parameter" title="Parameters.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters.Parameter</span></code></a>) – Maximum value of the function. Should usually be measured in mol/cm^3. For other units you have to take care with the <strong>densityunitfactor</strong> at <a class="reference internal" href="#SampleRepresentation.AtomLayerObject" title="SampleRepresentation.AtomLayerObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">AtomLayerObject</span></code></a>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="SampleRepresentation.plotAtomDensity">
<code class="descclassname">SampleRepresentation.</code><code class="descname">plotAtomDensity</code><span class="sig-paren">(</span><em>hs</em>, <em>fitpararray</em>, <em>colormap=[]</em>, <em>atomnames=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#plotAtomDensity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.plotAtomDensity" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function. Create a bar plot of the atom densities of all instances of <a class="reference internal" href="#SampleRepresentation.AtomLayerObject" title="SampleRepresentation.AtomLayerObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">AtomLayerObject</span></code></a> contained in the <a class="reference internal" href="#SampleRepresentation.Heterostructure" title="SampleRepresentation.Heterostructure"><code class="xref py py-class docutils literal notranslate"><span class="pre">Heterostructure</span></code></a> object <strong>hs</strong> corresdonding to the <strong>fitpararray</strong> (see <a class="reference internal" href="parameters.html#module-Parameters" title="Parameters"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Parameters</span></code></a>) and return the plotted information as dictionary.</p>
<p>This plot is only usefull for stacks of layers with equal widths as the widths are not taken into account for the plots</p>
<p>You can  define the colors of the bars with <strong>colormap</strong>. Just give a list of matplotlib color names. They will be used in the given order.
You can define which atoms you want to plot or in which order. Give <strong>atomnames</strong> as a list of strings. If <strong>atomnames</strong> is not given, the bars will have different width, such that overlapped bars can be seen.</p>
</dd></dl>

<dl class="function">
<dt id="SampleRepresentation.KramersKronig">
<code class="descclassname">SampleRepresentation.</code><code class="descname">KramersKronig</code><span class="sig-paren">(</span><em>energy</em>, <em>f_imag</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/SampleRepresentation.html#KramersKronig"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SampleRepresentation.KramersKronig" title="Permalink to this definition">¶</a></dt>
<dd><p>Convinience funtion. Performs the Kramers Kronig transformation</p>
<div class="math">
<p><img src="../_images/math/df223c86fddb153cbc3a80115b6a377f7dac23a4.png" alt="f^\prime(E)= - \frac{2}{\pi}\mathrm{CH}\int_0^\infty \frac{\eta \cdot f^{\prime\prime}(\eta)}{\eta^2-E^2} \, d\eta"/></p>
</div><p>It is just a wrapper for <code class="xref py py-func docutils literal notranslate"><span class="pre">Pythonreflectivity.KramersKroning()</span></code> from Martins Zwieblers <code class="xref py py-mod docutils literal notranslate"><span class="pre">Pythonreflectivity</span></code> package.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>energy</strong> – an ordered list/array of L energies (in eV). The energies do not have to be envenly spaced, but they should be ordered.</li>
<li><strong>f_imag</strong> – a list/array of real numbers and length L with absorption data</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="experiment.html" title="Module Experiment"
             >next</a> |</li>
        <li class="right" >
          <a href="parameters.html" title="Module Parameters"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PyXMRTool 0.9 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../api.html" >API</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Yannic Utz.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.0.1.
    </div>
  </body>
</html>