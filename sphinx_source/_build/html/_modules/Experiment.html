
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Experiment &#8212; PyXMRTool 0.9 documentation</title>
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PyXMRTool 0.9 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h3><a href="../index.html">Table Of Contents</a></h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">PyXMRToolâ€™s documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intro.html">todo: Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">todo: Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api.html">API</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for Experiment</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="sd">&quot;&quot;&quot;Deals with the description of the experiment and brings experimental and simulated data together.</span>
<span class="sd">It contains currently only the class :class:`.ReflDataSimulator`, which does this job.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1">#Python Version 2.7</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Yannic Utz&quot;</span>
<span class="n">__copyright__</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
<span class="n">__credits__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Yannic Utz and Martin Zwiebler&quot;</span><span class="p">]</span>
<span class="n">__license__</span> <span class="o">=</span> <span class="s2">&quot;GNU General Public License v3.0&quot;</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;0.9&quot;</span>
<span class="n">__maintainer__</span> <span class="o">=</span> <span class="s2">&quot;Yannic Utz&quot;</span>
<span class="n">__email__</span> <span class="o">=</span> <span class="s2">&quot;yannic.utz@tu-dresden.de&quot;</span>
<span class="n">__status__</span> <span class="o">=</span> <span class="s2">&quot;beta&quot;</span>



<span class="kn">import</span> <span class="nn">numbers</span>
<span class="kn">import</span> <span class="nn">os.path</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">scipy.constants</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="k">import</span> <span class="n">axes3d</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">matplotlib.patches</span> <span class="k">as</span> <span class="nn">mpatches</span>

<span class="kn">import</span> <span class="nn">Pythonreflectivity</span>

<span class="kn">import</span> <span class="nn">SampleRepresentation</span>





<div class="viewcode-block" id="ReflDataSimulator"><a class="viewcode-back" href="../modules-api/experiment.html#Experiment.ReflDataSimulator">[docs]</a><span class="k">class</span> <span class="nc">ReflDataSimulator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Holds the experimental data, simulates it according to the settings and fitparameters and can directly deliver the sum of squared residuals (:meth:`.getSimData`) and the residuals themselfs (:meth:`.getResidualsSSR`), which both describe the difference between data and simulation at a certain parameter set. It can be in different modes which determins which data or which derived data is stored and simulated.&quot;&quot;&quot;</span>
    
<div class="viewcode-block" id="ReflDataSimulator.__init__"><a class="viewcode-back" href="../modules-api/experiment.html#Experiment.ReflDataSimulator.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">length_scale</span><span class="o">=</span><span class="mf">1e-9</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the ReflDataSimulator with a certain mode.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mode : string</span>
<span class="sd">            The following modes are implemented so far:</span>
<span class="sd">                </span>
<span class="sd">            * \&#39;l\&#39;             - for linear polarized light, only reflectivity for sigma and pi polarization will be stored and simulated</span>
<span class="sd">            * \&#39;c\&#39;             - for circular polarized light, only reflectivity for left circular and right circular polarization will be stored and simulated</span>
<span class="sd">            * \&#39;x\&#39;             - for xmcd, only the difference between the reflectivity for right circular and left circular polarization will be stored and simulated</span>
<span class="sd">            * \&#39;cx&lt;xfactor&gt;\&#39;   - for the reflections of circular pol. light and the xmcd signal (which should usually been calculated from the left and right circ. pol.) simultaniously \&#39;&lt;xfactor&gt;\&#39; is optional and can be used to multiply the xmcd signal with this value. This can be usefull to give the xmcd more or less weight during fitting e.g.\&#39;cx20\&#39; or \&#39;cx0.1\&#39;</span>
<span class="sd">            * \&#39;lL\&#39;, \&#39;cL\&#39;, \&#39;xL\&#39;, \&#39;cLx&lt;xfactor&gt;\&#39;, - as before, but instead of the corresponding reflectivities themselfs their logarithms are stored and simulated. </span>
<span class="sd">        length_scale : float</span>
<span class="sd">            Defines in which unit lengths are measured in your script. The unit is then **length_scale** * meters. Default is **length_scale** = *1e-9* which means *nm*. It is important to define it here due to conversion between energies and wavelength.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">mode</span><span class="se">\&#39;</span><span class="s2"> has to be a string.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">mode</span><span class="o">==</span><span class="s2">&quot;l&quot;</span> <span class="ow">or</span> <span class="n">mode</span><span class="o">==</span><span class="s2">&quot;c&quot;</span> <span class="ow">or</span> <span class="n">mode</span><span class="o">==</span><span class="s2">&quot;x&quot;</span> <span class="ow">or</span> <span class="n">mode</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;cx&quot;</span> <span class="ow">or</span> <span class="n">mode</span><span class="o">==</span><span class="s2">&quot;lL&quot;</span> <span class="ow">or</span> <span class="n">mode</span><span class="o">==</span><span class="s2">&quot;cL&quot;</span> <span class="ow">or</span> <span class="n">mode</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;cLx&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">mode</span><span class="se">\&#39;</span><span class="s2"> can only take the values </span><span class="se">\&#39;</span><span class="s2">l</span><span class="se">\&#39;</span><span class="s2">, </span><span class="se">\&#39;</span><span class="s2">lL</span><span class="se">\&#39;</span><span class="s2">, </span><span class="se">\&#39;</span><span class="s2">c</span><span class="se">\&#39;</span><span class="s2">, </span><span class="se">\&#39;</span><span class="s2">cL</span><span class="se">\&#39;</span><span class="s2">, </span><span class="se">\&#39;</span><span class="s2">x</span><span class="se">\&#39;</span><span class="s2">, </span><span class="se">\&#39;</span><span class="s2">cx&lt;xfactor&gt;</span><span class="se">\&#39;</span><span class="s2"> or </span><span class="se">\&#39;</span><span class="s2">cLx&lt;xfactor&gt;</span><span class="se">\&#39;</span><span class="s2">.&quot;</span><span class="p">)</span>      
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">length_scale</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Real</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">length_scale</span><span class="se">\&#39;</span><span class="s2"> has to be a real number.&quot;</span><span class="p">)</span>
        
        
        <span class="k">if</span> <span class="n">mode</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;cx&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">=</span><span class="n">mode</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>                                <span class="c1">#save only the leading letters of the mode string</span>
            <span class="k">if</span> <span class="n">mode</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span><span class="o">==</span><span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_xmcdfactor</span><span class="o">=</span><span class="mf">1.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_xmcdfactor</span><span class="o">=</span><span class="nb">eval</span><span class="p">(</span><span class="n">mode</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>               <span class="c1">#save the xmcdfactor as an extra private property for later use</span>
        <span class="k">elif</span> <span class="n">mode</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;cLx&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">=</span><span class="n">mode</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>                                <span class="c1">#save only the leading letters of the mode string</span>
            <span class="k">if</span> <span class="n">mode</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span><span class="o">==</span><span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_xmcdfactor</span><span class="o">=</span><span class="mf">1.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_xmcdfactor</span><span class="o">=</span><span class="nb">eval</span><span class="p">(</span><span class="n">mode</span><span class="p">[</span><span class="mi">3</span><span class="p">:])</span>               <span class="c1">#save the xmcdfactor as an extra private property for later use</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">=</span><span class="n">mode</span>                                   <span class="c1">#for the other modes the mode-string can stay as it is</span>
        
        <span class="c1">#set length scale. Has direct impact for the calculation of wavelengths from energies.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lengthscale</span><span class="o">=</span><span class="n">length_scale</span>                                                                  <span class="c1">#need this property only for the methode setMode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hcfactor</span><span class="o">=</span><span class="n">scipy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">physical_constants</span><span class="p">[</span><span class="s2">&quot;Planck constant in eV s&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">scipy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">physical_constants</span><span class="p">[</span><span class="s2">&quot;speed of light in vacuum&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">length_scale</span>   </div>
        
        
    <span class="c1">#private methods</span>
    
    <span class="k">def</span> <span class="nf">_getMode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s1">&#39;cx&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s1">&#39;cLx&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xmcdfactor</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span>
    
    
    <span class="k">def</span> <span class="nf">_getExpDataFlat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">flatexpdata</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;l&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;lL&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;c&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;cL&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expdata</span><span class="p">:</span>
                <span class="n">flatexpdata</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">flatexpdata</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;x&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expdata</span><span class="p">:</span>
                <span class="n">flatexpdata</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s1">&#39;cx&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s1">&#39;cLx&#39;</span> <span class="p">:</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expdata</span><span class="p">:</span>
                <span class="n">flatexpdata</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">flatexpdata</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
                <span class="n">flatexpdata</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>                
        <span class="k">return</span> <span class="n">flatexpdata</span>
    
    <span class="k">def</span> <span class="nf">_getSimDataFlat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">fitpararray</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return simulated data according to the bevor set-up model and the parameter values given with fitpararray as flat array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># leave out parameter test, and test for existance of heterostructure to speed things up (this function will be called often in fit routines)</span>
        <span class="n">flatsimdata</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expdata</span><span class="p">:</span>
            <span class="c1">#item[0] is the energy, item[1] is the list of angles at this energy</span>
            <span class="n">singeE_HS</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_hs</span><span class="o">.</span><span class="n">getSingleEnergyStructure</span><span class="p">(</span><span class="n">fitpararray</span><span class="p">,</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>      
            <span class="n">wavelength</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_hcfactor</span><span class="o">/</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">rcalc</span><span class="o">=</span><span class="n">Pythonreflectivity</span><span class="o">.</span><span class="n">Reflectivity</span><span class="p">(</span><span class="n">singeE_HS</span><span class="p">,</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">wavelength</span><span class="p">,</span> <span class="n">Output</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="n">MultipleScattering</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_multiplescattering</span><span class="p">,</span> <span class="n">MagneticCutoff</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_magneticcutoff</span><span class="p">)</span>
            
            <span class="c1">#if non-magnetic, Pythonreflectivity.Reflectivity delivers only pi and sigma polarization!</span>
            <span class="c1">#check for this case and get left and right circular as average of pi and sigma if necessary</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rcalc</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;c&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;cL&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;x&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;cx&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;cLx&quot;</span><span class="p">):</span>
                <span class="n">average</span><span class="o">=</span><span class="p">(</span><span class="n">rcalc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">rcalc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mf">2.0</span>
                <span class="n">circular</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">average</span><span class="p">)))</span>
                <span class="n">circular</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">average</span>         <span class="c1">#left circular polarization</span>
                <span class="n">circular</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">average</span>         <span class="c1">#right circular polarization</span>
                <span class="n">rcalc</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rcalc</span><span class="p">,</span><span class="n">circular</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>           
                <span class="c1">#dedug</span>
                <span class="nb">print</span> <span class="s2">&quot;magnetic zero&quot;</span>
            
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;l&quot;</span><span class="p">:</span>  <span class="c1">#linear polarization</span>
                <span class="n">flatsimdata</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_reflmodifierfunction</span><span class="p">(</span><span class="n">rcalc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">fitpararray</span><span class="p">))</span>
                <span class="n">flatsimdata</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_reflmodifierfunction</span><span class="p">(</span><span class="n">rcalc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">fitpararray</span><span class="p">))</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;lL&quot;</span><span class="p">:</span>  <span class="c1">#logarithm of linear polarization</span>
                <span class="n">flatsimdata</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_reflmodifierfunction</span><span class="p">(</span><span class="n">rcalc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">fitpararray</span><span class="p">)))</span>               <span class="c1">#calculate logarithms of reflectivities</span>
                <span class="n">flatsimdata</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_reflmodifierfunction</span><span class="p">(</span><span class="n">rcalc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">fitpararray</span><span class="p">)))</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;c&quot;</span><span class="p">:</span> <span class="c1">#circular polarization</span>
                <span class="n">flatsimdata</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_reflmodifierfunction</span><span class="p">(</span><span class="n">rcalc</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">fitpararray</span><span class="p">))</span>
                <span class="n">flatsimdata</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_reflmodifierfunction</span><span class="p">(</span><span class="n">rcalc</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">fitpararray</span><span class="p">))</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;cL&quot;</span><span class="p">:</span> <span class="c1">#logarithm of circular polarization</span>
                <span class="n">flatsimdata</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_reflmodifierfunction</span><span class="p">(</span><span class="n">rcalc</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">fitpararray</span><span class="p">)))</span>                 <span class="c1">#calculate logarithms of reflectivities</span>
                <span class="n">flatsimdata</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_reflmodifierfunction</span><span class="p">(</span><span class="n">rcalc</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">fitpararray</span><span class="p">)))</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="c1">#xmcd: normalized difference between circular polarizations. </span>
                <span class="n">rleft</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_reflmodifierfunction</span><span class="p">(</span><span class="n">rcalc</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">fitpararray</span><span class="p">)</span>
                <span class="n">rright</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_reflmodifierfunction</span><span class="p">(</span><span class="n">rcalc</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">fitpararray</span><span class="p">)</span>
                <span class="n">xmcd</span><span class="o">=</span><span class="p">(</span><span class="n">rleft</span><span class="o">-</span><span class="n">rright</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">rleft</span><span class="o">+</span><span class="n">rright</span><span class="p">)</span>                                                         <span class="c1">#calculate xmcd as (rleft-rright)/(rleft+rright). Does not follow any sign convention, if there is one.</span>
                <span class="n">flatsimdata</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">xmcd</span><span class="p">)</span>                           
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s1">&#39;cx&#39;</span><span class="p">:</span> <span class="c1">#circular polarizations and xmcd simultaniously and xmcd multiplied with a factor</span>
                <span class="n">rleft</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_reflmodifierfunction</span><span class="p">(</span><span class="n">rcalc</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">fitpararray</span><span class="p">)</span>
                <span class="n">rright</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_reflmodifierfunction</span><span class="p">(</span><span class="n">rcalc</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">fitpararray</span><span class="p">)</span>
                <span class="n">xmcd</span><span class="o">=</span><span class="p">(</span><span class="n">rleft</span><span class="o">-</span><span class="n">rright</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">rleft</span><span class="o">+</span><span class="n">rright</span><span class="p">)</span>                                                         <span class="c1">#calculate xmcd as (rleft-rright)/(rleft+rright). Does not follow any sign convention, if there is one.</span>
                <span class="n">flatsimdata</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">rleft</span><span class="p">)</span>
                <span class="n">flatsimdata</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">rright</span><span class="p">)</span>
                <span class="n">flatsimdata</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xmcdfactor</span><span class="o">*</span><span class="n">xmcd</span><span class="p">)</span>                                   <span class="c1">#here the simulated xmcd signal is multiplied with a user defined factor. This is usefull if you want to give more or less weight to the xmcd while fitting</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s1">&#39;cLx&#39;</span><span class="p">:</span> <span class="c1">#logarithm of polarizations and xmcd simultaniously and xmcd multiplied with a factor</span>
                <span class="n">rleft</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_reflmodifierfunction</span><span class="p">(</span><span class="n">rcalc</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">fitpararray</span><span class="p">)</span>
                <span class="n">rright</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_reflmodifierfunction</span><span class="p">(</span><span class="n">rcalc</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">fitpararray</span><span class="p">)</span>
                <span class="n">xmcd</span><span class="o">=</span><span class="p">(</span><span class="n">rleft</span><span class="o">-</span><span class="n">rright</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">rleft</span><span class="o">+</span><span class="n">rright</span><span class="p">)</span>                                                         <span class="c1">#calculate xmcd as (rleft-rright)/(rleft+rright). Does not follow any sign convention, if there is one.</span>
                <span class="n">flatsimdata</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">rleft</span><span class="p">))</span>
                <span class="n">flatsimdata</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">rright</span><span class="p">))</span>
                <span class="n">flatsimdata</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xmcdfactor</span><span class="o">*</span><span class="n">xmcd</span><span class="p">)</span>                                   <span class="c1">#here the simulated xmcd signal is multiplied with a user defined factor. This is usefull if you want to give more or less weight to the xmcd while fitting</span>
        <span class="k">return</span> <span class="n">flatsimdata</span>
            
    
    <span class="k">def</span> <span class="nf">_getHCFactor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hcfactor</span>
    
    
    <span class="c1">#public methods</span>
    
<div class="viewcode-block" id="ReflDataSimulator.ReadData"><a class="viewcode-back" href="../modules-api/experiment.html#Experiment.ReflDataSimulator.ReadData">[docs]</a>    <span class="k">def</span> <span class="nf">ReadData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">files</span><span class="p">,</span><span class="n">linereaderfunction</span><span class="p">,</span> <span class="n">energies</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">angles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filenamereaderfunction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pointmodifierfunction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">headerlines</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read the data files and store the data corresponding to the **mode** specified with instanciation (see :meth:`ReflDataSimulator.__init__`)</span>
<span class="sd">        </span>
<span class="sd">        This function enables a very flexible reading of the data files.</span>
<span class="sd">        Logically, this function uses data points which consist of the independent variables energy and angle, and the reflectivities as dependent variables (rsigmag,rpi,rleft,rright,xmcd).</span>
<span class="sd">        So one point is specified by (energy,angle,rsigmag,rpi,rleft,rright,xmcd)  with energies in eV and angles in degrees.</span>
<span class="sd">        Where the values for the independent variables comes from can differ: either from lists (**energies**,**angles**), from the filenames (**filenamereaderfunction**) or from the lines in the data file (**linereaderfunction**).</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ---------</span>
<span class="sd">        files : str or list of str</span>
<span class="sd">            Specifies the set of data files. Either a list of filenames or one foldername of a folder containing all the data files (and only them!).</span>
<span class="sd">        linereaderfunction : callable</span>
<span class="sd">            A function given by the user which takes one line of an input file as string and returns a list/tuple of real numbers *(energy,angle,rsigma,rpi,rleft,rright,xmcd)*. Entries can also be \&#39;None\&#39;. Exceptions will only be trown if the needed information for the specified **mode** is not delivered. An easy way to create such a function is to use the method :meth:`.createLinereader`.</span>
<span class="sd">        energies : list of floats</span>
<span class="sd">            Only possible to be different from *None* if **files** is a list of filenames and **angles** is `None`. Gives the energies which belong to the corresponding files (same order) as floats.</span>
<span class="sd">        angles : list of floats</span>
<span class="sd">            Only possible to be different from *None* if **files** is a list of filenames and **energies** is `None`. Gives the angles which belong to the corresponding files (same order) as floats.</span>
<span class="sd">        filenamereaderfunction : callable</span>
<span class="sd">            A user-defined function which reads energies and/or angles from the filenames of the data files. This function should take a string (a filename without path), extract energy and/or angle out of it and return this as a tuple/list *(energy,angle)*. Both entries can also be set to *None*, but their will be an exception if the needed information for the data points can also not be obtained from the **linereaderfunction**.</span>
<span class="sd">        pointmodifierfunction : callable</span>
<span class="sd">            A user-definde function which is used to modify the obtained information. It takes the tuple/list of independent and dependent variables of a single data point and returns a modified one. It can be used for example if the data file contains qz values instead of angles. In this case you can read the qz values first as angles and replace them afterwards with the angles calculated out of it with the **pointmodifierfunction**. Of course you can also use a adopted **linereaderfunction** for this purpose (if all necessary information can be found in one line of the data files).</span>
<span class="sd">        headerlines : int</span>
<span class="sd">            specifies the number of lines which should be ignored at the top of each file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1">#Parameter checking</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">files</span><span class="p">,(</span><span class="nb">tuple</span><span class="p">,</span><span class="nb">list</span><span class="p">,</span><span class="nb">str</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">files</span><span class="se">\&#39;</span><span class="s2"> has to be a list of filenames or a folder name.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">files</span><span class="p">,(</span><span class="nb">tuple</span><span class="p">,</span><span class="nb">list</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Entries of </span><span class="se">\&#39;</span><span class="s2">files</span><span class="se">\&#39;</span><span class="s2"> have to be strings.&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="o">+</span><span class="n">name</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2"> (entry of </span><span class="se">\&#39;</span><span class="s2">files</span><span class="se">\&#39;</span><span class="s2"> is not an existing file.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">files</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">files</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="o">+</span><span class="n">name</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2"> is not an existing directory.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">linereaderfunction</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">linereaderfunction</span><span class="se">\&#39;</span><span class="s2"> has to be callable.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">energies</span><span class="p">,(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">))</span> <span class="ow">or</span> <span class="n">energies</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;\energies</span><span class="se">\&#39;</span><span class="s2"> has to be a list of numbers.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">energies</span><span class="p">,(</span><span class="nb">tuple</span><span class="p">,</span><span class="nb">list</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">en</span> <span class="ow">in</span> <span class="n">energies</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">en</span><span class="p">,</span><span class="n">numbers</span><span class="o">.</span><span class="n">Real</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Entries of </span><span class="se">\&#39;</span><span class="s2">energies</span><span class="se">\&#39;</span><span class="s2"> have to be real numbers.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">angles</span><span class="p">,(</span><span class="nb">tuple</span><span class="p">,</span><span class="nb">list</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">an</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">an</span><span class="p">,</span><span class="n">numbers</span><span class="o">.</span><span class="n">Real</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Entries of </span><span class="se">\&#39;</span><span class="s2">angles</span><span class="se">\&#39;</span><span class="s2"> have to be real numbers.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">callable</span><span class="p">(</span><span class="n">filenamereaderfunction</span><span class="p">)</span> <span class="ow">or</span> <span class="n">filenamereaderfunction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">filenamereaderfunction</span><span class="se">\&#39;</span><span class="s2"> has to be callable.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pointmodifierfunction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">pointmodifierfunction</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">pointmodifierfunction</span><span class="se">\&#39;</span><span class="s2"> has to be callable.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">headerlines</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;\headerlines</span><span class="se">\&#39;</span><span class="s2"> has to be an integer number.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">headerlines</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;\headerlines</span><span class="se">\&#39;</span><span class="s2"> has to be a positive number.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">energies</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">angles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">filenamereaderfunction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">energies</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">angles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">energies</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">filenamereaderfunction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>  <span class="ow">or</span> <span class="p">(</span><span class="n">angles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">filenamereaderfunction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Either use </span><span class="se">\&#39;</span><span class="s2">energies</span><span class="se">\&#39;</span><span class="s2">, </span><span class="se">\&#39;</span><span class="s2">angles</span><span class="se">\&#39;</span><span class="s2"> or </span><span class="se">\&#39;</span><span class="s2">filenamereaderfunction</span><span class="se">\&#39;</span><span class="s2"> but not several of them.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">energies</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">angles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">files</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">energies</span><span class="se">\&#39;</span><span class="s2"> or </span><span class="se">\&#39;</span><span class="s2">angles</span><span class="se">\&#39;</span><span class="s2"> can only be used if </span><span class="se">\&#39;</span><span class="s2">files</span><span class="se">\&#39;</span><span class="s2"> is an array of filenames.&quot;</span><span class="p">)</span>
        
        <span class="c1">#store parameters for later use with setMode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_datafiles</span><span class="o">=</span><span class="n">files</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_datalinereaderfunction</span><span class="o">=</span><span class="n">linereaderfunction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dataenergies</span><span class="o">=</span><span class="n">energies</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dataangles</span><span class="o">=</span><span class="n">angles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_datafilenamereaderfunction</span><span class="o">=</span><span class="n">filenamereaderfunction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_datapointmodifierfunction</span><span class="o">=</span><span class="n">pointmodifierfunction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dataheaderlines</span><span class="o">=</span><span class="n">headerlines</span>
        
        
        <span class="c1">#get filenames of files in directory</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">files</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
            <span class="n">files</span><span class="o">=</span><span class="p">[</span><span class="n">files</span><span class="o">+</span><span class="s2">&quot;/&quot;</span><span class="o">+</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">files</span><span class="p">)]</span>
        
       
        <span class="c1">#go trough all files</span>
        <span class="n">datapoints</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">i</span><span class="o">=</span><span class="mi">0</span>
        <span class="n">file_energy</span><span class="o">=</span><span class="kc">None</span>
        <span class="n">file_angle</span><span class="o">=</span><span class="kc">None</span>
        <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">energies</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>                                                    <span class="c1">#if &quot;file-wide&quot; independent variables are defined set them here</span>
                <span class="n">file_energy</span><span class="o">=</span><span class="n">energies</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">angles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">file_angles</span><span class="o">=</span><span class="n">angles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">filenamereaderfunction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">file_energy</span><span class="p">,</span><span class="n">file_angle</span><span class="o">=</span><span class="n">filenamereaderfunction</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">fname</span><span class="p">))</span>      <span class="c1">#give only the filename without the path to the filenamereaderfunction</span>
            <span class="n">f</span><span class="o">=</span><span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
            <span class="n">lines</span><span class="o">=</span><span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()[</span><span class="n">headerlines</span><span class="p">:]</span>                                                <span class="c1">#read file, skip headerlines, store as array &quot;lines&quot;</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
                <span class="n">output</span><span class="o">=</span><span class="n">linereaderfunction</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">output</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">energy</span><span class="p">,</span><span class="n">angle</span><span class="p">,</span><span class="n">rsigma</span><span class="p">,</span><span class="n">rpi</span><span class="p">,</span><span class="n">rleft</span><span class="p">,</span><span class="n">rright</span><span class="p">,</span><span class="n">xmcd</span><span class="o">=</span><span class="n">output</span>
                    <span class="k">if</span> <span class="n">file_energy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>                                                  <span class="c1">#overwrite energy and/or angle if file-wide energy and/or angle is given</span>
                        <span class="n">energy</span><span class="o">=</span><span class="n">file_energy</span>
                    <span class="k">if</span> <span class="n">file_angle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">angle</span><span class="o">=</span><span class="n">file_angle</span>
                    <span class="k">if</span> <span class="n">energy</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">angle</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Needed data not in line&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">pointmodifierfunction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">energy</span><span class="p">,</span><span class="n">angle</span><span class="p">,</span><span class="n">rsigma</span><span class="p">,</span><span class="n">rpi</span><span class="p">,</span><span class="n">rleft</span><span class="p">,</span><span class="n">rright</span><span class="p">,</span><span class="n">xmcd</span><span class="o">=</span><span class="n">pointmodifierfunction</span><span class="p">([</span><span class="n">energy</span><span class="p">,</span><span class="n">angle</span><span class="p">,</span><span class="n">rsigma</span><span class="p">,</span><span class="n">rpi</span><span class="p">,</span><span class="n">rleft</span><span class="p">,</span><span class="n">rright</span><span class="p">,</span><span class="n">xmcd</span><span class="p">])</span>   <span class="c1">#apply pointmodifierfunction</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s1">&#39;l&#39;</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">rsigma</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">rpi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Needed data not in line&quot;</span><span class="p">)</span>
                        <span class="n">datapoints</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">energy</span><span class="p">,</span><span class="n">angle</span><span class="p">,</span><span class="n">rsigma</span><span class="p">,</span><span class="n">rpi</span><span class="p">])</span> 
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s1">&#39;lL&#39;</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">rsigma</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">rpi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Needed data not in line&quot;</span><span class="p">)</span>
                        <span class="n">datapoints</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">energy</span><span class="p">,</span><span class="n">angle</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">rsigma</span><span class="p">),</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">rpi</span><span class="p">)])</span>                        <span class="c1">#store logarithms of reflectivities</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s1">&#39;c&#39;</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">rleft</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">rright</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Needed data not in line&quot;</span><span class="p">)</span>
                        <span class="n">datapoints</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">energy</span><span class="p">,</span><span class="n">angle</span><span class="p">,</span><span class="n">rleft</span><span class="p">,</span><span class="n">rright</span><span class="p">])</span>                         
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s1">&#39;cL&#39;</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">rleft</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">rright</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Needed data not in line&quot;</span><span class="p">)</span>
                        <span class="n">datapoints</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">energy</span><span class="p">,</span><span class="n">angle</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">rleft</span><span class="p">),</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">rright</span><span class="p">)])</span>                       <span class="c1">#store logarithms of reflectivities</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s1">&#39;x&#39;</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">xmcd</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Needed data not in line&quot;</span><span class="p">)</span>
                        <span class="n">datapoints</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">energy</span><span class="p">,</span><span class="n">angle</span><span class="p">,</span><span class="n">xmcd</span><span class="p">])</span> 
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s1">&#39;cx&#39;</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">rleft</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">rright</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">xmcd</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Needed data not in line&quot;</span><span class="p">)</span>
                        <span class="n">datapoints</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">energy</span><span class="p">,</span><span class="n">angle</span><span class="p">,</span><span class="n">rleft</span><span class="p">,</span><span class="n">rright</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_xmcdfactor</span><span class="o">*</span><span class="n">xmcd</span><span class="p">])</span>                   <span class="c1">#here the measured xmcd signal is multiplied with a user defined factor. This is usefull if you want to give more or less weight to the xmcd while fitting</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s1">&#39;cLx&#39;</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">rleft</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">rright</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">xmcd</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Needed data not in line&quot;</span><span class="p">)</span>
                        <span class="n">datapoints</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">energy</span><span class="p">,</span><span class="n">angle</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">rleft</span><span class="p">),</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">rright</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">_xmcdfactor</span><span class="o">*</span><span class="n">xmcd</span><span class="p">])</span>  <span class="c1">#store logarithms of reflectivities</span>
            <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>
        
        <span class="c1"># up to now there is an intermediate data structure: a list of complete datapoints eg. [ [energy1,angle1,rsigma1,rpi1], ...., [energyN,angleN,rsigmaN,rpiN]]</span>
        <span class="c1"># So there are many datapoints with the same energies</span>
        
        <span class="c1">#create now the data structure self._expdata for internal storage. It should be fast for delivering data belonging to single energies.</span>
        <span class="c1">#Therefore it looks like this:  self._expdata=[[energy1,[angle1,....angleN], [rsigma1, .... rsigmaN], [rpi1,...rpiN]], ...[energyL,[angle1,....angleK], [rsigma1, .... rsigmaK], [rpi1,...rpiK]] </span>
        <span class="c1">#                          or:  self._expdata=[[energy1,[angle1,....angleN], [rleft1, .... rleftN], [rright1,...rrightN]], ...[energyL,[angle1,....angleK], [rleft1, .... rleftK], [rright1,...rrightK]] </span>
        <span class="c1">#                          or:  self._expdata=[[energy1,[angle1,....angleN], [xmcd1, .... xmcdN]], ...[energyL,[angle1,....angleK], [xmcd1, .... xmcdK]] </span>
        <span class="c1">#                          or:  self._expdata=[[energy1,[angle1,....angleN], [rleft1, .... rleftN], [rright1,...rrightN], [xmcd1, .... xmcdN]]], ...[energyL,[angle1,....angleK], [rleft1, .... rleftK], [rright1,...rrightK],[xmcd1, .... xmcdK]] </span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_expdata</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">while</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">datapoints</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">):</span>
            <span class="n">element</span><span class="o">=</span><span class="n">datapoints</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">energy</span><span class="o">=</span><span class="n">element</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">single_energy_datapoints</span><span class="o">=</span><span class="p">[</span><span class="n">element</span><span class="p">]</span>
            <span class="c1">#fill single_energy_datapoints array</span>
            <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">datapoints</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">single_energy_datapoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">datapoints</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
            <span class="n">single_energy_datapoints</span><span class="o">=</span><span class="p">[</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">single_energy_datapoints</span><span class="p">]</span>        <span class="c1">#remove energy</span>
            <span class="n">single_energy_datapoints</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>                         <span class="c1">#sort for increasing angles</span>
            <span class="n">single_energy_datapoints</span><span class="o">=</span><span class="p">((</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">single_energy_datapoints</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>                  <span class="c1">#make a numpy array out of it,transpose it, and transform it again to a list of lists</span>
            <span class="n">item</span><span class="o">=</span><span class="p">[</span><span class="n">energy</span><span class="p">]</span>                                                                    <span class="c1">#create one item for the list self._expdata</span>
            <span class="n">item</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">single_energy_datapoints</span><span class="p">)</span>                                            <span class="c1">#extend it, such that it looks like this [energyL,[angle1,....angleK], [rsigma1, .... rsigmaK], [rpi1,...rpiK]  or equivalent</span>
            <span class="k">for</span> <span class="n">ang</span> <span class="ow">in</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>                                                  <span class="c1">#check if every angle occurs only once for this energy</span>
                <span class="k">if</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">ang</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;There is more than one datapoint with energy=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;eV and angle=&quot;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ang</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;degrees.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_expdata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_expdata</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">item</span><span class="p">:</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>                         <span class="c1">#sort with ascending energy</span></div>
        
        
      
    
<div class="viewcode-block" id="ReflDataSimulator.setModel"><a class="viewcode-back" href="../modules-api/experiment.html#Experiment.ReflDataSimulator.setModel">[docs]</a>    <span class="k">def</span> <span class="nf">setModel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">heterostructure</span><span class="p">,</span> <span class="n">reflmodifierfunction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">MultipleScattering</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">MagneticCutoff</span><span class="o">=</span><span class="mf">1e-50</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set up the model for the simulation of the reflectivity data. </span>
<span class="sd">        </span>
<span class="sd">        The simulation of the reflectivities is in prinicple done by using the information about the sample stored in **heterostructure** (of type :class:`SampleRepresentation.Heterostructure`).</span>
<span class="sd">        The calculated reflectivities are then given to the **reflmodifierfunction** (takes one number or numpy array and the fitpararray; returns one number or a numpy array). This function has to be defined </span>
<span class="sd">        by the user and can be used for example to multiply the reflectivity by a global number and/or to add a common background. To make these numbers fittable, use the fitparameters registerd at an instance of :class:`Paramters.ParamterPool`.</span>
<span class="sd">        Example::</span>
<span class="sd">        </span>
<span class="sd">            pp=Paramters.ParameterPool(&quot;any_parameterfile&quot;)</span>
<span class="sd">            ...</span>
<span class="sd">            b=pp.NewParameter(&quot;background&quot;)</span>
<span class="sd">            m=pp.NewParameter(&quot;multiplier&quot;)</span>
<span class="sd">            reflmodifierfunction=lambda r, fitpararray: b.getValue(fitpararray) + r * m.getValue(fitpararray)</span>
<span class="sd">        </span>
<span class="sd">        and give this function to :meth:`.setModel`.</span>
<span class="sd">        </span>
<span class="sd">        BEWARE: The reflmodifierfunction is called very often during fitting procedures. Make it performant!</span>
<span class="sd">               </span>
<span class="sd">        With **MultipleScattering** you can switch on (*True*) and off (*False*) the simulation of multiple scattering. *False* is 20 percent faster. Default is *True*. Has no effect on calculations that require the full matrix.</span>
<span class="sd">        </span>
<span class="sd">        **MagneticCutoff**: If an off-diagonal element of chi (chi_g) fulfills abs(chi_g)&lt;MagneticCutoff, it is set to zero. It defaults to 10e-50.</span>
<span class="sd">        </span>
<span class="sd">        The last two parameters are directly passed to :func:`Pythonreflectivity.Reflectivity`. See also the Documentation of :mod:`Pythonreflectivity`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">heterostructure</span><span class="p">,</span><span class="n">SampleRepresentation</span><span class="o">.</span><span class="n">Heterostructure</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">heterostructure</span><span class="se">\&#39;</span><span class="s2"> must be of type </span><span class="se">\&#39;</span><span class="s2">SampleRepresentation.Heterostructure</span><span class="se">\&#39;</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">reflmodifierfunction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">reflmodifierfunction</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">reflmodifierfunction</span><span class="se">\&#39;</span><span class="s2"> has to be callable.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">MultipleScattering</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">MultipleScattering</span><span class="se">\&#39;</span><span class="s2"> has to be a boolean value.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">MagneticCutoff</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Real</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;MagneticCutoff has to be a real number.&quot;</span><span class="p">)</span>            
        <span class="bp">self</span><span class="o">.</span><span class="n">_hs</span><span class="o">=</span><span class="n">heterostructure</span>
        <span class="k">if</span> <span class="n">reflmodifierfunction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>                                            <span class="c1">#if no reflmodifierfunction is given, set hier the &quot;identity function&quot; to avoid testing for None in getSimData</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reflmodifierfunction</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">r</span><span class="p">,</span><span class="n">fitpararray</span><span class="p">:</span> <span class="n">r</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reflmodifierfunction</span><span class="o">=</span><span class="n">reflmodifierfunction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_multiplescattering</span><span class="o">=</span><span class="n">MultipleScattering</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_magneticcutoff</span><span class="o">=</span><span class="n">MagneticCutoff</span></div>
        
<div class="viewcode-block" id="ReflDataSimulator.getLenDataFlat"><a class="viewcode-back" href="../modules-api/experiment.html#Experiment.ReflDataSimulator.getLenDataFlat">[docs]</a>    <span class="k">def</span> <span class="nf">getLenDataFlat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return length of the flat data representation. </span>
<span class="sd">        </span>
<span class="sd">        It will be the number of measured data points times 2 for mode &quot;l&quot; and &quot;c&quot;, only the number of measured data points for mode &quot;x&quot; and the number of measured data points times 3 for mode &quot;cx&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getExpDataFlat</span><span class="p">())</span></div>
        
        
<div class="viewcode-block" id="ReflDataSimulator.getSimData"><a class="viewcode-back" href="../modules-api/experiment.html#Experiment.ReflDataSimulator.getSimData">[docs]</a>    <span class="k">def</span> <span class="nf">getSimData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">fitpararray</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return simulated data according to the bevor set-up model and the parameter values given with **fitpararray** (see also :mod:`Parameters`).</span>
<span class="sd">        </span>
<span class="sd">        The retured data is a list and has on of the following or similar shapes::</span>
<span class="sd">            </span>
<span class="sd">            [[energy1,[angle1,....angleN], [rsigma1, .... rsigmaN], [rpi1,...rpiN]], ...[energyL,[angle1,....angleK], [rsigma1, .... rsigmaK], [rpi1,...rpiK]] </span>
<span class="sd">            [[energy1,[angle1,....angleN], [rleft1, .... rleftN], [rright1,...rrightN]], ...[energyL,[angle1,....angleK], [rleft1, .... rleftK], [rright1,...rrightK]] </span>
<span class="sd">            [[energy1,[angle1,....angleN], [xmcd1, .... xmcdN]], ...[energyL,[angle1,....angleK], [xmcd1, .... xmcdK]] </span>
<span class="sd">            [[energy1,[angle1,....angleN], [rleft1, .... rleftN], [rright1,...rrightN], [xmcd1, .... xmcdN]]], ...[energyL,[angle1,....angleK], [rleft1, .... rleftK], [rright1,...rrightK],[xmcd1, .... xmcdK]] </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># leave out parameter test, and test for existance of heterostructure to speed things up (this function will be called often in fit routines)</span>
        <span class="n">simdata</span><span class="o">=</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_expdata</span><span class="p">)</span>                                    <span class="c1">#copy experimental data to get energies and angles</span>
        <span class="n">simdata_flat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_getSimDataFlat</span><span class="p">(</span><span class="n">fitpararray</span><span class="p">)</span>
        <span class="c1">#replace the copied experimental data with simulated values</span>
        <span class="n">startindex</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;l&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;lL&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;c&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;cL&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">simdata</span><span class="p">:</span>
                <span class="n">datalen</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">simdata_flat</span><span class="p">[</span><span class="n">startindex</span><span class="p">:</span><span class="n">startindex</span><span class="o">+</span><span class="n">datalen</span><span class="p">]</span>                                     <span class="c1">#rsigma or rleft</span>
                <span class="n">item</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">=</span><span class="n">simdata_flat</span><span class="p">[</span><span class="n">startindex</span><span class="o">+</span><span class="n">datalen</span><span class="p">:</span><span class="n">startindex</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">datalen</span><span class="p">]</span>                           <span class="c1">#rpi or rright</span>
                <span class="n">startindex</span><span class="o">=</span><span class="n">startindex</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">datalen</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;x&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">simdata</span><span class="p">:</span>
                <span class="n">datalen</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">simdata_flat</span><span class="p">[</span><span class="n">startindex</span><span class="p">:</span><span class="n">startindex</span><span class="o">+</span><span class="n">datalen</span><span class="p">]</span>                                     <span class="c1">#xmcd</span>
                <span class="n">startindex</span><span class="o">=</span><span class="n">startindex</span><span class="o">+</span><span class="n">datalen</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;cx&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;cLx&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">simdata</span><span class="p">:</span>
                <span class="n">datalen</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">simdata_flat</span><span class="p">[</span><span class="n">startindex</span><span class="p">:</span><span class="n">startindex</span><span class="o">+</span><span class="n">datalen</span><span class="p">]</span>                                     <span class="c1">#rleft</span>
                <span class="n">item</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">=</span><span class="n">simdata_flat</span><span class="p">[</span><span class="n">startindex</span><span class="o">+</span><span class="n">datalen</span><span class="p">:</span><span class="n">startindex</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">datalen</span><span class="p">]</span>                           <span class="c1">#rright</span>
                <span class="n">item</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">=</span><span class="n">simdata_flat</span><span class="p">[</span><span class="n">startindex</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">datalen</span><span class="p">:</span><span class="n">startindex</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">datalen</span><span class="p">]</span>                         <span class="c1">#xmcd</span>
                <span class="n">startindex</span><span class="o">=</span><span class="n">startindex</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">datalen</span>
        <span class="k">return</span> <span class="n">simdata</span></div>
    
<div class="viewcode-block" id="ReflDataSimulator.getExpData"><a class="viewcode-back" href="../modules-api/experiment.html#Experiment.ReflDataSimulator.getExpData">[docs]</a>    <span class="k">def</span> <span class="nf">getExpData</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return stored experimental data.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        The retured data is a list and has on of the following or similar shapes::</span>
<span class="sd">            </span>
<span class="sd">            [[energy1,[angle1,....angleN], [rsigma1, .... rsigmaN], [rpi1,...rpiN]], ...[energyL,[angle1,....angleK], [rsigma1, .... rsigmaK], [rpi1,...rpiK]] </span>
<span class="sd">            [[energy1,[angle1,....angleN], [rleft1, .... rleftN], [rright1,...rrightN]], ...[energyL,[angle1,....angleK], [rleft1, .... rleftK], [rright1,...rrightK]] </span>
<span class="sd">            [[energy1,[angle1,....angleN], [xmcd1, .... xmcdN]], ...[energyL,[angle1,....angleK], [xmcd1, .... xmcdK]] </span>
<span class="sd">            [[energy1,[angle1,....angleN], [rleft1, .... rleftN], [rright1,...rrightN], [xmcd1, .... xmcdN]]], ...[energyL,[angle1,....angleK], [rleft1, .... rleftK], [rright1,...rrightK],[xmcd1, .... xmcdK]] </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expdata</span></div>
    
<div class="viewcode-block" id="ReflDataSimulator.getSSR"><a class="viewcode-back" href="../modules-api/experiment.html#Experiment.ReflDataSimulator.getSSR">[docs]</a>    <span class="k">def</span> <span class="nf">getSSR</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">fitpararray</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return sum of squared residuals as float according to the parameterset given by **fitpararray** (see also :mod:`Parameters`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getSimDataFlat</span><span class="p">(</span><span class="n">fitpararray</span><span class="p">))</span> <span class="o">-</span>  <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getExpDataFlat</span><span class="p">())</span> <span class="p">)</span>  <span class="p">)</span></div>
    
<div class="viewcode-block" id="ReflDataSimulator.getResidualsSSR"><a class="viewcode-back" href="../modules-api/experiment.html#Experiment.ReflDataSimulator.getResidualsSSR">[docs]</a>    <span class="k">def</span> <span class="nf">getResidualsSSR</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">fitpararray</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the residuals and the sum of squared residuals according to the parameterset given by **fitpararray** (see also :mod:`Parameters`).</span>
<span class="sd">        </span>
<span class="sd">        The information is returned as tuple: array of differences between simulated and measured data, sum of squared residuals.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">residuals</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getSimDataFlat</span><span class="p">(</span><span class="n">fitpararray</span><span class="p">))</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getExpDataFlat</span><span class="p">())</span>
        <span class="n">ssr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span> <span class="n">residuals</span>  <span class="p">))</span>
        <span class="k">return</span> <span class="n">residuals</span><span class="p">,</span><span class="n">ssr</span></div>
    
<div class="viewcode-block" id="ReflDataSimulator.plotData"><a class="viewcode-back" href="../modules-api/experiment.html#Experiment.ReflDataSimulator.plotData">[docs]</a>    <span class="k">def</span> <span class="nf">plotData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fitpararray</span><span class="p">,</span><span class="n">simcolor</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span><span class="n">expcolor</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="n">simlabel</span><span class="o">=</span><span class="s1">&#39;simulated&#39;</span><span class="p">,</span><span class="n">explabel</span><span class="o">=</span><span class="s1">&#39;experimental&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot simulated and experimental data.</span>
<span class="sd">        </span>
<span class="sd">        This function generates a plot at the first call and refreshes it if called again.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ---------</span>
<span class="sd">            simcolor : str</span>
<span class="sd">                Specifies the color of the simulated data for the plotting with pyplot (see https://matplotlib.org/users/colors.html). Default is red.</span>
<span class="sd">            expcolor : str  are supposed to be strings which specify a color for the plotting with pyplot (see https://matplotlib.org/users/colors.html).</span>
<span class="sd">                Specifies the color of the experimental data for the plotting with pyplot (see https://matplotlib.org/users/colors.html). Default is blue.</span>
<span class="sd">            simlabel : str </span>
<span class="sd">                Label shown in the legend of the plot for the simulated data. Default is *&quot;simulated&quot;*.</span>
<span class="sd">            explabel : str </span>
<span class="sd">                Label shown in the legend of the plot for the experimental data. Default is *&quot;experimental&quot;*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1">#check parameters</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">simcolor</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">simcolor</span><span class="se">\&#39;</span><span class="s2"> must be of string type.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expcolor</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">expcolor</span><span class="se">\&#39;</span><span class="s2"> must be of string type.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">simlabel</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">simlabel</span><span class="se">\&#39;</span><span class="s2"> must be of string type.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">explabel</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">explabel</span><span class="se">\&#39;</span><span class="s2"> must be of string type.&quot;</span><span class="p">)</span>
        
        
        
        <span class="c1">#get data</span>
        <span class="n">simdata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getSimData</span><span class="p">(</span><span class="n">fitpararray</span><span class="p">)</span>
        <span class="n">expdata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getExpData</span><span class="p">()</span>
        
        
       
           
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;_fig&#39;</span><span class="p">):</span>            <span class="c1">#close previous figure</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fig</span><span class="p">)</span>
        
        <span class="c1">#create figure and subplots</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">==</span> <span class="s2">&quot;l&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">==</span> <span class="s2">&quot;lL&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">==</span> <span class="s2">&quot;c&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">==</span> <span class="s2">&quot;cL&quot;</span><span class="p">:</span>      <span class="c1">#linear and circula polarization (or logarithm of it)       </span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">121</span><span class="p">,</span><span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>                  
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">122</span><span class="p">,</span><span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>                  
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">==</span> <span class="s2">&quot;x&quot;</span><span class="p">:</span>          <span class="c1">#xmcd</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span><span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>              <span class="c1">#for xmcd</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">==</span> <span class="s2">&quot;cx&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">==</span> <span class="s2">&quot;cLx&quot;</span> <span class="p">:</span>    <span class="c1">#circular polarization and xmcd</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">131</span><span class="p">,</span><span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>              <span class="c1">#for left circular pol </span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">132</span><span class="p">,</span><span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>              <span class="c1">#for right circular pol</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">133</span><span class="p">,</span><span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>              <span class="c1">#for xmcd</span>
        
                
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">==</span> <span class="s2">&quot;l&quot;</span><span class="p">:</span>            <span class="c1">#linear polarization</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;angle&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;sigma refl.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;theta&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;pi refl.&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">expdata</span><span class="p">:</span>                                                            <span class="c1">#go trough energies of experimental data</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">expcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and intensities on the z axis</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">expcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and intensities on the z axis</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">simdata</span><span class="p">:</span>                                                            <span class="c1">#go trough energies of simulated data</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">simcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and intensities on the z axis</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">simcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and intensities on the z axis</span>
        
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">==</span> <span class="s2">&quot;lL&quot;</span><span class="p">:</span>            <span class="c1">#log of linear polarization</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;angle&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;log( sigma refl. )&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;theta&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;log( pi refl. )&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">expdata</span><span class="p">:</span>                                                            <span class="c1">#go trough energies of experimental data</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">expcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and log of intensities on the z axis</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">expcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and log of intensities on the z axis</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">simdata</span><span class="p">:</span>                                                            <span class="c1">#go trough energies of simulated data</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">simcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and log of intensities on the z axis</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">simcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and log of intensities on the z axis</span>
        
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">==</span> <span class="s2">&quot;c&quot;</span><span class="p">:</span>            <span class="c1">#circular polarization</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;angle&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;left circ. refl.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;theta&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;right circ. refl.&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">expdata</span><span class="p">:</span>                                                            <span class="c1">#go trough energies of experimental data</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">expcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and intensities on the z axis</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">expcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and intensities on the z axis</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">simdata</span><span class="p">:</span>                                                            <span class="c1">#go trough energies of simulated data</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">simcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and intensities on the z axis</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">simcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and intensities on the z axis</span>
        
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">==</span> <span class="s2">&quot;cL&quot;</span><span class="p">:</span>            <span class="c1">#log of circular polarization</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;angle&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;log( left circ. refl. )&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;theta&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;log( right circ. refl. )&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">expdata</span><span class="p">:</span>                                                            <span class="c1">#go trough energies of experimental data</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">expcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and log of intensities on the z axis</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">expcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and log of intensities on the z axis</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">simdata</span><span class="p">:</span>                                                            <span class="c1">#go trough energies of simulated data</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">simcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and log of intensities on the z axis</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">simcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and log of intensities on the z axis</span>
                
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">==</span> <span class="s2">&quot;x&quot;</span><span class="p">:</span>            <span class="c1">#xmcd</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;angle&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;xmcd&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">expdata</span><span class="p">:</span>                                                            <span class="c1">#go trough energies of experimental data</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">expcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and xmcd on the z axis</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">simdata</span><span class="p">:</span>                                                            <span class="c1">#go trough energies of simulated data</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">simcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and xmcd on the z axis</span>
                        
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">==</span> <span class="s2">&quot;cx&quot;</span><span class="p">:</span>          <span class="c1">#circular polarization and xmcd</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax3</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;angle&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;left circ. refl.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;theta&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;right circ. refl.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax3</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;angle&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax3</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xmcdfactor</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax3</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;xmcd&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax3</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;xmcd * &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xmcdfactor</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">expdata</span><span class="p">:</span>                                                            <span class="c1">#go trough energies of experimental data</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">expcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and intensities on the z axis</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">expcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and intensities on the z axis</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax3</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">4</span><span class="p">]),</span><span class="n">color</span><span class="o">=</span><span class="n">expcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and xmcd on the z axis</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">simdata</span><span class="p">:</span>                                                            <span class="c1">#go trough energies of simulated data</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">simcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and intensities on the z axis</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">simcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and intensities on the z axis</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax3</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">4</span><span class="p">]),</span><span class="n">color</span><span class="o">=</span><span class="n">simcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and xmcd on the z axis</span>
        
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">==</span> <span class="s2">&quot;cLx&quot;</span><span class="p">:</span>          <span class="c1">#log of circular polarization and xmcd</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax3</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;angle&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;log( left circ. refl. )&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;theta&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;log( right circ. refl. )&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax3</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;angle&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax3</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xmcdfactor</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax3</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;xmcd&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax3</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;xmcd * &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xmcdfactor</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">expdata</span><span class="p">:</span>                                                            <span class="c1">#go trough energies of experimental data</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">expcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and intensities on the z axis</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">expcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and intensities on the z axis</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax3</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">4</span><span class="p">]),</span><span class="n">color</span><span class="o">=</span><span class="n">expcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and xmcd on the z axis</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">simdata</span><span class="p">:</span>                                                            <span class="c1">#go trough energies of simulated data</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">simcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and intensities on the z axis</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">simcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and intensities on the z axis</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax3</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">4</span><span class="p">]),</span><span class="n">color</span><span class="o">=</span><span class="n">simcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and xmcd on the z axis</span>
        
        <span class="c1">#create legend</span>
        <span class="n">exp_patch</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">Patch</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="n">expcolor</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="n">explabel</span><span class="p">)</span>
        <span class="n">sim_patch</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">Patch</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="n">simcolor</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="n">simlabel</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">handles</span><span class="o">=</span><span class="p">[</span><span class="n">exp_patch</span><span class="p">,</span><span class="n">sim_patch</span><span class="p">])</span>
        
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">pause</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="ReflDataSimulator.setMode"><a class="viewcode-back" href="../modules-api/experiment.html#Experiment.ReflDataSimulator.setMode">[docs]</a>    <span class="k">def</span> <span class="nf">setMode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">mode</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Change the mode after instantiation.</span>
<span class="sd">           </span>
<span class="sd">        Be carefull with this function. Errors can occur if the mode does not fit to the available information in the data files.</span>
<span class="sd">           </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mode : string</span>
<span class="sd">            The following modes are implemented so far:</span>
<span class="sd">                </span>
<span class="sd">            * \&#39;l\&#39;             - for linear polarized light, only reflectivity for sigma and pi polarization will be stored and simulated</span>
<span class="sd">            * \&#39;c\&#39;             - for circular polarized light, only reflectivity for left circular and right circular polarization will be stored and simulated</span>
<span class="sd">            * \&#39;x\&#39;             - for xmcd, only the difference between the reflectivity for right circular and left circular polarization will be stored and simulated</span>
<span class="sd">            * \&#39;cx&lt;xfactor&gt;\&#39;   - for the reflections of circular pol. light and the xmcd signal (which should usually been calculated from the left and right circ. pol.) simultaniously \&#39;&lt;xfactor&gt;\&#39; is optional and can be used to multiply the xmcd signal with this value. This can be usefull to give the xmcd more or less weight during fitting e.g.\&#39;cx20\&#39; or \&#39;cx0.1\&#39;</span>
<span class="sd">            * \&#39;lL\&#39;, \&#39;cL\&#39;, \&#39;xL\&#39;, \&#39;cLx&lt;xfactor&gt;\&#39;, - as before, but instead of the corresponding reflectivities themselfs their logarithms are stored and simulated. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1">#use the __init__ method to change mode to be sure to treat mode in the same way, even if changes occur in the futu</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_lengthscale</span><span class="p">)</span>
        <span class="c1">#read data again if already read</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s2">&quot;_expdata&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ReadData</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_datafiles</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_datalinereaderfunction</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataenergies</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataangles</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_datafilenamereaderfunction</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_datapointmodifierfunction</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataheaderlines</span><span class="p">)</span></div>

        
               
        
<div class="viewcode-block" id="ReflDataSimulator.createLinereader"><a class="viewcode-back" href="../modules-api/experiment.html#Experiment.ReflDataSimulator.createLinereader">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">createLinereader</span><span class="p">(</span><span class="n">energy_column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">angle_column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">rsigma_column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">rpi_column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">rleft_column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">rright_column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">xmcd_column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">commentsymbol</span><span class="o">=</span><span class="s1">&#39;#&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a linereader function which can read lines from whitespace-seperated files and returns lists of real numbers *[energy,angle,rsigma,rpi,rleft,rright,xmcd]* (or *None* for a uncommented line).</span>
<span class="sd">        </span>
<span class="sd">        With the parameters *..._column* you can determin wich column is interpreted how.</span>
<span class="sd">        Column numbers are starting from 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#check parameters</span>
        <span class="n">parameterlist</span><span class="o">=</span><span class="p">[</span><span class="n">energy_column</span><span class="p">,</span><span class="n">angle_column</span><span class="p">,</span><span class="n">rsigma_column</span><span class="p">,</span><span class="n">rpi_column</span><span class="p">,</span><span class="n">rleft_column</span><span class="p">,</span><span class="n">rright_column</span><span class="p">,</span><span class="n">xmcd_column</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">parameterlist</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">item</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Columns have to be given as integer numbers.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">item</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">item</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Columns have to be positive numbers.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">commentsymbol</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">commentsymbol</span><span class="se">\&#39;</span><span class="s2"> has to be a string.&quot;</span><span class="p">)</span>
        <span class="c1">#define the linereader function</span>
        <span class="k">def</span> <span class="nf">linereader</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">line</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">line</span><span class="se">\&#39;</span><span class="s2"> needs to be a string.&quot;</span><span class="p">)</span>
                <span class="n">line</span><span class="o">=</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">commentsymbol</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>                            <span class="c1">#ignore everything behind the commentsymbol  #</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="o">.</span><span class="n">isspace</span><span class="p">():</span>                               <span class="c1">#ignore empty lines        </span>
                    <span class="n">linearray</span><span class="o">=</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                    <span class="n">linelist</span><span class="o">=</span><span class="p">[]</span>
                    <span class="n">i</span><span class="o">=</span><span class="mi">0</span>
                    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">parameterlist</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">item</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">linelist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">linelist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">linearray</span><span class="p">[</span><span class="n">item</span><span class="p">]))</span>
                    <span class="k">return</span> <span class="n">linelist</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">linereader</span></div>
    
    
    <span class="c1">#public properties</span>
    <span class="n">mode</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getMode</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;The current mode. See :meth:`.__init__`for possible modes. Read-only.&quot;&quot;&quot;</span>
    <span class="n">hcfactor</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getHCFactor</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;Planck constant times the speed of light in units of *eV* times the unit of length which was defined by **length_scale** with :meth:`.__init__`. Read-only.&quot;&quot;&quot;</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PyXMRTool 0.9 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Yannic Utz.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.5.
    </div>
  </body>
</html>