
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Experiment &#8212; PyXMRTool 0.9 documentation</title>
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PyXMRTool 0.9 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h3><a href="../index.html">Table of Contents</a></h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">PyXMRToolâ€™s documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hints.html">Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../definitions.html">Terms and Definitions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../development.html">Developement</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for Experiment</h1><div class="highlight"><pre>
<span class="c1">#&lt;PyXMRTool: A Python Package for the analysis of X-Ray Magnetic Reflectivity data measured on heterostructures&gt;</span>
<span class="c1">#    Copyright (C) &lt;2018&gt;  &lt;Yannic Utz&gt;</span>
<span class="c1">#</span>
<span class="c1">#    This program is free software: you can redistribute it and/or modify</span>
<span class="c1">#    it under the terms of the GNU Lesser General Public License as published by</span>
<span class="c1">#    the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1">#    (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1">#    This program is distributed in the hope that it will be useful,</span>
<span class="c1">#    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1">#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1">#    GNU Lesser General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1">#    You should have received a copy of the GNU Lesser General Public License</span>
<span class="c1">#    along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.</span>

<span class="sd">&quot;&quot;&quot;Deals with the description of the experiment and brings experimental and simulated data together.</span>
<span class="sd">It contains currently only the class :class:`.ReflDataSimulator`, which does this job.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1">#Python Version 3.6</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Yannic Utz&quot;</span>
<span class="n">__copyright__</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
<span class="n">__credits__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Yannic Utz and Martin Zwiebler&quot;</span><span class="p">]</span>
<span class="n">__license__</span> <span class="o">=</span> <span class="s2">&quot;GNU General Public License v3.0&quot;</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;0.9&quot;</span>
<span class="n">__maintainer__</span> <span class="o">=</span> <span class="s2">&quot;Yannic Utz&quot;</span>
<span class="n">__email__</span> <span class="o">=</span> <span class="s2">&quot;yannic.utz@tu-dresden.de&quot;</span>
<span class="n">__status__</span> <span class="o">=</span> <span class="s2">&quot;beta&quot;</span>



<span class="kn">import</span> <span class="nn">numbers</span>
<span class="kn">import</span> <span class="nn">os.path</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">scipy.constants</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="k">import</span> <span class="n">axes3d</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">matplotlib.patches</span> <span class="k">as</span> <span class="nn">mpatches</span>


<span class="kn">import</span> <span class="nn">Pythonreflectivity</span>

<span class="kn">from</span> <span class="nn">PyXMRTool</span> <span class="k">import</span> <span class="n">SampleRepresentation</span>
<span class="kn">from</span> <span class="nn">PyXMRTool</span> <span class="k">import</span> <span class="n">Parameters</span>






<div class="viewcode-block" id="ReflDataSimulator"><a class="viewcode-back" href="../modules-api/experiment.html#Experiment.ReflDataSimulator">[docs]</a><span class="k">class</span> <span class="nc">ReflDataSimulator</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Holds the experimental data, simulates it according to the settings and fitparameters and can directly deliver the sum of squared residuals (:meth:`.getSSR`) and the residuals themselfs (:meth:`.getResidualsSSR`), which both describe the difference between data and simulation at a certain parameter set. It can be in different modes which determins which data or which derived data is stored and simulated.&quot;&quot;&quot;</span>
    
<div class="viewcode-block" id="ReflDataSimulator.__init__"><a class="viewcode-back" href="../modules-api/experiment.html#Experiment.ReflDataSimulator.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">length_scale</span><span class="o">=</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">9</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the ReflDataSimulator with a certain mode.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mode : string</span>
<span class="sd">            The following modes are implemented so far:</span>
<span class="sd">                </span>
<span class="sd">            * \&#39;l\&#39;             - for linear polarized light, only reflectivity for sigma and pi polarization will be stored and simulated</span>
<span class="sd">            * \&#39;c\&#39;             - for circular polarized light, only reflectivity for left circular and right circular polarization will be stored and simulated</span>
<span class="sd">            * \&#39;t\&#39;             - only the total reflectivity (sum of reflectivities of different polarizations l/r or sigma/pi) will be stored and simulated (contains only structural information)</span>
<span class="sd">            * \&#39;x\&#39;             - for xmcd, only the difference between the reflectivity for right circular and left circular polarization will be stored and simulated (contains only magnetic information). Actually, it is the normalized XMCD or asymmetry *(rleft-rright)/(rleft+rright)*.</span>
<span class="sd">            * \&#39;cx&lt;xfactor&gt;\&#39;   - for the reflections of circular pol. light and the xmcd signal (which should usually been calculated from the left and right circ. pol.) simultaniously \&#39;&lt;xfactor&gt;\&#39; is optional and can be used to multiply the xmcd signal with this value. This can be usefull to give the xmcd more or less weight during fitting e.g.\&#39;cx20\&#39; or \&#39;cx0.1\&#39;</span>
<span class="sd">            * \&#39;lL\&#39;, \&#39;cL\&#39;, \&#39;tL\&#39;, \&#39;xL\&#39;, \&#39;cLx&lt;xfactor&gt;\&#39;, - as before, but instead of the corresponding reflectivities (or derived values) themselfs their logarithms are stored and simulated. This is usefull for fitting as with the logarithm the errors of different data points are weighted in a comparable way, in spite of the strongly decaying intensitiy for higher angles (see J.Pyhs.: Condens. Matter 26 (2014) 363201, page 16).</span>
<span class="sd">        length_scale : float</span>
<span class="sd">            Defines in which unit lengths are measured in your script. The unit is then **length_scale** * meters. Default is **length_scale** = *1e-9* which means *nm*. It is important to define it here due to conversion between energies and wavelength.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">mode</span><span class="se">\&#39;</span><span class="s2"> has to be a string.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">mode</span><span class="o">==</span><span class="s2">&quot;l&quot;</span> <span class="ow">or</span> <span class="n">mode</span><span class="o">==</span><span class="s2">&quot;c&quot;</span> <span class="ow">or</span> <span class="n">mode</span><span class="o">==</span><span class="s2">&quot;t&quot;</span> <span class="ow">or</span> <span class="n">mode</span><span class="o">==</span><span class="s2">&quot;tL&quot;</span> <span class="ow">or</span> <span class="n">mode</span><span class="o">==</span><span class="s2">&quot;x&quot;</span> <span class="ow">or</span> <span class="n">mode</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;cx&quot;</span> <span class="ow">or</span> <span class="n">mode</span><span class="o">==</span><span class="s2">&quot;lL&quot;</span> <span class="ow">or</span> <span class="n">mode</span><span class="o">==</span><span class="s2">&quot;cL&quot;</span> <span class="ow">or</span> <span class="n">mode</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;cLx&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">mode</span><span class="se">\&#39;</span><span class="s2"> can only take the values </span><span class="se">\&#39;</span><span class="s2">l</span><span class="se">\&#39;</span><span class="s2">, </span><span class="se">\&#39;</span><span class="s2">lL</span><span class="se">\&#39;</span><span class="s2">, </span><span class="se">\&#39;</span><span class="s2">c</span><span class="se">\&#39;</span><span class="s2">, </span><span class="se">\&#39;</span><span class="s2">cL</span><span class="se">\&#39;</span><span class="s2">, </span><span class="se">\&#39;</span><span class="s2">t</span><span class="se">\&#39;</span><span class="s2">, </span><span class="se">\&#39;</span><span class="s2">tL</span><span class="se">\&#39;</span><span class="s2">, </span><span class="se">\&#39;</span><span class="s2">x</span><span class="se">\&#39;</span><span class="s2">, </span><span class="se">\&#39;</span><span class="s2">cx&lt;xfactor&gt;</span><span class="se">\&#39;</span><span class="s2"> or </span><span class="se">\&#39;</span><span class="s2">cLx&lt;xfactor&gt;</span><span class="se">\&#39;</span><span class="s2">.&quot;</span><span class="p">)</span>      
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">length_scale</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Real</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">length_scale</span><span class="se">\&#39;</span><span class="s2"> has to be a real number.&quot;</span><span class="p">)</span>
        
        
        <span class="k">if</span> <span class="n">mode</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;cx&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">=</span><span class="n">mode</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>                                <span class="c1">#save only the leading letters of the mode string</span>
            <span class="k">if</span> <span class="n">mode</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span><span class="o">==</span><span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_xmcdfactor</span><span class="o">=</span><span class="mf">1.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_xmcdfactor</span><span class="o">=</span><span class="nb">eval</span><span class="p">(</span><span class="n">mode</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>               <span class="c1">#save the xmcdfactor as an extra private property for later use</span>
        <span class="k">elif</span> <span class="n">mode</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;cLx&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">=</span><span class="n">mode</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>                                <span class="c1">#save only the leading letters of the mode string</span>
            <span class="k">if</span> <span class="n">mode</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span><span class="o">==</span><span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_xmcdfactor</span><span class="o">=</span><span class="mf">1.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_xmcdfactor</span><span class="o">=</span><span class="nb">eval</span><span class="p">(</span><span class="n">mode</span><span class="p">[</span><span class="mi">3</span><span class="p">:])</span>               <span class="c1">#save the xmcdfactor as an extra private property for later use</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">=</span><span class="n">mode</span>                                   <span class="c1">#for the other modes the mode-string can stay as it is</span>
        
        <span class="c1">#set length scale. Has direct impact for the calculation of wavelengths from energies.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lengthscale</span><span class="o">=</span><span class="n">length_scale</span>                                                                  <span class="c1">#need this property only for the methode setMode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hcfactor</span><span class="o">=</span><span class="n">scipy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">physical_constants</span><span class="p">[</span><span class="s2">&quot;Planck constant in eV s&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">scipy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">physical_constants</span><span class="p">[</span><span class="s2">&quot;speed of light in vacuum&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">length_scale</span>
        
        <span class="c1">#initiate datasource storage, an array which stores datasources to be able to reread them when executin setMode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_datasourcestorage</span><span class="o">=</span><span class="p">[]</span>
        
        <span class="c1">#initiate destilled storage of experimental data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_expdata</span><span class="o">=</span><span class="p">[]</span></div>
        
        
        
        
    <span class="c1">#private methods</span>
    
    <span class="k">def</span> <span class="nf">_getMode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s1">&#39;cx&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s1">&#39;cLx&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xmcdfactor</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span>
    
    
    <span class="k">def</span> <span class="nf">_getExpDataFlat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">flatexpdata</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;l&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;lL&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;c&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;cL&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expdata</span><span class="p">:</span>
                <span class="n">flatexpdata</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">flatexpdata</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;x&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;t&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;tL&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expdata</span><span class="p">:</span>
                <span class="n">flatexpdata</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s1">&#39;cx&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s1">&#39;cLx&#39;</span> <span class="p">:</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expdata</span><span class="p">:</span>
                <span class="n">flatexpdata</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">flatexpdata</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
                <span class="n">flatexpdata</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>                
        <span class="k">return</span> <span class="n">flatexpdata</span>
    
    <span class="k">def</span> <span class="nf">_getSimDataFlat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">fitpararray</span><span class="p">,</span> <span class="n">energy_angles</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return simulated data according to the bevor set-up model, the energies/angles of the stored experimental data (substracted by *exp_energyshift* and *exp_angleshift, see :meth:`.setModel`) and and the parameter values given with fitpararray as flat array.</span>
<span class="sd">        </span>
<span class="sd">        If energy_angles is given, the energies and angles specified there are used instead (and also substracted by *exp_energyshift* and *exp_angleshift, see :meth:`.setModel`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># leave out parameter test, and test for existance of heterostructure to speed things up (this function will be called often in fit routines)</span>
        <span class="n">flatsimdata</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">exp_energyshift</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_exp_energyshift</span><span class="o">.</span><span class="n">getValue</span><span class="p">(</span><span class="n">fitpararray</span><span class="p">)</span>             <span class="c1">#shift (fitparameter) used to shift the experimentally measured energies (see :meth:`.setModel`)</span>
        <span class="n">exp_angleshift</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_exp_angleshift</span><span class="o">.</span><span class="n">getValue</span><span class="p">(</span><span class="n">fitpararray</span><span class="p">)</span>                <span class="c1">#shift (fitparameter) used to shift the experimentally measured angles (see :meth:`.setModel`)</span>
        <span class="k">if</span> <span class="n">energy_angles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">energy_angles</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_expdata</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">energy_angles</span><span class="p">:</span>
            <span class="c1">#item[0] is the energy, item[1] is the list of angles at this energy</span>
            <span class="c1">#shift energies and angles</span>
            <span class="n">energy</span><span class="o">=</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">exp_energyshift</span>
            <span class="n">angles</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">-</span><span class="n">exp_angleshift</span>
            <span class="c1">#get reflectivities with the help of Martins Pythonreflectivity package</span>
            <span class="n">singleE_HS</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_hs</span><span class="o">.</span><span class="n">getSingleEnergyStructure</span><span class="p">(</span><span class="n">fitpararray</span><span class="p">,</span><span class="n">energy</span><span class="p">)</span>      
            <span class="n">wavelength</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_hcfactor</span><span class="o">/</span><span class="n">energy</span>
            <span class="n">rcalc</span><span class="o">=</span><span class="n">Pythonreflectivity</span><span class="o">.</span><span class="n">Reflectivity</span><span class="p">(</span><span class="n">singleE_HS</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span><span class="n">wavelength</span><span class="p">,</span> <span class="n">Output</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="n">MultipleScattering</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_multiplescattering</span><span class="p">,</span> <span class="n">MagneticCutoff</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_magneticcutoff</span><span class="p">)</span>
            
            <span class="c1">#if non-magnetic, Pythonreflectivity.Reflectivity delivers only pi and sigma polarization!</span>
            <span class="c1">#check for this case and get left and right circular as average of pi and sigma if necessary</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rcalc</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;c&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;cL&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;t&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;tL&quot;</span><span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;x&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;cx&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;cLx&quot;</span><span class="p">):</span>
                <span class="n">average</span><span class="o">=</span><span class="p">(</span><span class="n">rcalc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">rcalc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mf">2.0</span>
                <span class="n">circular</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">average</span><span class="p">)))</span>
                <span class="n">circular</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">average</span>         <span class="c1">#left circular polarization</span>
                <span class="n">circular</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">average</span>         <span class="c1">#right circular polarization</span>
                <span class="n">rcalc</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rcalc</span><span class="p">,</span><span class="n">circular</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>           
            
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;l&quot;</span><span class="p">:</span>  <span class="c1">#linear polarization</span>
                <span class="n">flatsimdata</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_reflmodifierfunction</span><span class="p">(</span><span class="n">rcalc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">fitpararray</span><span class="p">))</span>
                <span class="n">flatsimdata</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_reflmodifierfunction</span><span class="p">(</span><span class="n">rcalc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">fitpararray</span><span class="p">))</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;lL&quot;</span><span class="p">:</span>  <span class="c1">#logarithm of linear polarization</span>
                <span class="n">flatsimdata</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_reflmodifierfunction</span><span class="p">(</span><span class="n">rcalc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">fitpararray</span><span class="p">)))</span>               <span class="c1">#calculate logarithms of reflectivities</span>
                <span class="n">flatsimdata</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_reflmodifierfunction</span><span class="p">(</span><span class="n">rcalc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">fitpararray</span><span class="p">)))</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;c&quot;</span><span class="p">:</span> <span class="c1">#circular polarization</span>
                <span class="n">flatsimdata</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_reflmodifierfunction</span><span class="p">(</span><span class="n">rcalc</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">fitpararray</span><span class="p">))</span>
                <span class="n">flatsimdata</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_reflmodifierfunction</span><span class="p">(</span><span class="n">rcalc</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">fitpararray</span><span class="p">))</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;cL&quot;</span><span class="p">:</span> <span class="c1">#logarithm of circular polarization</span>
                <span class="n">flatsimdata</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_reflmodifierfunction</span><span class="p">(</span><span class="n">rcalc</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">fitpararray</span><span class="p">)))</span>                 <span class="c1">#calculate logarithms of reflectivities</span>
                <span class="n">flatsimdata</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_reflmodifierfunction</span><span class="p">(</span><span class="n">rcalc</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">fitpararray</span><span class="p">)))</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;t&quot;</span><span class="p">:</span> <span class="c1"># total reflectivity/sum of circular polarizations</span>
                <span class="n">flatsimdata</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_reflmodifierfunction</span><span class="p">(</span><span class="n">rcalc</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">fitpararray</span><span class="p">)</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_reflmodifierfunction</span><span class="p">(</span><span class="n">rcalc</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">fitpararray</span><span class="p">))</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;tL&quot;</span><span class="p">:</span> <span class="c1">#logarithm of total reflectivity/sum of circular polarizations</span>
                <span class="n">flatsimdata</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_reflmodifierfunction</span><span class="p">(</span><span class="n">rcalc</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">fitpararray</span><span class="p">)</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_reflmodifierfunction</span><span class="p">(</span><span class="n">rcalc</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">fitpararray</span><span class="p">)))</span>                 <span class="c1">#calculate logarithms of sum of reflectivities</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="c1">#xmcd: normalized difference between circular polarizations. </span>
                <span class="n">rleft</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_reflmodifierfunction</span><span class="p">(</span><span class="n">rcalc</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">fitpararray</span><span class="p">)</span>
                <span class="n">rright</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_reflmodifierfunction</span><span class="p">(</span><span class="n">rcalc</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">fitpararray</span><span class="p">)</span>
                <span class="n">xmcd</span><span class="o">=</span><span class="p">(</span><span class="n">rleft</span><span class="o">-</span><span class="n">rright</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">rleft</span><span class="o">+</span><span class="n">rright</span><span class="p">)</span>                                                         <span class="c1">#calculate xmcd as (rleft-rright)/(rleft+rright). Does not follow any sign convention, if there is one.</span>
                <span class="n">flatsimdata</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">xmcd</span><span class="p">)</span>                           
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s1">&#39;cx&#39;</span><span class="p">:</span> <span class="c1">#circular polarizations and xmcd simultaniously and xmcd multiplied with a factor</span>
                <span class="n">rleft</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_reflmodifierfunction</span><span class="p">(</span><span class="n">rcalc</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">fitpararray</span><span class="p">)</span>
                <span class="n">rright</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_reflmodifierfunction</span><span class="p">(</span><span class="n">rcalc</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">fitpararray</span><span class="p">)</span>
                <span class="n">xmcd</span><span class="o">=</span><span class="p">(</span><span class="n">rleft</span><span class="o">-</span><span class="n">rright</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">rleft</span><span class="o">+</span><span class="n">rright</span><span class="p">)</span>                                                         <span class="c1">#calculate xmcd as (rleft-rright)/(rleft+rright). Does not follow any sign convention, if there is one.</span>
                <span class="n">flatsimdata</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">rleft</span><span class="p">)</span>
                <span class="n">flatsimdata</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">rright</span><span class="p">)</span>
                <span class="n">flatsimdata</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xmcdfactor</span><span class="o">*</span><span class="n">xmcd</span><span class="p">)</span>                                   <span class="c1">#here the simulated xmcd signal is multiplied with a user defined factor. This is usefull if you want to give more or less weight to the xmcd while fitting</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s1">&#39;cLx&#39;</span><span class="p">:</span> <span class="c1">#logarithm of polarizations and xmcd simultaniously and xmcd multiplied with a factor</span>
                <span class="n">rleft</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_reflmodifierfunction</span><span class="p">(</span><span class="n">rcalc</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">fitpararray</span><span class="p">)</span>
                <span class="n">rright</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_reflmodifierfunction</span><span class="p">(</span><span class="n">rcalc</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">fitpararray</span><span class="p">)</span>
                <span class="n">xmcd</span><span class="o">=</span><span class="p">(</span><span class="n">rleft</span><span class="o">-</span><span class="n">rright</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">rleft</span><span class="o">+</span><span class="n">rright</span><span class="p">)</span>                                                         <span class="c1">#calculate xmcd as (rleft-rright)/(rleft+rright). Does not follow any sign convention, if there is one.</span>
                <span class="n">flatsimdata</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">rleft</span><span class="p">))</span>
                <span class="n">flatsimdata</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">rright</span><span class="p">))</span>
                <span class="n">flatsimdata</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xmcdfactor</span><span class="o">*</span><span class="n">xmcd</span><span class="p">)</span>                                   <span class="c1">#here the simulated xmcd signal is multiplied with a user defined factor. This is usefull if you want to give more or less weight to the xmcd while fitting</span>
        <span class="k">return</span> <span class="n">flatsimdata</span>
    
    <span class="k">def</span> <span class="nf">_destillDatapoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">datapoint</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Takes a complete datapoint (which contains all possible entries) and destill a datapoint as it is needed for the current mode (see :meth:`.__init__`).</span>
<span class="sd">        </span>
<span class="sd">        This private method is used by :meth:`.ReadData` to convert the data returned by the *linereaderfunction* and the *pointmodifierfunction* and it is used by :meth:`.setData` to destill the given datapoints before they are given to :meth.`_setData`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">energy</span><span class="p">,</span><span class="n">angle</span><span class="p">,</span><span class="n">rsigma</span><span class="p">,</span><span class="n">rpi</span><span class="p">,</span><span class="n">rleft</span><span class="p">,</span><span class="n">rright</span><span class="p">,</span><span class="n">xmcd</span><span class="p">,</span><span class="n">total</span><span class="o">=</span><span class="n">datapoint</span>    <span class="c1">#unpack datapoint</span>
        
        <span class="c1">#set every value to NaN which is zero or None</span>
        <span class="k">if</span> <span class="n">rsigma</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">rsigma</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="n">rsigma</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">if</span> <span class="n">rpi</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">rpi</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="n">rpi</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">if</span> <span class="n">rleft</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">rleft</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="n">rleft</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">if</span> <span class="n">rright</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">rright</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="n">rright</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">if</span> <span class="n">xmcd</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">xmcd</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="n">xmcd</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">if</span> <span class="n">total</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">total</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="n">total</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s1">&#39;l&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">energy</span><span class="p">,</span><span class="n">angle</span><span class="p">,</span><span class="n">rsigma</span><span class="p">,</span><span class="n">rpi</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s1">&#39;lL&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">energy</span><span class="p">,</span><span class="n">angle</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">rsigma</span><span class="p">),</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">rpi</span><span class="p">)]</span>                        <span class="c1">#store logarithms of reflectivities</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s1">&#39;c&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">energy</span><span class="p">,</span><span class="n">angle</span><span class="p">,</span><span class="n">rleft</span><span class="p">,</span><span class="n">rright</span><span class="p">]</span>                       
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s1">&#39;cL&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">energy</span><span class="p">,</span><span class="n">angle</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">rleft</span><span class="p">),</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">rright</span><span class="p">)]</span>            <span class="c1">#store logarithms of reflectivities</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s1">&#39;t&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">energy</span><span class="p">,</span><span class="n">angle</span><span class="p">,</span><span class="n">total</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s1">&#39;tL&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">energy</span><span class="p">,</span><span class="n">angle</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">total</span><span class="p">)]</span>                  <span class="c1">#store logarithms of sum of reflectivities</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s1">&#39;x&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">energy</span><span class="p">,</span><span class="n">angle</span><span class="p">,</span><span class="n">xmcd</span><span class="p">]</span> 
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s1">&#39;cx&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">energy</span><span class="p">,</span><span class="n">angle</span><span class="p">,</span><span class="n">rleft</span><span class="p">,</span><span class="n">rright</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_xmcdfactor</span><span class="o">*</span><span class="n">xmcd</span><span class="p">]</span>                   <span class="c1">#here the measured xmcd signal is multiplied with a user defined factor. This is usefull if you want to give more or less weight to the xmcd while fitting</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s1">&#39;cLx&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">energy</span><span class="p">,</span><span class="n">angle</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">rleft</span><span class="p">),</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">rright</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">_xmcdfactor</span><span class="o">*</span><span class="n">xmcd</span><span class="p">]</span>  <span class="c1">#store logarithms of reflectivities</span>
    
    
    
    
    <span class="k">def</span> <span class="nf">_ReadDataCore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">files</span><span class="p">,</span><span class="n">linereaderfunction</span><span class="p">,</span> <span class="n">energies</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">angles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filenamereaderfunction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pointmodifierfunction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">headerlines</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read the data files and store the data corresponding to the **mode** specified with instanciation (see :meth:`ReflDataSimulator.__init__`)</span>
<span class="sd">        </span>
<span class="sd">        This is a core function not to be called by the user directly, but by :meth:`ReadData` and :meth:`setMode` to fullfill their tasks.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ---------</span>
<span class="sd">        files : str or list of str</span>
<span class="sd">            Specifies the set of data files. Either a list of filenames or one foldername of a folder containing all the data files (and only them!).</span>
<span class="sd">        linereaderfunction : callable</span>
<span class="sd">            A function given by the user which takes one line of an input file as string and returns a list/tuple of real numbers *(energy,angle,rsigma,rpi,rleft,rright,xmcd,total)*. Entries can also be \&#39;None\&#39;. Exceptions will only be trown if the needed information for the specified **mode** is not delivered. An easy way to create such a function is to use the method :meth:`.createLinereader`.</span>
<span class="sd">            The linereaderfunction can also return a list of lists if several datapoints are present in on line of the datafile.</span>
<span class="sd">        energies : list of floats</span>
<span class="sd">            Only possible to be different from *None* if **files** is a list of filenames and **angles** is `None`. Gives the energies which belong to the corresponding files (same order) as floats.</span>
<span class="sd">        angles : list of floats</span>
<span class="sd">            Only possible to be different from *None* if **files** is a list of filenames and **energies** is `None`. Gives the angles which belong to the corresponding files (same order) as floats.</span>
<span class="sd">        filenamereaderfunction : callable</span>
<span class="sd">            A user-defined function which reads energies and/or angles from the filenames of the data files. This function should take a string (a filename without path), extract energy and/or angle out of it and return this as a tuple/list *(energy,angle)*. Both entries can also be set to *None*, but their will be an exception if the needed information for the data points can also not be obtained from the **linereaderfunction**.</span>
<span class="sd">        pointmodifierfunction : callable</span>
<span class="sd">            A user-definde function which is used to modify the obtained information. It takes the tuple/list of independent and dependent variables of a single data point and returns a modified one. It can be used for example if the data file contains qz values instead of angles. In this case you can read the qz values first as angles and replace them afterwards with the angles calculated out of it with the **pointmodifierfunction**. Of course you can also use a adopted **linereaderfunction** for this purpose (if all necessary information can be found in one line of the data files).</span>
<span class="sd">        headerlines : int</span>
<span class="sd">            specifies the number of lines which should be ignored at the top of each file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#get filenames of files in directory</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">files</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
            <span class="n">files</span><span class="o">=</span><span class="p">[</span><span class="n">files</span><span class="o">+</span><span class="s2">&quot;/&quot;</span><span class="o">+</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">files</span><span class="p">)]</span>
        
       
        <span class="c1">#go trough all files</span>
        <span class="n">datapoints</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">i</span><span class="o">=</span><span class="mi">0</span>
        <span class="n">file_energy</span><span class="o">=</span><span class="kc">None</span>
        <span class="n">file_angle</span><span class="o">=</span><span class="kc">None</span>
        <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">energies</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>                                                    <span class="c1">#if &quot;file-wide&quot; independent variables are defined set them here</span>
                <span class="n">file_energy</span><span class="o">=</span><span class="n">energies</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">angles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">file_angles</span><span class="o">=</span><span class="n">angles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">filenamereaderfunction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">file_energy</span><span class="p">,</span><span class="n">file_angle</span><span class="o">=</span><span class="n">filenamereaderfunction</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">fname</span><span class="p">))</span>      <span class="c1">#give only the filename without the path to the filenamereaderfunction</span>
            <span class="n">f</span><span class="o">=</span><span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
            <span class="n">lines</span><span class="o">=</span><span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()[</span><span class="n">headerlines</span><span class="p">:]</span>                                                <span class="c1">#read file, skip headerlines, store as array &quot;lines&quot;</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
                <span class="n">output</span><span class="o">=</span><span class="n">linereaderfunction</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">output</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">tuple</span><span class="p">):</span>           <span class="c1">#look if output consists of several datapoints</span>
                        <span class="k">for</span> <span class="n">datapoint</span> <span class="ow">in</span> <span class="n">output</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">file_energy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>                                                  <span class="c1">#overwrite energy and/or angle if file-wide energy and/or angle is given</span>
                                <span class="n">datapoint</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">file_energy</span>                <span class="c1">#set &quot;energy&quot; of the datapoint to &quot;file_energy&quot;</span>
                            <span class="k">if</span> <span class="n">file_angle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                                <span class="n">datapoint</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">file_angle</span>                 <span class="c1">#set &quot;angle&quot; of the datapoint to &quot;file_angle&quot;</span>
                            <span class="k">if</span> <span class="n">datapoint</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">datapoint</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Needed data (energy or angle) not in line&quot;</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">pointmodifierfunction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                                <span class="n">datapoint</span><span class="o">=</span><span class="n">pointmodifierfunction</span><span class="p">(</span><span class="n">datapoint</span><span class="p">)</span>   <span class="c1">#apply pointmodifierfunction; datapoint should be an array like this [energy,angle,rsigma,rpi,rleft,rright,xmcd,total]</span>
                            <span class="n">dest_datapoint</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_destillDatapoint</span><span class="p">(</span><span class="n">datapoint</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">dest_datapoint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                                <span class="n">datapoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dest_datapoint</span><span class="p">)</span>             
                    <span class="k">else</span><span class="p">:</span>                                                                     <span class="c1">#if one line consists of one datapoint only</span>
                        <span class="n">datapoint</span><span class="o">=</span><span class="n">output</span>
                        <span class="k">if</span> <span class="n">file_energy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>                                                  <span class="c1">#overwrite energy and/or angle if file-wide energy and/or angle is given</span>
                            <span class="n">datapoint</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">file_energy</span>                <span class="c1">#set &quot;energy&quot; of the datapoint to &quot;file_energy&quot;</span>
                        <span class="k">if</span> <span class="n">file_angle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">datapoint</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">file_angle</span>                 <span class="c1">#set &quot;angle&quot; of the datapoint to &quot;file_angle&quot;</span>
                        <span class="k">if</span> <span class="n">datapoint</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">datapoint</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Needed data (energy or angle) not in line&quot;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">pointmodifierfunction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">datapoint</span><span class="o">=</span><span class="n">pointmodifierfunction</span><span class="p">(</span><span class="n">datapoint</span><span class="p">)</span>   <span class="c1">#apply pointmodifierfunction; datapoint should be an array like this [energy,angle,rsigma,rpi,rleft,rright,xmcd,total]</span>
                        <span class="n">dest_datapoint</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_destillDatapoint</span><span class="p">(</span><span class="n">datapoint</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">dest_datapoint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">datapoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dest_datapoint</span><span class="p">)</span>                    
            <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>
        
        <span class="c1"># up to now there is an intermediate data structure: a list of complete datapoints eg. [ [energy1,angle1,rsigma1,rpi1], ...., [energyN,angleN,rsigmaN,rpiN]]</span>
        <span class="c1"># So there are many datapoints with the same energies</span>
        
        <span class="c1">#create now the data structure self._expdata for internal storage. It should be fast for delivering data belonging to single energies.</span>
        <span class="c1">#Therefore it looks like this:  self._expdata=[[energy1,[angle1,....angleN], [rsigma1, .... rsigmaN], [rpi1,...rpiN]], ...[energyL,[angle1,....angleK], [rsigma1, .... rsigmaK], [rpi1,...rpiK]] </span>
        <span class="c1">#                          or:  self._expdata=[[energy1,[angle1,....angleN], [rleft1, .... rleftN], [rright1,...rrightN]], ...[energyL,[angle1,....angleK], [rleft1, .... rleftK], [rright1,...rrightK]] </span>
        <span class="c1">#                          or:  self._expdata=[[energy1,[angle1,....angleN], [xmcd1, .... xmcdN]], ...[energyL,[angle1,....angleK], [xmcd1, .... xmcdK]] </span>
        <span class="c1">#                          or:  self._expdata=[[energy1,[angle1,....angleN], [rleft1, .... rleftN], [rright1,...rrightN], [xmcd1, .... xmcdN]]], ...[energyL,[angle1,....angleK], [rleft1, .... rleftK], [rright1,...rrightK],[xmcd1, .... xmcdK]] </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setData</span><span class="p">(</span><span class="n">datapoints</span><span class="p">)</span>  
    
    <span class="k">def</span> <span class="nf">_setDataCore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">datapoints</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Core function which is used by :meth:`setData` and :meth:`setMode` to do their job.</span>
<span class="sd">        Store the data given with **datapoints** corresponding to the **mode** specified with instanciation (see :meth:`ReflDataSimulator.__init__`) instead of reading the data from data files (see :meth:`.ReadData`).</span>
<span class="sd">        </span>
<span class="sd">        **datapoints** has to be a list/array of datapoints of the following form:</span>
<span class="sd">           [[energy1,angle1,rsigma1,rpi1,rleft1,rright1,xmcd1,total1], ..., [energyK,angleK,rsigmaK,rpiK,rleftK,rrightK,xmcdK,totalK]</span>
<span class="sd">           </span>
<span class="sd">        Each datapoint corresponds to a measurement of the reflectivity at a certain angle and energy. Entries are alowed to hold *None* if the corresponding entry is not needed for current **mode**.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1">#destill datapoints (extract only needed entries)</span>
        <span class="n">dest_datapoints</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">datapoints</span><span class="p">:</span>
            <span class="n">dest_point</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_destillDatapoint</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dest_point</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">dest_datapoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dest_point</span><span class="p">)</span>   
        <span class="c1">#create internal structure for storage</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setData</span><span class="p">(</span><span class="n">dest_datapoints</span><span class="p">)</span>
    
    
    <span class="k">def</span> <span class="nf">_setData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">datapoints</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates the internal structure self._expdata (appends new datapoints), without consistency check.</span>
<span class="sd">        </span>
<span class="sd">        The data is taken from the list of datapoints, which has e.g. the following shape:</span>
<span class="sd">        [ [energy1,angle1,rsigma1,rpi1], ...., [energyN,angleN,rsigmaN,rpiN]]</span>
<span class="sd">        So there are many datapoints with the same energies.</span>
<span class="sd">        </span>
<span class="sd">       </span>
<span class="sd">        The data structure self._expdata is created for internal storage. It should be fast for delivering data belonging to single energies.</span>
<span class="sd">        Therefore it looks like this:  self._expdata=[[energy1,[angle1,....angleN], [rsigma1, .... rsigmaN], [rpi1,...rpiN]], ...[energyL,[angle1,....angleK], [rsigma1, .... rsigmaK], [rpi1,...rpiK]] </span>
<span class="sd">                                  or:  self._expdata=[[energy1,[angle1,....angleN], [rleft1, .... rleftN], [rright1,...rrightN]], ...[energyL,[angle1,....angleK], [rleft1, .... rleftK], [rright1,...rrightK]] </span>
<span class="sd">                                  or:  self._expdata=[[energy1,[angle1,....angleN], [xmcd1, .... xmcdN]], ...[energyL,[angle1,....angleK], [xmcd1, .... xmcdK]] </span>
<span class="sd">                                  or:  self._expdata=[[energy1,[angle1,....angleN], [rleft1, .... rleftN], [rright1,...rrightN], [xmcd1, .... xmcdN]]], ...[energyL,[angle1,....angleK], [rleft1, .... rleftK], [rright1,...rrightK],[xmcd1, .... xmcdK]] </span>
<span class="sd">                                  or:  self._expdata=[[energy1,[angle1,....angleN], [xmcd1, .... xmcdN]], ...[energyL,[angle1,....angleK], [total1, .... totalK]] </span>
<span class="sd">        </span>
<span class="sd">        Values for rsigma, rpi etc. can be NaN. Angles occur several times for one energy.</span>
<span class="sd">        </span>
<span class="sd">        This private method is used by :meth:`.ReadData` to convert the temporary list of datapoints and by :meth:`.SetData` which just adds an consistency check for the list of datapoints delivered by the user.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        

        <span class="k">while</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">datapoints</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">):</span>
            <span class="n">element</span><span class="o">=</span><span class="n">datapoints</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">energy</span><span class="o">=</span><span class="n">element</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">single_energy_datapoints</span><span class="o">=</span><span class="p">[</span><span class="n">element</span><span class="p">]</span>
            <span class="c1">#fill single_energy_datapoints array</span>
            <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">datapoints</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">single_energy_datapoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">datapoints</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
            <span class="n">single_energy_datapoints</span><span class="o">=</span><span class="p">[</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">single_energy_datapoints</span><span class="p">]</span>        <span class="c1">#remove energy</span>
            <span class="n">single_energy_datapoints</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>                         <span class="c1">#sort for increasing angles</span>
            <span class="n">single_energy_datapoints</span><span class="o">=</span><span class="p">((</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">single_energy_datapoints</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>                  <span class="c1">#make a numpy array out of it,transpose it, and transform it again to a list of lists</span>
            <span class="n">item</span><span class="o">=</span><span class="p">[</span><span class="n">energy</span><span class="p">]</span>                                                                    <span class="c1">#create one item for the list self._expdata</span>
            <span class="n">item</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">single_energy_datapoints</span><span class="p">)</span>                                            <span class="c1">#extend it, such that it looks like this [energyL,[angle1,....angleK], [rsigma1, .... rsigmaK], [rpi1,...rpiK]  or equivalent</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_expdata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_expdata</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">item</span><span class="p">:</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>                         <span class="c1">#sort with ascending energy</span>
            
    
    
    
    <span class="k">def</span> <span class="nf">_getHCFactor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hcfactor</span>
    
    
    <span class="c1">#public methods</span>
    
<div class="viewcode-block" id="ReflDataSimulator.ReadData"><a class="viewcode-back" href="../modules-api/experiment.html#Experiment.ReflDataSimulator.ReadData">[docs]</a>    <span class="k">def</span> <span class="nf">ReadData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">files</span><span class="p">,</span><span class="n">linereaderfunction</span><span class="p">,</span> <span class="n">energies</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">angles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filenamereaderfunction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pointmodifierfunction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">headerlines</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read the data files and store the data corresponding to the **mode** specified with instanciation (see :meth:`ReflDataSimulator.__init__`)</span>
<span class="sd">        </span>
<span class="sd">        This function enables a very flexible reading of the data files.</span>
<span class="sd">        Logically, this function uses data points which consist of the independent variables energy and angle, and the reflectivities as dependent variables (rsigma,rpi,rleft,rright,xmcd,total).</span>
<span class="sd">        So one point is specified by (energy,angle,rsigmag,rpi,rleft,rright,xmcd,total)  with energies in eV and angles in degrees.</span>
<span class="sd">        Where the values for the independent variables comes from can differ: either from lists (**energies**, **angles**), from the filenames (**filenamereaderfunction**) or from the lines in the data file (**linereaderfunction**).</span>
<span class="sd">        </span>
<span class="sd">        The function allows for multiple data reads. Each execution adds new data to the already stored one.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ---------</span>
<span class="sd">        files : str or list of str</span>
<span class="sd">            Specifies the set of data files. Either a list of filenames or one foldername of a folder containing all the data files (and only them!).</span>
<span class="sd">        linereaderfunction : callable</span>
<span class="sd">            A function given by the user which takes one line of an input file as string and returns a list/tuple of real numbers *(energy,angle,rsigma,rpi,rleft,rright,xmcd,total)*. Entries can also be \&#39;None\&#39;. Exceptions will only be trown if the needed information for the specified **mode** is not delivered. An easy way to create such a function is to use the method :meth:`.createLinereader`.</span>
<span class="sd">            The linereaderfunction can also return a list of lists if several datapoints are present in on line of the datafile.</span>
<span class="sd">        energies : list of floats</span>
<span class="sd">            Only possible to be different from *None* if **files** is a list of filenames and **angles** is `None`. Gives the energies which belong to the corresponding files (same order) as floats.</span>
<span class="sd">        angles : list of floats</span>
<span class="sd">            Only possible to be different from *None* if **files** is a list of filenames and **energies** is `None`. Gives the angles which belong to the corresponding files (same order) as floats.</span>
<span class="sd">        filenamereaderfunction : callable</span>
<span class="sd">            A user-defined function which reads energies and/or angles from the filenames of the data files. This function should take a string (a filename without path), extract energy and/or angle out of it and return this as a tuple/list *(energy,angle)*. Both entries can also be set to *None*, but their will be an exception if the needed information for the data points can also not be obtained from the **linereaderfunction**.</span>
<span class="sd">        pointmodifierfunction : callable</span>
<span class="sd">            A user-definde function which is used to modify the obtained information. It takes the tuple/list of independent and dependent variables of a single data point and returns a modified one. It can be used for example if the data file contains qz values instead of angles. In this case you can read the qz values first as angles and replace them afterwards with the angles calculated out of it with the **pointmodifierfunction**. Of course you can also use a adopted **linereaderfunction** for this purpose (if all necessary information can be found in one line of the data files).</span>
<span class="sd">        headerlines : int</span>
<span class="sd">            specifies the number of lines which should be ignored at the top of each file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1">#Parameter checking</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">files</span><span class="p">,(</span><span class="nb">tuple</span><span class="p">,</span><span class="nb">list</span><span class="p">,</span><span class="nb">str</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">files</span><span class="se">\&#39;</span><span class="s2"> has to be a list of filenames or a folder name.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">files</span><span class="p">,(</span><span class="nb">tuple</span><span class="p">,</span><span class="nb">list</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Entries of </span><span class="se">\&#39;</span><span class="s2">files</span><span class="se">\&#39;</span><span class="s2"> have to be strings.&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="o">+</span><span class="n">name</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2"> (entry of </span><span class="se">\&#39;</span><span class="s2">files</span><span class="se">\&#39;</span><span class="s2"> is not an existing file.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">files</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">files</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="o">+</span><span class="n">name</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2"> is not an existing directory.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">linereaderfunction</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">linereaderfunction</span><span class="se">\&#39;</span><span class="s2"> has to be callable.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">energies</span><span class="p">,(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span> <span class="ow">or</span> <span class="n">energies</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;\energies</span><span class="se">\&#39;</span><span class="s2"> has to be a list of numbers.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">energies</span><span class="p">,(</span><span class="nb">tuple</span><span class="p">,</span><span class="nb">list</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">en</span> <span class="ow">in</span> <span class="n">energies</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">en</span><span class="p">,</span><span class="n">numbers</span><span class="o">.</span><span class="n">Real</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Entries of </span><span class="se">\&#39;</span><span class="s2">energies</span><span class="se">\&#39;</span><span class="s2"> have to be real numbers.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">angles</span><span class="p">,(</span><span class="nb">tuple</span><span class="p">,</span><span class="nb">list</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">an</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">an</span><span class="p">,</span><span class="n">numbers</span><span class="o">.</span><span class="n">Real</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Entries of </span><span class="se">\&#39;</span><span class="s2">angles</span><span class="se">\&#39;</span><span class="s2"> have to be real numbers.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">callable</span><span class="p">(</span><span class="n">filenamereaderfunction</span><span class="p">)</span> <span class="ow">or</span> <span class="n">filenamereaderfunction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">filenamereaderfunction</span><span class="se">\&#39;</span><span class="s2"> has to be callable.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pointmodifierfunction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">pointmodifierfunction</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">pointmodifierfunction</span><span class="se">\&#39;</span><span class="s2"> has to be callable.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">headerlines</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;\headerlines</span><span class="se">\&#39;</span><span class="s2"> has to be an integer number.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">headerlines</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;\headerlines</span><span class="se">\&#39;</span><span class="s2"> has to be a positive number.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">energies</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">angles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">filenamereaderfunction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">energies</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">angles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">energies</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">filenamereaderfunction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>  <span class="ow">or</span> <span class="p">(</span><span class="n">angles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">filenamereaderfunction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Either use </span><span class="se">\&#39;</span><span class="s2">energies</span><span class="se">\&#39;</span><span class="s2">, </span><span class="se">\&#39;</span><span class="s2">angles</span><span class="se">\&#39;</span><span class="s2"> or </span><span class="se">\&#39;</span><span class="s2">filenamereaderfunction</span><span class="se">\&#39;</span><span class="s2"> but not several of them.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">energies</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">angles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">files</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">energies</span><span class="se">\&#39;</span><span class="s2"> or </span><span class="se">\&#39;</span><span class="s2">angles</span><span class="se">\&#39;</span><span class="s2"> can only be used if </span><span class="se">\&#39;</span><span class="s2">files</span><span class="se">\&#39;</span><span class="s2"> is an array of filenames.&quot;</span><span class="p">)</span>
        
        <span class="c1">#store parameters for later use with setMode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_datasourcestorage</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;source&quot;</span> <span class="p">:</span> <span class="s2">&quot;files&quot;</span><span class="p">,</span> <span class="s2">&quot;files&quot;</span> <span class="p">:</span> <span class="n">files</span><span class="p">,</span> <span class="s2">&quot;linereaderfunction&quot;</span> <span class="p">:</span> <span class="n">linereaderfunction</span><span class="p">,</span> <span class="s2">&quot;energies&quot;</span><span class="p">:</span> <span class="n">energies</span><span class="p">,</span> <span class="s2">&quot;angles&quot;</span><span class="p">:</span> <span class="n">angles</span><span class="p">,</span> <span class="s2">&quot;filenamereaderfunction&quot;</span><span class="p">:</span> <span class="n">filenamereaderfunction</span><span class="p">,</span> <span class="s2">&quot;pointmodifierfunction&quot;</span> <span class="p">:</span> <span class="n">pointmodifierfunction</span><span class="p">,</span> <span class="s2">&quot;headerlines&quot;</span> <span class="p">:</span> <span class="n">headerlines</span><span class="p">})</span>
        
        <span class="c1">#call _ReadDataCore</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ReadDataCore</span><span class="p">(</span><span class="n">files</span><span class="p">,</span><span class="n">linereaderfunction</span><span class="p">,</span> <span class="n">energies</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">filenamereaderfunction</span><span class="p">,</span> <span class="n">pointmodifierfunction</span><span class="p">,</span> <span class="n">headerlines</span><span class="p">)</span></div>
    



        
    
<div class="viewcode-block" id="ReflDataSimulator.setData"><a class="viewcode-back" href="../modules-api/experiment.html#Experiment.ReflDataSimulator.setData">[docs]</a>    <span class="k">def</span> <span class="nf">setData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">datapoints</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Store the data given with **datapoints** corresponding to the **mode** specified with instanciation (see :meth:`ReflDataSimulator.__init__`) instead of reading the data from data files (see :meth:`.ReadData`).</span>
<span class="sd">        </span>
<span class="sd">        **datapoints** has to be a list/array of datapoints of the following form:</span>
<span class="sd">           [[energy1,angle1,rsigma1,rpi1,rleft1,rright1,xmcd1,total1], ..., [energyK,angleK,rsigmaK,rpiK,rleftK,rrightK,xmcdK,totalK]</span>
<span class="sd">           </span>
<span class="sd">        Each datapoint corresponds to a measurement of the reflectivity at a certain angle and energy. Entries are alowed to hold *None* if the corresponding entry is not needed for current **mode**.</span>
<span class="sd">        </span>
<span class="sd">        The function allows for multiple data reads. Each execution adds new data to the already stored one.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1">#convert to numpy array</span>
        <span class="n">datapoints</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">datapoints</span><span class="p">)</span>
        <span class="c1">#some checks</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">datapoints</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>                        <span class="c1">#if not 2-dimensional</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input data has wrong shape.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">datapoints</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">8</span><span class="p">:</span>                           <span class="c1">#if datapoints do not have 8 entries</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input data has wrong shape.&quot;</span><span class="p">)</span>
        
        <span class="c1">#store parameters for later use with setMode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_datasourcestorage</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;source&quot;</span> <span class="p">:</span> <span class="s2">&quot;array&quot;</span><span class="p">,</span> <span class="s2">&quot;datapoints&quot;</span> <span class="p">:</span> <span class="n">datapoints</span><span class="p">})</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_setDataCore</span><span class="p">(</span><span class="n">datapoints</span><span class="p">)</span></div>

        
        
        
    
<div class="viewcode-block" id="ReflDataSimulator.setModel"><a class="viewcode-back" href="../modules-api/experiment.html#Experiment.ReflDataSimulator.setModel">[docs]</a>    <span class="k">def</span> <span class="nf">setModel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">heterostructure</span><span class="p">,</span> <span class="n">exp_energyshift</span><span class="o">=</span><span class="n">Parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">exp_angleshift</span><span class="o">=</span><span class="n">Parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">reflmodifierfunction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">MultipleScattering</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">MagneticCutoff</span><span class="o">=</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">50</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set up the model for the simulation of the reflectivity data. </span>
<span class="sd">        </span>
<span class="sd">        The simulation of the reflectivities is in prinicple done by using the information about the sample stored in **heterostructure** (of type :class:`SampleRepresentation.Heterostructure`). But to connect the simulation with the experiment it is also important to take into account systematic errors in energy and angles and to be able to adjust the simulated reflectivities to measured ones with offset and scaling.</span>
<span class="sd">        </span>
<span class="sd">        A first step concerns the independent variables energy and angles. We assume, the experiment does not measure the true quantities. Instead they measure shifted quantities: :math:`E_{exp}=E_{true}+\\mathrm{exp\_energyshift}` and :math:`\\theta_{exp}=\\theta_{true}+\\mathrm{exp\_angleshift}`.</span>
<span class="sd">        The simulated reflectivities will be calculated for the *true* quantities which correspond to the measured ones. (by substraction of the shifts)</span>
<span class="sd">        **exp_energyshift** and **exp_angleshift** are measured in *eV* and *degrees* resp.</span>
<span class="sd">        </span>
<span class="sd">    </span>
<span class="sd">        The calculated reflectivities are then given to the **reflmodifierfunction** for further modification of the reflectivity values (takes one number or numpy array and the fitpararray; returns one number or a numpy array). This function has to be defined </span>
<span class="sd">        by the user and can be used for example to multiply the reflectivity by a global number and/or to add a common background. To make these numbers fittable, use the fitparameters registerd at an instance of :class:`Paramters.ParamterPool`.</span>
<span class="sd">        Example::</span>
<span class="sd">        </span>
<span class="sd">            pp=Paramters.ParameterPool(&quot;any_parameterfile&quot;)</span>
<span class="sd">            ...</span>
<span class="sd">            b=pp.newParameter(&quot;background&quot;)</span>
<span class="sd">            m=pp.newParameter(&quot;multiplier&quot;)</span>
<span class="sd">            reflmodifierfunction=lambda r, fitpararray: b.getValue(fitpararray) + r * m.getValue(fitpararray)</span>
<span class="sd">        </span>
<span class="sd">        and give this function to :meth:`.setModel`.</span>
<span class="sd">        </span>
<span class="sd">        BEWARE: The reflmodifierfunction is called very often during fitting procedures. Make it performant!</span>
<span class="sd">               </span>
<span class="sd">        With **MultipleScattering** you can switch on (*True*) and off (*False*) the simulation of multiple scattering. *False* is 20 percent faster. Default is *True*. Has no effect on calculations that require the full matrix.</span>
<span class="sd">        </span>
<span class="sd">        **MagneticCutoff**: If an off-diagonal element of chi (chi_g) fulfills abs(chi_g)&lt;MagneticCutoff, it is set to zero. It defaults to 10e-50.</span>
<span class="sd">        </span>
<span class="sd">        The last two parameters are directly passed to :func:`Pythonreflectivity.Reflectivity`. See also the Documentation of :mod:`Pythonreflectivity`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">heterostructure</span><span class="p">,</span><span class="n">SampleRepresentation</span><span class="o">.</span><span class="n">Heterostructure</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">heterostructure</span><span class="se">\&#39;</span><span class="s2"> must be of type </span><span class="se">\&#39;</span><span class="s2">SampleRepresentation.Heterostructure</span><span class="se">\&#39;</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exp_energyshift</span><span class="p">,</span><span class="n">Parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">exp_energyshift</span><span class="se">\&#39;</span><span class="s2"> must be an instance of  </span><span class="se">\&#39;</span><span class="s2">Parameters.Parameter</span><span class="se">\&#39;</span><span class="s2"> or of an derived class.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exp_angleshift</span><span class="p">,</span><span class="n">Parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">exp_angleshift</span><span class="se">\&#39;</span><span class="s2"> must be an instance of  </span><span class="se">\&#39;</span><span class="s2">Parameters.Parameter</span><span class="se">\&#39;</span><span class="s2"> or of an derived class.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">reflmodifierfunction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">reflmodifierfunction</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">reflmodifierfunction</span><span class="se">\&#39;</span><span class="s2"> has to be callable.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">MultipleScattering</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">MultipleScattering</span><span class="se">\&#39;</span><span class="s2"> has to be a boolean value.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">MagneticCutoff</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Real</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;MagneticCutoff has to be a real number.&quot;</span><span class="p">)</span>            
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_hs</span><span class="o">=</span><span class="n">heterostructure</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_exp_energyshift</span><span class="o">=</span><span class="n">exp_energyshift</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_exp_angleshift</span><span class="o">=</span><span class="n">exp_angleshift</span>
        <span class="k">if</span> <span class="n">reflmodifierfunction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>                                            <span class="c1">#if no reflmodifierfunction is given, set hier the &quot;identity function&quot; to avoid testing for None in getSimData</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reflmodifierfunction</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">r</span><span class="p">,</span><span class="n">fitpararray</span><span class="p">:</span> <span class="n">r</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reflmodifierfunction</span><span class="o">=</span><span class="n">reflmodifierfunction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_multiplescattering</span><span class="o">=</span><span class="n">MultipleScattering</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_magneticcutoff</span><span class="o">=</span><span class="n">MagneticCutoff</span></div>
        
<div class="viewcode-block" id="ReflDataSimulator.getLenDataFlat"><a class="viewcode-back" href="../modules-api/experiment.html#Experiment.ReflDataSimulator.getLenDataFlat">[docs]</a>    <span class="k">def</span> <span class="nf">getLenDataFlat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return length of the flat data representation. </span>
<span class="sd">        </span>
<span class="sd">        It will be the number of measured data points times 2 for mode &quot;l&quot; and &quot;c&quot;, only the number of measured data points for mode &quot;x&quot; and &quot;t&quot;, and the number of measured data points times 3 for mode &quot;cx&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getExpDataFlat</span><span class="p">())</span></div>
        
        
<div class="viewcode-block" id="ReflDataSimulator.getSimData"><a class="viewcode-back" href="../modules-api/experiment.html#Experiment.ReflDataSimulator.getSimData">[docs]</a>    <span class="k">def</span> <span class="nf">getSimData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">fitpararray</span><span class="p">,</span> <span class="n">energy_angles</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return simulated data according to the bevor set-up model and the parameter values given with **fitpararray** (see also :mod:`Parameters`).</span>
<span class="sd">        Usually, the data is simulated for the energies and angles of the stored experimental data (substracted by *exp_energyshift* and *exp_angleshift*, see :meth:`.setModel`).</span>
<span class="sd">        </span>
<span class="sd">        If you specify **energy_angles**, then the data is simulated for the energy/angle combinations given there (also substracted by *exp_energyshift* and *exp_angleshift*, see :meth:`.setModel`).</span>
<span class="sd">        </span>
<span class="sd">        **energy_angles** has to have the following shape::</span>
<span class="sd">        </span>
<span class="sd">            [[energy1,[angle11,....angle1N]], ...[energyL,[angleL,....angleLK]] </span>
<span class="sd">        </span>
<span class="sd">        The returned data is a list and has on of the following or similar shapes::</span>
<span class="sd">            </span>
<span class="sd">            [[energy1,[angle1,....angleN], [rsigma1, .... rsigmaN], [rpi1,...rpiN]], ...[energyL,[angle1,....angleK], [rsigma1, .... rsigmaK], [rpi1,...rpiK]] </span>
<span class="sd">            [[energy1,[angle1,....angleN], [rleft1, .... rleftN], [rright1,...rrightN]], ...[energyL,[angle1,....angleK], [rleft1, .... rleftK], [rright1,...rrightK]] </span>
<span class="sd">            [[energy1,[angle1,....angleN], [xmcd1, .... xmcdN]], ...[energyL,[angle1,....angleK], [xmcd1, .... xmcdK]] </span>
<span class="sd">            [[energy1,[angle1,....angleN], [rleft1, .... rleftN], [rright1,...rrightN], [xmcd1, .... xmcdN]]], ...[energyL,[angle1,....angleK], [rleft1, .... rleftK], [rright1,...rrightK],[xmcd1, .... xmcdK]] </span>
<span class="sd">            [[energy1,[angle1,....angleN], [xmcd1, .... xmcdN]], ...[energyL,[angle1,....angleK], [total1, .... totalK]] </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># leave out parameter test, and test for existance of heterostructure to speed things up (this function will be called often in fit routines)</span>
        <span class="k">if</span> <span class="n">energy_angles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">simdata</span><span class="o">=</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_expdata</span><span class="p">)</span>                                    <span class="c1">#copy experimental data to get energies and angles</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">energy_angles</span><span class="p">,(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`energy_angles` needs to be a list or tuple.&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">energy_angles</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`energy_angles` has a wrong shape.&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">numbers</span><span class="o">.</span><span class="n">Real</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`energy_angles` has a wrong shape.&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`energy_angles` has a wrong shape.&quot;</span><span class="p">)</span>
            <span class="n">simdata</span><span class="o">=</span><span class="n">energy_angles</span>
        <span class="n">simdata_flat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_getSimDataFlat</span><span class="p">(</span><span class="n">fitpararray</span><span class="p">,</span><span class="n">energy_angles</span><span class="p">)</span>
        <span class="c1">#replace the copied experimental data with simulated values</span>
        <span class="n">startindex</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;l&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;lL&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;c&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;cL&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">simdata</span><span class="p">:</span>
                <span class="n">datalen</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">energy_angles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">item</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                    <span class="n">item</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                <span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">simdata_flat</span><span class="p">[</span><span class="n">startindex</span><span class="p">:</span><span class="n">startindex</span><span class="o">+</span><span class="n">datalen</span><span class="p">]</span>                                     <span class="c1">#rsigma or rleft</span>
                <span class="n">item</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">=</span><span class="n">simdata_flat</span><span class="p">[</span><span class="n">startindex</span><span class="o">+</span><span class="n">datalen</span><span class="p">:</span><span class="n">startindex</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">datalen</span><span class="p">]</span>                           <span class="c1">#rpi or rright</span>
                <span class="n">startindex</span><span class="o">=</span><span class="n">startindex</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">datalen</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;x&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;t&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;tL&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">simdata</span><span class="p">:</span>
                <span class="n">datalen</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">energy_angles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">item</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                <span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">simdata_flat</span><span class="p">[</span><span class="n">startindex</span><span class="p">:</span><span class="n">startindex</span><span class="o">+</span><span class="n">datalen</span><span class="p">]</span>                                     <span class="c1">#xmcd or sum of rleft and rright</span>
                <span class="n">startindex</span><span class="o">=</span><span class="n">startindex</span><span class="o">+</span><span class="n">datalen</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;cx&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">==</span><span class="s2">&quot;cLx&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">simdata</span><span class="p">:</span>
                <span class="n">datalen</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">energy_angles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">item</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                    <span class="n">item</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                    <span class="n">item</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                <span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">simdata_flat</span><span class="p">[</span><span class="n">startindex</span><span class="p">:</span><span class="n">startindex</span><span class="o">+</span><span class="n">datalen</span><span class="p">]</span>                                     <span class="c1">#rleft</span>
                <span class="n">item</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">=</span><span class="n">simdata_flat</span><span class="p">[</span><span class="n">startindex</span><span class="o">+</span><span class="n">datalen</span><span class="p">:</span><span class="n">startindex</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">datalen</span><span class="p">]</span>                           <span class="c1">#rright</span>
                <span class="n">item</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">=</span><span class="n">simdata_flat</span><span class="p">[</span><span class="n">startindex</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">datalen</span><span class="p">:</span><span class="n">startindex</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">datalen</span><span class="p">]</span>                         <span class="c1">#xmcd</span>
                <span class="n">startindex</span><span class="o">=</span><span class="n">startindex</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">datalen</span>
        <span class="k">return</span> <span class="n">simdata</span></div>
    
<div class="viewcode-block" id="ReflDataSimulator.getExpData"><a class="viewcode-back" href="../modules-api/experiment.html#Experiment.ReflDataSimulator.getExpData">[docs]</a>    <span class="k">def</span> <span class="nf">getExpData</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return stored experimental data.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        The retured data is a list and has on of the following or similar shapes::</span>
<span class="sd">            </span>
<span class="sd">            [[energy1,[angle1,....angleN], [rsigma1, .... rsigmaN], [rpi1,...rpiN]], ...[energyL,[angle1,....angleK], [rsigma1, .... rsigmaK], [rpi1,...rpiK]] </span>
<span class="sd">            [[energy1,[angle1,....angleN], [rleft1, .... rleftN], [rright1,...rrightN]], ...[energyL,[angle1,....angleK], [rleft1, .... rleftK], [rright1,...rrightK]] </span>
<span class="sd">            [[energy1,[angle1,....angleN], [xmcd1, .... xmcdN]], ...[energyL,[angle1,....angleK], [xmcd1, .... xmcdK]] </span>
<span class="sd">            [[energy1,[angle1,....angleN], [rleft1, .... rleftN], [rright1,...rrightN], [xmcd1, .... xmcdN]]], ...[energyL,[angle1,....angleK], [rleft1, .... rleftK], [rright1,...rrightK],[xmcd1, .... xmcdK]] </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expdata</span></div>
    
<div class="viewcode-block" id="ReflDataSimulator.getSSR"><a class="viewcode-back" href="../modules-api/experiment.html#Experiment.ReflDataSimulator.getSSR">[docs]</a>    <span class="k">def</span> <span class="nf">getSSR</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">fitpararray</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return sum of squared residuals between measured and simulated data as float according to the parameterset given by **fitpararray** (see also :mod:`Parameters`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getSimDataFlat</span><span class="p">(</span><span class="n">fitpararray</span><span class="p">))</span> <span class="o">-</span>  <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getExpDataFlat</span><span class="p">())</span> <span class="p">)</span>  <span class="p">)</span>      <span class="c1">#numpy.nansum sets all NaN within the sum to zero and performs summation afterwards</span></div>
    
<div class="viewcode-block" id="ReflDataSimulator.getResidualsSSR"><a class="viewcode-back" href="../modules-api/experiment.html#Experiment.ReflDataSimulator.getResidualsSSR">[docs]</a>    <span class="k">def</span> <span class="nf">getResidualsSSR</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">fitpararray</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the residuals and the sum of squared residuals between measured and simulated data according to the parameterset given by **fitpararray** (see also :mod:`Parameters`).</span>
<span class="sd">        </span>
<span class="sd">        The information is returned as tuple: array of differences between simulated and measured data, sum of squared residuals.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">residuals</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getSimDataFlat</span><span class="p">(</span><span class="n">fitpararray</span><span class="p">))</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getExpDataFlat</span><span class="p">())</span>
        <span class="n">ssr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span> <span class="n">residuals</span>  <span class="p">))</span>
        <span class="n">residuals</span><span class="o">=</span><span class="n">residuals</span><span class="p">[</span><span class="o">~</span><span class="n">numpy</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">residuals</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">residuals</span><span class="p">,</span><span class="n">ssr</span></div>
    
<div class="viewcode-block" id="ReflDataSimulator.getResiduals"><a class="viewcode-back" href="../modules-api/experiment.html#Experiment.ReflDataSimulator.getResiduals">[docs]</a>    <span class="k">def</span> <span class="nf">getResiduals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fitpararray</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the residuals between measured and simulated data according to the parameterset given by **fitpararray** (see also :mod:`Parameters`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">residuals</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getSimDataFlat</span><span class="p">(</span><span class="n">fitpararray</span><span class="p">))</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getExpDataFlat</span><span class="p">())</span>
        <span class="n">residuals</span><span class="o">=</span><span class="n">residuals</span><span class="p">[</span><span class="o">~</span><span class="n">numpy</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">residuals</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">residuals</span></div>
        
<div class="viewcode-block" id="ReflDataSimulator.plotData"><a class="viewcode-back" href="../modules-api/experiment.html#Experiment.ReflDataSimulator.plotData">[docs]</a>    <span class="k">def</span> <span class="nf">plotData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fitpararray</span><span class="p">,</span><span class="n">simcolor</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span><span class="n">expcolor</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="n">simlabel</span><span class="o">=</span><span class="s1">&#39;simulated&#39;</span><span class="p">,</span><span class="n">explabel</span><span class="o">=</span><span class="s1">&#39;experimental&#39;</span><span class="p">,</span><span class="n">energy_angles</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot simulated and experimental data.</span>
<span class="sd">        </span>
<span class="sd">        If **energy_angles** is given, it will only plot simulated data for the given energy/angle combinations.</span>
<span class="sd">        </span>
<span class="sd">        This function generates a plot at the first call and refreshes it if called again.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ---------</span>
<span class="sd">            simcolor : str</span>
<span class="sd">                Specifies the color of the simulated data for the plotting with pyplot (see https://matplotlib.org/users/colors.html). Default is red.</span>
<span class="sd">            expcolor : str  are supposed to be strings which specify a color for the plotting with pyplot (see https://matplotlib.org/users/colors.html).</span>
<span class="sd">                Specifies the color of the experimental data for the plotting with pyplot (see https://matplotlib.org/users/colors.html). Default is blue.</span>
<span class="sd">            simlabel : str </span>
<span class="sd">                Label shown in the legend of the plot for the simulated data. Default is *&quot;simulated&quot;*.</span>
<span class="sd">            explabel : str </span>
<span class="sd">                Label shown in the legend of the plot for the experimental data. Default is *&quot;experimental&quot;*.</span>
<span class="sd">            energy_angles : list</span>
<span class="sd">                If given, only simulated data will be plotted for the given energy/angle combinations.</span>
<span class="sd">                It has to have the following shape::</span>
<span class="sd">        </span>
<span class="sd">                    [[energy1,[angle11,....angle1N]], ...[energyL,[angleL,....angleLK]]</span>
<span class="sd">                    </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1">#check parameters</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">simcolor</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">simcolor</span><span class="se">\&#39;</span><span class="s2"> must be of string type.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expcolor</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">expcolor</span><span class="se">\&#39;</span><span class="s2"> must be of string type.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">simlabel</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">simlabel</span><span class="se">\&#39;</span><span class="s2"> must be of string type.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">explabel</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">explabel</span><span class="se">\&#39;</span><span class="s2"> must be of string type.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">energy_angles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">energy_angles</span><span class="p">,(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`energy_angles` needs to be a list or tuple.&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">energy_angles</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`energy_angles` has a wrong shape.&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">numbers</span><span class="o">.</span><span class="n">Real</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`energy_angles` has a wrong shape.&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`energy_angles` has a wrong shape.&quot;</span><span class="p">)</span>
        
        
        
        <span class="c1">#get data</span>
        <span class="n">simdata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getSimData</span><span class="p">(</span><span class="n">fitpararray</span><span class="p">,</span><span class="n">energy_angles</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">energy_angles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
          <span class="n">expdata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getExpData</span><span class="p">()</span>
           
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;_fig&#39;</span><span class="p">):</span>            <span class="c1">#close previous figure</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fig</span><span class="p">)</span>
        
        <span class="c1">#create figure and subplots</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">==</span> <span class="s2">&quot;l&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">==</span> <span class="s2">&quot;lL&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">==</span> <span class="s2">&quot;c&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">==</span> <span class="s2">&quot;cL&quot;</span><span class="p">:</span>      <span class="c1">#linear and circular polarization (or logarithm of it)       </span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">121</span><span class="p">,</span><span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>                  
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">122</span><span class="p">,</span><span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>                  
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">==</span> <span class="s2">&quot;x&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">==</span> <span class="s2">&quot;tL&quot;</span><span class="p">:</span>          <span class="c1">#xmcd and total</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span><span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>              <span class="c1">#for xmcd</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">==</span> <span class="s2">&quot;cx&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">==</span> <span class="s2">&quot;cLx&quot;</span> <span class="p">:</span>    <span class="c1">#circular polarization and xmcd</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">131</span><span class="p">,</span><span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>              <span class="c1">#for left circular pol </span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">132</span><span class="p">,</span><span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>              <span class="c1">#for right circular pol</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">133</span><span class="p">,</span><span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>              <span class="c1">#for xmcd</span>
        
                
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">==</span> <span class="s2">&quot;l&quot;</span><span class="p">:</span>            <span class="c1">#linear polarization</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;angle&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;sigma refl.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;theta&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;pi refl.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">energy_angles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">expdata</span><span class="p">:</span>                                                            <span class="c1">#go trough energies of experimental data</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">expcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and intensities on the z axis</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">expcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and intensities on the z axis</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">simdata</span><span class="p">:</span>                                                            <span class="c1">#go trough energies of simulated data</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">simcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and intensities on the z axis</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">simcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and intensities on the z axis</span>
        
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">==</span> <span class="s2">&quot;lL&quot;</span><span class="p">:</span>            <span class="c1">#log of linear polarization</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;angle&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;log( sigma refl. )&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;theta&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;log( pi refl. )&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">expdata</span><span class="p">:</span>                                                            <span class="c1">#go trough energies of experimental data</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">expcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and log of intensities on the z axis</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">expcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and log of intensities on the z axis</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">simdata</span><span class="p">:</span>                                                            <span class="c1">#go trough energies of simulated data</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">simcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and log of intensities on the z axis</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">simcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and log of intensities on the z axis</span>
        
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">==</span> <span class="s2">&quot;c&quot;</span><span class="p">:</span>            <span class="c1">#circular polarization</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;angle&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;left circ. refl.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;theta&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;right circ. refl.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">energy_angles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">expdata</span><span class="p">:</span>                                                            <span class="c1">#go trough energies of experimental data</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">expcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and intensities on the z axis</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">expcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and intensities on the z axis</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">simdata</span><span class="p">:</span>                                                            <span class="c1">#go trough energies of simulated data</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">simcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and intensities on the z axis</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">simcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and intensities on the z axis</span>
        
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">==</span> <span class="s2">&quot;cL&quot;</span><span class="p">:</span>            <span class="c1">#log of circular polarization</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;angle&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;log( left circ. refl. )&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;theta&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;log( right circ. refl. )&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">energy_angles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">expdata</span><span class="p">:</span>                                                            <span class="c1">#go trough energies of experimental data</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">expcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and log of intensities on the z axis</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">expcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and log of intensities on the z axis</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">simdata</span><span class="p">:</span>                                                            <span class="c1">#go trough energies of simulated data</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">simcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and log of intensities on the z axis</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">simcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and log of intensities on the z axis</span>
        
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>            <span class="c1">#sum of circular polarizations</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;angle&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;total refl.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">energy_angles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">expdata</span><span class="p">:</span>                                                            <span class="c1">#go trough energies of experimental data</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">expcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and xmcd on the z axis</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">simdata</span><span class="p">:</span>                                                            <span class="c1">#go trough energies of simulated data</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">simcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and xmcd on the z axis</span>
                
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">==</span> <span class="s2">&quot;tL&quot;</span><span class="p">:</span>            <span class="c1">#log of sum of circular polarizations</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;angle&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;log( total refl. )&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">energy_angles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">expdata</span><span class="p">:</span>                                                            <span class="c1">#go trough energies of experimental data</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">expcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and xmcd on the z axis</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">simdata</span><span class="p">:</span>                                                            <span class="c1">#go trough energies of simulated data</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">simcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and xmcd on the z axis</span>
        
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">==</span> <span class="s2">&quot;x&quot;</span><span class="p">:</span>            <span class="c1">#xmcd#log of sum of circular polarizations</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;angle&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;xmcd&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">energy_angles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">expdata</span><span class="p">:</span>                                                            <span class="c1">#go trough energies of experimental data</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">expcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and xmcd on the z axis</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">simdata</span><span class="p">:</span>                                                            <span class="c1">#go trough energies of simulated data</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">simcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and xmcd on the z axis</span>
                        
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">==</span> <span class="s2">&quot;cx&quot;</span><span class="p">:</span>          <span class="c1">#circular polarization and xmcd</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax3</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;angle&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;left circ. refl.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;theta&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;right circ. refl.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax3</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;angle&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax3</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xmcdfactor</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax3</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;xmcd&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax3</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;xmcd * &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xmcdfactor</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">energy_angles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">expdata</span><span class="p">:</span>                                                            <span class="c1">#go trough energies of experimental data</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">expcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and intensities on the z axis</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">expcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and intensities on the z axis</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_ax3</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">4</span><span class="p">]),</span><span class="n">color</span><span class="o">=</span><span class="n">expcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and xmcd on the z axis</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">simdata</span><span class="p">:</span>                                                            <span class="c1">#go trough energies of simulated data</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">simcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and intensities on the z axis</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">simcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and intensities on the z axis</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax3</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">4</span><span class="p">]),</span><span class="n">color</span><span class="o">=</span><span class="n">simcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and xmcd on the z axis</span>
        
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">==</span> <span class="s2">&quot;cLx&quot;</span><span class="p">:</span>          <span class="c1">#log of circular polarization and xmcd</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax3</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;angle&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;log( left circ. refl. )&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;theta&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;log( right circ. refl. )&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax3</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;angle&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax3</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xmcdfactor</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax3</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;xmcd&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax3</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;xmcd * &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xmcdfactor</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">energy_angles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">expdata</span><span class="p">:</span>                                                            <span class="c1">#go trough energies of experimental data</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">expcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and intensities on the z axis</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">expcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and intensities on the z axis</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_ax3</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">4</span><span class="p">]),</span><span class="n">color</span><span class="o">=</span><span class="n">expcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and xmcd on the z axis</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">simdata</span><span class="p">:</span>                                                            <span class="c1">#go trough energies of simulated data</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">simcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and intensities on the z axis</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">item</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">simcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and intensities on the z axis</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ax3</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">4</span><span class="p">]),</span><span class="n">color</span><span class="o">=</span><span class="n">simcolor</span><span class="p">)</span>   <span class="c1">#angles on the x axis, energies on the y axis and xmcd on the z axis</span>
        
        <span class="c1">#create legend</span>
        <span class="n">exp_patch</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">Patch</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="n">expcolor</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="n">explabel</span><span class="p">)</span>
        <span class="n">sim_patch</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">Patch</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="n">simcolor</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="n">simlabel</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">handles</span><span class="o">=</span><span class="p">[</span><span class="n">exp_patch</span><span class="p">,</span><span class="n">sim_patch</span><span class="p">])</span>
        
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">pause</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="ReflDataSimulator.setMode"><a class="viewcode-back" href="../modules-api/experiment.html#Experiment.ReflDataSimulator.setMode">[docs]</a>    <span class="k">def</span> <span class="nf">setMode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">mode</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Change the mode after instantiation.</span>
<span class="sd">           </span>
<span class="sd">        Be carefull with this function. Errors can occur if the mode does not fit to the available information in the data files.</span>
<span class="sd">           </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mode : string</span>
<span class="sd">            The following modes are implemented so far:</span>
<span class="sd">                </span>
<span class="sd">            * \&#39;l\&#39;             - for linear polarized light, only reflectivity for sigma and pi polarization will be stored and simulated</span>
<span class="sd">            * \&#39;c\&#39;             - for circular polarized light, only reflectivity for left circular and right circular polarization will be stored and simulated</span>
<span class="sd">            * \&#39;s\&#39;             - only the sum of the reflectivities of left and right polarized light will be stored and simulated (contains only structural information)</span>
<span class="sd">            * \&#39;x\&#39;             - for xmcd, only the difference between the reflectivity for right circular and left circular polarization will be stored and simulated. Actually, it is the normalized XMCD or asymmetry *(rleft-rright)/(rleft+rright)*.</span>
<span class="sd">            * \&#39;cx&lt;xfactor&gt;\&#39;   - for the reflections of circular pol. light and the xmcd signal (which should usually been calculated from the left and right circ. pol.) simultaniously \&#39;&lt;xfactor&gt;\&#39; is optional and can be used to multiply the xmcd signal with this value. This can be usefull to give the xmcd more or less weight during fitting e.g.\&#39;cx20\&#39; or \&#39;cx0.1\&#39;</span>
<span class="sd">            * \&#39;lL\&#39;, \&#39;cL\&#39;, \&#39;sL\&#39;, \&#39;xL\&#39;, \&#39;cLx&lt;xfactor&gt;\&#39;, - as before, but instead of the corresponding reflectivities themselfs their logarithms are stored and simulated. This is usefull for fitting as with the logarithm the errors of different data points are weighted in a comparable way, in spite of the strongly decaying intensitiy for higher angles (see J.Pyhs.: Condens. Matter 26 (2014) 363201, page 16).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1">#have a look on  self._expdata and self._datasourcestorage before it is set to &quot;zero&quot; by initialization</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expdata</span><span class="o">==</span><span class="p">[]:</span>
            <span class="n">existingdata</span><span class="o">=</span><span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">existingdata</span><span class="o">=</span><span class="kc">False</span>
        <span class="n">datasourcestorage</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_datasourcestorage</span>
        <span class="c1">#use the __init__ method to change mode to be sure to treat mode in the same way, even if changes occur in the futur</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_lengthscale</span><span class="p">)</span>
        <span class="c1">#read data again if already read</span>
        <span class="k">if</span> <span class="n">existingdata</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_datasourcestorage</span><span class="o">=</span><span class="n">datasourcestorage</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_datasourcestorage</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">item</span><span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;files&quot;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_ReadDataCore</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="s2">&quot;files&quot;</span><span class="p">],</span> <span class="n">item</span><span class="p">[</span><span class="s2">&quot;linereaderfunction&quot;</span><span class="p">],</span> <span class="n">item</span><span class="p">[</span><span class="s2">&quot;energies&quot;</span><span class="p">],</span> <span class="n">item</span><span class="p">[</span><span class="s2">&quot;angles&quot;</span><span class="p">],</span> <span class="n">item</span><span class="p">[</span><span class="s2">&quot;filenamereaderfunction&quot;</span><span class="p">],</span> <span class="n">item</span><span class="p">[</span><span class="s2">&quot;pointmodifierfunction&quot;</span><span class="p">],</span> <span class="n">item</span><span class="p">[</span><span class="s2">&quot;headerlines&quot;</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">item</span><span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;array&quot;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_setDataCore</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="s2">&quot;datapoints&quot;</span><span class="p">])</span></div>
               
        
<div class="viewcode-block" id="ReflDataSimulator.createLinereader"><a class="viewcode-back" href="../modules-api/experiment.html#Experiment.ReflDataSimulator.createLinereader">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">createLinereader</span><span class="p">(</span><span class="n">energy_column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">angle_column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rsigma_angle_column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rsigma_column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rpi_angle_column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rpi_column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rleft_angle_column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rleft_column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rright_angle_column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rright_column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xmcd_angle_column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xmcd_column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">total_angle_column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">total_column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">commentsymbol</span><span class="o">=</span><span class="s1">&#39;#&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a linereader function which can read lines from whitespace-seperated files and returns a datapoint, which is a lists of real numbers *[energy,angle,rsigma,rpi,rleft,rright,xmcd,sum]* (or *None* for a uncommented line).</span>
<span class="sd">        Values can also be *None*.</span>
<span class="sd">        The linereader function returns a list of datapoints if several angles are defined within one line.</span>
<span class="sd">        </span>
<span class="sd">        With the parameters *..._column* you can determin wich column is interpreted how.</span>
<span class="sd">        Instead of one angle for all reflectivities within one line (**angle_column**), one can also define columns for angles which are specifically for one reflectivity polarization.</span>
<span class="sd">        Column numbers are starting from 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#check parameters</span>
        <span class="n">indep_pars_columns</span><span class="o">=</span><span class="p">[</span><span class="n">energy_column</span><span class="p">,</span><span class="n">angle_column</span><span class="p">]</span>
        <span class="n">values_columns</span><span class="o">=</span><span class="p">[</span><span class="n">rsigma_column</span><span class="p">,</span> <span class="n">rpi_column</span><span class="p">,</span> <span class="n">rleft_column</span><span class="p">,</span> <span class="n">rright_column</span><span class="p">,</span> <span class="n">xmcd_column</span><span class="p">,</span> <span class="n">total_column</span><span class="p">]</span>                                                      <span class="c1">#BEWARE: values_columns and additional_angles_columns have to have corresponding entries with the same order!!!</span>
        <span class="n">additional_angles_columns</span><span class="o">=</span><span class="p">[</span><span class="n">rsigma_angle_column</span><span class="p">,</span> <span class="n">rpi_angle_column</span><span class="p">,</span> <span class="n">rleft_angle_column</span><span class="p">,</span> <span class="n">rright_angle_column</span><span class="p">,</span> <span class="n">xmcd_angle_column</span><span class="p">,</span> <span class="n">total_angle_column</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">indep_pars_columns</span><span class="o">+</span><span class="n">values_columns</span><span class="o">+</span><span class="n">additional_angles_columns</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">item</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Columns have to be given as integer numbers.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">item</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">item</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Columns have to be positive numbers.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">commentsymbol</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">commentsymbol</span><span class="se">\&#39;</span><span class="s2"> has to be a string.&quot;</span><span class="p">)</span>
        
        <span class="c1">#define the linereader function without additional angles</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">item</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">additional_angles_columns</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">linereader</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">line</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">line</span><span class="se">\&#39;</span><span class="s2"> needs to be a string.&quot;</span><span class="p">)</span>
                    <span class="n">line</span><span class="o">=</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">commentsymbol</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>                            <span class="c1">#ignore everything behind the commentsymbol  #</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="o">.</span><span class="n">isspace</span><span class="p">()</span> <span class="ow">and</span> <span class="n">line</span><span class="p">:</span>                               <span class="c1">#ignore empty lines        </span>
                        <span class="n">linearray</span><span class="o">=</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                        <span class="n">linelist</span><span class="o">=</span><span class="p">[]</span>
                        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">indep_pars_columns</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">item</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                                <span class="n">linelist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span> 
                                <span class="n">linelist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">linearray</span><span class="p">[</span><span class="n">item</span><span class="p">]))</span>
                        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">values_columns</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">item</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                                <span class="n">linelist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">linelist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">linearray</span><span class="p">[</span><span class="n">item</span><span class="p">]))</span>
                        <span class="k">return</span> <span class="n">linelist</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">None</span>
       
        <span class="k">else</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">linereader</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">line</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">line</span><span class="se">\&#39;</span><span class="s2"> needs to be a string.&quot;</span><span class="p">)</span>
                    <span class="n">line</span><span class="o">=</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">commentsymbol</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>                            <span class="c1">#ignore everything behind the commentsymbol  #</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="o">.</span><span class="n">isspace</span><span class="p">()</span> <span class="ow">and</span> <span class="n">line</span><span class="p">:</span>                               <span class="c1">#ignore empty lines        </span>
                        <span class="n">linearray</span><span class="o">=</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                        <span class="n">pointlist</span><span class="o">=</span><span class="p">[]</span>
                        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">angle_column</span><span class="p">,</span> <span class="n">value_column</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">additional_angles_columns</span><span class="p">))),</span> <span class="n">additional_angles_columns</span><span class="p">,</span> <span class="n">values_columns</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">angle_column</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                                <span class="n">point</span><span class="o">=</span><span class="p">[]</span>
                                <span class="c1">#energy</span>
                                <span class="k">if</span> <span class="n">energy_column</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                                    <span class="n">point</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">point</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">linearray</span><span class="p">[</span><span class="n">energy_column</span><span class="p">]))</span>
                                <span class="c1">#angle</span>
                                <span class="n">point</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">linearray</span><span class="p">[</span><span class="n">angle_column</span><span class="p">]))</span>
                                <span class="c1">#values</span>
                                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                                    <span class="n">point</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">value_column</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                                    <span class="n">point</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">point</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">linearray</span><span class="p">[</span><span class="n">value_column</span><span class="p">]))</span>
                                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values_columns</span><span class="p">)</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                                    <span class="n">point</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                                <span class="n">pointlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
                        <span class="k">return</span> <span class="n">pointlist</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">None</span>
        
        <span class="k">return</span> <span class="n">linereader</span></div>
    
    
    <span class="c1">#public properties</span>
    <span class="n">mode</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getMode</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;The current mode. See :meth:`.__init__` for possible modes. Read-only.&quot;&quot;&quot;</span>
    <span class="n">hcfactor</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getHCFactor</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;Planck constant times the speed of light in units of *eV* times the unit of length which was defined by **length_scale** with :meth:`.__init__`. Read-only.</span>
<span class="sd">       BEWARE: It is *h* times *c* not *h_bar* times *c*.</span>
<span class="sd">    &quot;&quot;&quot;</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PyXMRTool 0.9 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Yannic Utz.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.0.1.
    </div>
  </body>
</html>