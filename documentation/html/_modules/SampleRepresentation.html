
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>SampleRepresentation &#8212; PyXMRTool 0.9 documentation</title>
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PyXMRTool 0.9 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h3><a href="../index.html">Table of Contents</a></h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">PyXMRToolâ€™s documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">todo: Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hints.html">Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../definitions.html">Terms and Definitions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../development.html">Developement</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for SampleRepresentation</h1><div class="highlight"><pre>
<span class="c1"># &lt;PyXMRTool: A Python Package for the analysis of X-Ray Magnetic Reflectivity data measured on heterostructures&gt;</span>
<span class="c1">#    Copyright (C) &lt;2018&gt;  &lt;Yannic Utz&gt;</span>
<span class="c1">#</span>
<span class="c1">#    This program is free software: you can redistribute it and/or modify</span>
<span class="c1">#    it under the terms of the GNU Lesser General Public License as published by</span>
<span class="c1">#    the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1">#    (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1">#    This program is distributed in the hope that it will be useful,</span>
<span class="c1">#    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1">#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1">#    GNU Lesser General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1">#    You should have received a copy of the GNU Lesser General Public License</span>
<span class="c1">#    along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.</span>


<span class="sd">&quot;&quot;&quot;Deals with the sample representation for simulation of the reflectivity.</span>

<span class="sd">A multilayer sample is represented by a :class:`.Heterostructure` object. Its main pupose is to deliver the list of layers (Layer type of the :mod:`Pythonreflectivity` package from Martin Zwiebler) with defined susceptibilities at certain energies via :meth.`Heterostructure.getSingleEnergyStructure`. The layers within this heterostructure are represented by instances of :class:`.LayerObject` or of derived classes, which alows for a very flexibel modelling of the sample.</span>

<span class="sd">So far the following layer types are implemented:</span>

<span class="sd">* :class:`.LayerObject`: Layer with a constant (over energy) but fittable electric susceptibility tensor.</span>

<span class="sd">* :class:`.ModelChiLayerObject`: This layer type holds the electric susceptibility tensor as a user-defined function of energy.</span>

<span class="sd">* :class:`.MagneticLayerObject`: This layer type deals with a magnetic layer and therefor creates the off-diagonal elements of the susceptibitlity tensor from a magnetic term and two angles.</span>
<span class="sd">    </span>
<span class="sd">* :class:`.AtomLayerObject`: This layer deals with compositions of atoms with different formfactors. The densities of the atoms can be varied during fitting procedures and plotted with using :func:`.plotAtomDensity`. The formfactors are represented by instances of classes which are derived from :class:`.Formfactor` (the base class is abstract and cannot be used directly).</span>

<span class="sd">So far the following formfactor types are implemented:</span>

<span class="sd">* :class:`.FFfromFile`: Reads an energy-dependent formfactor as data points from a textfile. For energies between the data points the formfactor is linearly interpolated.</span>

<span class="sd">* :class:`.FFfromScaledAbsorption`: Reads an absorption measurement (fitted to off-resonant tabulated values) and a theoretical/tabulated energy-dependen formfactor from textfiles. Within a given energy-range, the absorption is scaled with a fittable factor and the real part is obtained by a Kramers-Kronig transformation. See section 3.3 of Martin Zwiebler PhD-Thesis for details.</span>

<span class="sd">* :class:`.FFfromFitableModel`: Formfactor from user-defined fitable model functions. Can be used to implement e.g. a Kramers-Kronig variational approach.</span>

<span class="sd">* :class:`.MagneticFormfactor`: Basic formfactor class to deal with a magnetic formfactor, i.e. only the off-diagonal elements of a formfactor tensor. Magnetic terms are defined by the user as instances of :class:`Parameters.ParametrizedFunction`.</span>

<span class="sd">* :class:`.MFFfromXMCD`: A magnetic formfactor which is created from an XMCD measurement.</span>

<span class="sd">To allow for atomic slicing you can create density profiles with class :class:`.DensityProfile` or the specialized :class:`.DensityProfile_erf`. Once created, they can provide atomic densities used in :class:`.AtomLayerObject` for the different layers (which are used as slices).</span>

<span class="sd">The function :func:`.plotAtomDensity` can be used to plot the variation of atom densities between the layers.</span>
<span class="sd">    </span>


<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># Python Version 3.6</span>


<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Yannic Utz&quot;</span>
<span class="n">__copyright__</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
<span class="n">__credits__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Yannic Utz and Martin Zwiebler&quot;</span><span class="p">]</span>
<span class="n">__license__</span> <span class="o">=</span> <span class="s2">&quot;GNU General Public License v3.0&quot;</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;0.9&quot;</span>
<span class="n">__maintainer__</span> <span class="o">=</span> <span class="s2">&quot;Yannic Utz&quot;</span>
<span class="n">__email__</span> <span class="o">=</span> <span class="s2">&quot;yannic.utz@tu-dresden.de&quot;</span>
<span class="n">__status__</span> <span class="o">=</span> <span class="s2">&quot;beta&quot;</span>

<span class="kn">import</span> <span class="nn">os.path</span>
<span class="kn">import</span> <span class="nn">numbers</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">ast</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">interpolate</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">optimize</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="k">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">Pythonreflectivity</span>

<span class="kn">from</span> <span class="nn">PyXMRTool</span> <span class="k">import</span> <span class="n">Parameters</span>

<span class="c1"># -----------------------------------------------------------------------------------------------------------------------------</span>
<span class="c1"># global variables for setup</span>

<span class="n">chantler_directory</span> <span class="o">=</span> <span class="s2">&quot;resources/ChantlerTables&quot;</span>  <span class="c1"># directory which contains Chantler tables relative to this module&#39;s directory</span>
<span class="n">chantler_suffix</span> <span class="o">=</span> <span class="s2">&quot;.cff&quot;</span>  <span class="c1"># suffix of files containing a Chantler table</span>
<span class="n">chantler_reader_file</span> <span class="o">=</span> <span class="s2">&quot;ChantlerReader.pyt&quot;</span>  <span class="c1"># filename of the file containing the function chantler_linereader()</span>

<span class="c1"># -----------------------------------------------------------------------------------------------------------------------------</span>
<span class="c1"># some stuff happening at execution of the module</span>

<span class="n">package_directory</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">__file__</span><span class="p">))</span>  <span class="c1"># store the absolute path of this  module</span>
<span class="n">exec</span><span class="p">(</span><span class="nb">compile</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">package_directory</span><span class="p">,</span> <span class="n">chantler_directory</span><span class="p">,</span> <span class="n">chantler_reader_file</span><span class="p">))</span><span class="o">.</span><span class="n">read</span><span class="p">(),</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">package_directory</span><span class="p">,</span> <span class="n">chantler_directory</span><span class="p">,</span> <span class="n">chantler_reader_file</span><span class="p">),</span> <span class="s1">&#39;exec&#39;</span><span class="p">))</span>


<span class="c1"># -----------------------------------------------------------------------------------------------------------------------------</span>
<span class="c1"># Heterostructure</span>

<div class="viewcode-block" id="Heterostructure"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.Heterostructure">[docs]</a><span class="k">class</span> <span class="nc">Heterostructure</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Represents a heterostructure as a stack of instances of :class:`.LayerObject` or of derived classes.</span>
<span class="sd">    Its main pupose is to model the sample in a very flexibel way and to get the list of layers (Layer type of the :mod:`Pythonreflectivity` package from Martin Zwiebler) with defined susceptibilities at certain energies.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    In contrast to Martin&#39;s list of Layer-type objects, this class contains all information also for different energies.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Heterostructure.__init__"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.Heterostructure.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_layers</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">multilayer_structure</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create heterostructructure object.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        number_of_layers : int </span>
<span class="sd">            gives the number of different layers</span>
<span class="sd">        multilayer_structure : list</span>
<span class="sd">            Makes it possible to define multilayers which contain identical layers several times.</span>
<span class="sd">            This can be done by passing a list containing the indices of layers from the lowest (e.g. substrate) to the highest (top layer, hit first by the beam).</span>
<span class="sd">            Default is ``[0,1,2,3, ...,number_of_layers-1]``. Multilayer syntax is e.g.``[0,1,2,[100,[3,4,5,6]],7,.,1,..]`` which repeats 100 times the sequence of</span>
<span class="sd">            layers 3,4,5,6 in between 2 and 7 and later on layer 1 is repeated once.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">number_of_layers</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">number_of_layers</span><span class="se">\&#39;</span><span class="s2"> must be of type int.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">number_of_layers</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">number_of_layers</span><span class="se">\&#39;</span><span class="s2"> must be positive.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">multilayer_structure</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">multilayer_structure</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">number_of_layers</span><span class="p">))</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">multilayer_structure</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">multilayer_structure</span><span class="se">\&#39;</span><span class="s2"> has to be a list.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_consistency_check</span><span class="p">(</span><span class="n">number_of_layers</span><span class="p">,</span> <span class="n">multilayer_structure</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_number_of_layers</span> <span class="o">=</span> <span class="n">number_of_layers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_multilayer_structure</span> <span class="o">=</span> <span class="n">multilayer_structure</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_listoflayers</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_of_layers</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_updatePyReflMLString</span><span class="p">()</span></div>

    <span class="c1"># private members</span>

    <span class="k">def</span> <span class="nf">_consistency_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_layers</span><span class="p">,</span> <span class="n">multilayer_structure</span><span class="p">):</span>
        <span class="n">index_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">multilayer_structure</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">item</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">index_list</span><span class="p">:</span>
                    <span class="n">index_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">list</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">multilayer_structure</span><span class="se">\&#39;</span><span class="s2"> has wrong format.&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">subitem</span> <span class="ow">in</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">subitem</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">multilayer_structure</span><span class="se">\&#39;</span><span class="s2"> has wrong format.&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">subitem</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">index_list</span><span class="p">:</span>
                        <span class="n">index_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subitem</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">multilayer_structure</span><span class="se">\&#39;</span><span class="s2"> has wrong format.&quot;</span><span class="p">)</span>
        <span class="n">index_list</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">index_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Indices in </span><span class="se">\&#39;</span><span class="s2">multilayer_structure</span><span class="se">\&#39;</span><span class="s2"> have to start from 0.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">index_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">index_list</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Highest index in </span><span class="se">\&#39;</span><span class="s2">multilayer_structure</span><span class="se">\&#39;</span><span class="s2"> does not agree with the number of different indices-1.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">index_list</span><span class="p">)</span> <span class="o">!=</span> <span class="n">number_of_layers</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;Number of different indices in </span><span class="se">\&#39;</span><span class="s2">multilayer_structure</span><span class="se">\&#39;</span><span class="s2"> does not agree with </span><span class="se">\&#39;</span><span class="s2">number_of_layers</span><span class="se">\&#39;</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">index_list</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_updatePyReflMLString</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_PyReflMLstring</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multilayer_structure</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_PyReflMLstring</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;,&quot;</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_PyReflMLstring</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_PyReflMLstring</span> <span class="o">+=</span> <span class="s2">&quot;*&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_PyReflMLstring</span> <span class="o">+=</span> <span class="s2">&quot;(&quot;</span>
                <span class="k">for</span> <span class="n">subitem</span> <span class="ow">in</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_PyReflMLstring</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">subitem</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;,&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_PyReflMLstring</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_PyReflMLstring</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># remove last comma</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_PyReflMLstring</span> <span class="o">+=</span> <span class="s2">&quot;),&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_PyReflMLstring</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_PyReflMLstring</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># remove last comma</span>

    <span class="k">def</span> <span class="nf">_getNumberOfLayers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return number of different layers (i.e. number of different indices).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_number_of_layers</span>

    <span class="k">def</span> <span class="nf">_getTotalNumberOfLayers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return total number of layers (counting also multiple use of the same layer according to \&#39;multilayer_structure\&#39;).&quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multilayer_structure</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">n</span> <span class="o">+=</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">n</span>

    <span class="k">def</span> <span class="nf">_mapTotalIndexToInternal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tot_ind</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the index used within \&#39;multilayer_structure\&#39; which corresponds to the total index of the layer counting from the bottom.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tot_ind</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_total</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Index out of range.&quot;</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multilayer_structure</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">tot_ind</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">item</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">loop</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="k">for</span> <span class="n">subitem</span> <span class="ow">in</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">tot_ind</span><span class="p">:</span>
                            <span class="k">return</span> <span class="n">subitem</span>
                        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># public methods</span>

<div class="viewcode-block" id="Heterostructure.setLayout"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.Heterostructure.setLayout">[docs]</a>    <span class="k">def</span> <span class="nf">setLayout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_layers</span><span class="p">,</span> <span class="n">multilayer_structure</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Change the layout of the heterostructure.</span>
<span class="sd">        </span>
<span class="sd">           See :meth:`.__init__` for details. Only difference is: you cannot make changes which would remove layers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">number_of_layers</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">number_of_layers</span><span class="se">\&#39;</span><span class="s2"> must be of type int.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">number_of_layers</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">number_of_layers</span><span class="se">\&#39;</span><span class="s2"> must be positive.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">multilayer_structure</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">multilayer_structure</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">number_of_layers</span><span class="p">))</span>
            <span class="n">numberofindices</span> <span class="o">=</span> <span class="n">number_of_layers</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">multilayer_structure</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">multilayer_structure</span><span class="se">\&#39;</span><span class="s2"> has to be a list.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">numberofindices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_consistency_check</span><span class="p">(</span><span class="n">number_of_layers</span><span class="p">,</span> <span class="n">multilayer_structure</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">numberofindices</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_listoflayers</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_listoflayers</span><span class="p">[</span><span class="n">numberofindices</span><span class="p">:]:</span>
                <span class="k">if</span> <span class="n">item</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                        <span class="s2">&quot;Cannot change layout. Remove layers with index &gt; &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">numberofindices</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; first.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_listoflayers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_listoflayers</span><span class="p">[:</span><span class="n">numberofindices</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">numberofindices</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_listoflayers</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_listoflayers</span> <span class="o">+=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numberofindices</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_listoflayers</span><span class="p">))]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_number_of_layers</span> <span class="o">=</span> <span class="n">number_of_layers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_multilayer_structure</span> <span class="o">=</span> <span class="n">multilayer_structure</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_updatePyReflMLString</span><span class="p">()</span></div>

<div class="viewcode-block" id="Heterostructure.setLayer"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.Heterostructure.setLayer">[docs]</a>    <span class="k">def</span> <span class="nf">setLayer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">layer</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Place **layer** (instance of :class:`.LayerObject`) at position **index** (counting from 0, starting from the bottom or according to indices defined by **multilayer_structure**).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">index</span><span class="se">\&#39;</span><span class="s2"> must be of type int.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">index</span><span class="se">\&#39;</span><span class="s2"> must be positive.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_number_of_layers</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">index</span><span class="se">\&#39;</span><span class="s2"> exceeds defined number of layers.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">LayerObject</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">layer</span><span class="se">\&#39;</span><span class="s2"> has to be an instance of </span><span class="se">\&#39;</span><span class="s2">LayerObject</span><span class="se">\&#39;</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_listoflayers</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">layer</span></div>

<div class="viewcode-block" id="Heterostructure.getLayer"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.Heterostructure.getLayer">[docs]</a>    <span class="k">def</span> <span class="nf">getLayer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the instance of :class:`.LayerObject` which is placed at position **index** (counting from 0, starting from the bottom or according to indices defined by **multilayer_structure**).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">index</span><span class="se">\&#39;</span><span class="s2"> must be of type int.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">index</span><span class="se">\&#39;</span><span class="s2"> must be positive.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_number_of_layers</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">index</span><span class="se">\&#39;</span><span class="s2"> exceeds defined number of layers.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_listoflayers</span><span class="p">[</span><span class="n">index</span><span class="p">]</span></div>

<div class="viewcode-block" id="Heterostructure.getTotalLayer"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.Heterostructure.getTotalLayer">[docs]</a>    <span class="k">def</span> <span class="nf">getTotalLayer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the instance of :class:`.LayerObject` which is placed at position **index** (counting from 0, starting from the bottom, repeated layers are counted repeatedly).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getLayer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mapTotalIndexToInternal</span><span class="p">(</span><span class="n">index</span><span class="p">))</span></div>

<div class="viewcode-block" id="Heterostructure.removeLayer"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.Heterostructure.removeLayer">[docs]</a>    <span class="k">def</span> <span class="nf">removeLayer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove the instance of :class:`.LayerObject` which is placed at position **index** (counting from 0, starting from the bottom or according to indices defined by **multilayer_structure**).</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        **index** can also be a list of indices.</span>
<span class="sd">        BEWARE: The instance of :class:`.LayerObject` itself and the corresdonding instances of :class:`Parameters.Fitparameter` are not deleted! So in a following fitting procedure, these parameters might still be varied even though they don&#39;t have any effect on the result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">index</span><span class="se">\&#39;</span><span class="s2"> must be positive.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_number_of_layers</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">index</span><span class="se">\&#39;</span><span class="s2"> exceeds defined number of layers.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_listoflayers</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">index</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="s2">&quot;Entries of </span><span class="se">\&#39;</span><span class="s2">index</span><span class="se">\&#39;</span><span class="s2"> list must be of type int.&quot;</span>
                <span class="k">if</span> <span class="n">item</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Entries of </span><span class="se">\&#39;</span><span class="s2">index</span><span class="se">\&#39;</span><span class="s2"> list must be positive.&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">item</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_number_of_layers</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Entry of </span><span class="se">\&#39;</span><span class="s2">index</span><span class="se">\&#39;</span><span class="s2"> list exceeds defined number of layers.&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_listoflayers</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">index</span><span class="se">\&#39;</span><span class="s2"> must be of type int or list of int&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Heterostructure.getSingleEnergyStructure"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.Heterostructure.getSingleEnergyStructure">[docs]</a>    <span class="k">def</span> <span class="nf">getSingleEnergyStructure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fitpararray</span><span class="p">,</span> <span class="n">energy</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return list of layers (Layer type of the :mod:`Pythonreflectivity` package from Martin Zwiebler) which can be directly used as input for :func:`Pythonreflectivity.Reflectivity`.</span>
<span class="sd">        </span>
<span class="sd">        **energy** in units of eV</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">PyReflStructure</span> <span class="o">=</span> <span class="n">Pythonreflectivity</span><span class="o">.</span><span class="n">Generate_structure</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_number_of_layers</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_PyReflMLstring</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_listoflayers</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">layer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;WARNING: Layer &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; is undefined!&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">PyReflStructure</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">setd</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">getD</span><span class="p">(</span><span class="n">fitpararray</span><span class="p">))</span>
                <span class="n">PyReflStructure</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">setsigma</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">getSigma</span><span class="p">(</span><span class="n">fitpararray</span><span class="p">))</span>
                <span class="n">PyReflStructure</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">setmag</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">getMagDir</span><span class="p">(</span><span class="n">fitpararray</span><span class="p">))</span>
                <span class="n">PyReflStructure</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">setchi</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">getChi</span><span class="p">(</span><span class="n">fitpararray</span><span class="p">,</span> <span class="n">energy</span><span class="p">))</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">PyReflStructure</span></div>

    <span class="c1"># properties</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getNumberOfLayers</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;(*int*) Number of different layers. Read-only.&quot;&quot;&quot;</span>
    <span class="n">N_total</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getTotalNumberOfLayers</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;(*int*) Total number of layers counting also multiple use of the same layer according to **multilayer_structure**. Read-only.&quot;&quot;&quot;</span></div>


<span class="c1"># -----------------------------------------------------------------------------------------------------------------------------</span>
<span class="c1"># Layer Classes</span>

<div class="viewcode-block" id="LayerObject"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.LayerObject">[docs]</a><span class="k">class</span> <span class="nc">LayerObject</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Base class for all layer objects as the common interface. Speciallized implementation should inherit from this class.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="LayerObject.__init__"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.LayerObject.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chitensor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">magdir</span><span class="o">=</span><span class="s2">&quot;0&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        d : :class:`Parameters.Parameter`</span>
<span class="sd">            Thickness. Unit is the same as for every other length used throughout the project and is not predefined. E.g. wavelength.</span>
<span class="sd">            *None* or *0* mean infinitively thick.</span>
<span class="sd">        sigma : :class:`Parameters.Parameter`</span>
<span class="sd">            The roughness of the upper surface of the layer. Has dimension of length. Unit: see **d**.</span>
<span class="sd">        chitensor : list of :class:`Parameters.Parameter`</span>
<span class="sd">            Electric susceptibility tensor of the layer.</span>
<span class="sd">            </span>
<span class="sd">            * *[chi]* sets *chi_xx = chi_yy = chi_zz = chi*</span>
<span class="sd">            * *[chi_xx,chi_yy,chi_z]* sets *chi_xx,chi_yy,chi_zz*, others are zero</span>
<span class="sd">            * *[chi_xx,chi_yy,chi_z,chi_g]* sets  *chi_xx,chi_yy,chi_zz* and depending on **magdir** *chi_yz=-chi_zy=chi_g* (if *x*), *chi_xz=-chi_zx=chi_g* (if *y*) or *chi_xz=-chi_zx=chi_g* (if *z*)</span>
<span class="sd">            * *[chi_xx,chi_xy,chi_xz,chi_yx,chi_yy,chi_yz,chi_zx,chi_zy,chi_zz]* sets all the corresdonding elements</span>
<span class="sd">         </span>
<span class="sd">        magdir : str</span>
<span class="sd">            Gives the magnetization direction for MOKE. Possible values are *\&quot;x\&quot;*, *\&quot;y\&quot;*, *\&quot;z\&quot;* and *\&quot;0\&quot;* (no magnetization).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check parameters</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">Parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">d</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">d</span><span class="se">\&#39;</span><span class="s2"> must be an instance of class </span><span class="se">\&#39;</span><span class="s2">Parameters.Parameter</span><span class="se">\&#39;</span><span class="s2"> or of an derived class (e.g. </span><span class="se">\&#39;</span><span class="s2">Parameters.Fitparameter</span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">chitensor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">chitensor</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">Parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s2">&quot;Elements of </span><span class="se">\&#39;</span><span class="s2">chitensor</span><span class="se">\&#39;</span><span class="s2"> must be instances of class </span><span class="se">\&#39;</span><span class="s2">Parameters.Parameter</span><span class="se">\&#39;</span><span class="s2"> or of an derived class (e.g. </span><span class="se">\&#39;</span><span class="s2">Parameters.Fitparameter</span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">Parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">sigma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">sigma</span><span class="se">\&#39;</span><span class="s2"> must be an instance of class </span><span class="se">\&#39;</span><span class="s2">Parameters.Parameter</span><span class="se">\&#39;</span><span class="s2"> or of an derived class (e.g. </span><span class="se">\&#39;</span><span class="s2">Parameters.Fitparameter</span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">magdir</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">magdir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">magdir</span><span class="se">\&#39;</span><span class="s2"> must be of type </span><span class="se">\&#39;</span><span class="s2">str</span><span class="se">\&#39;</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="n">magdir</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span> <span class="ow">or</span> <span class="n">magdir</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span> <span class="ow">or</span> <span class="n">magdir</span> <span class="o">==</span> <span class="s1">&#39;z&#39;</span> <span class="ow">or</span> <span class="n">magdir</span> <span class="o">==</span> <span class="s1">&#39;0&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid input for </span><span class="se">\&#39;</span><span class="s2">magdir</span><span class="se">\&#39;</span><span class="s2">. Valid inputs are </span><span class="se">\&#39;</span><span class="s2">x</span><span class="se">\&#39;</span><span class="s2">,</span><span class="se">\&#39;</span><span class="s2">y</span><span class="se">\&#39;</span><span class="s2">,</span><span class="se">\&#39;</span><span class="s2">z</span><span class="se">\&#39;</span><span class="s2">, and </span><span class="se">\&#39;</span><span class="s2">0</span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># asign members</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_d</span> <span class="o">=</span> <span class="n">d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_chitensor</span> <span class="o">=</span> <span class="n">chitensor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sigma</span> <span class="o">=</span> <span class="n">sigma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_magdir</span> <span class="o">=</span> <span class="n">magdir</span></div>

    <span class="k">def</span> <span class="nf">_setd_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">Parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">d</span><span class="se">\&#39;</span><span class="s2"> must be an instance of class </span><span class="se">\&#39;</span><span class="s2">Parameters.Parameter</span><span class="se">\&#39;</span><span class="s2"> or of an derived class (e.g. </span><span class="se">\&#39;</span><span class="s2">Parameters.Fitparameter</span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_d</span> <span class="o">=</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">_getd_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span>

    <span class="k">def</span> <span class="nf">_getChitensor_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chitensor</span>

    <span class="k">def</span> <span class="nf">_setChitensor_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chitensor</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">chitensor</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">Parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Elements of </span><span class="se">\&#39;</span><span class="s2">chitensor</span><span class="se">\&#39;</span><span class="s2"> must be instances of class </span><span class="se">\&#39;</span><span class="s2">Parameters.Parameter</span><span class="se">\&#39;</span><span class="s2"> or of an derived class (e.g. </span><span class="se">\&#39;</span><span class="s2">Parameters.Fitparameter</span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_chitensor</span> <span class="o">=</span> <span class="n">chitensor</span>

    <span class="k">def</span> <span class="nf">_getMagdir_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_magdir</span>

    <span class="k">def</span> <span class="nf">_setMagdir_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">magdir</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">magdir</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">magdir</span><span class="se">\&#39;</span><span class="s2"> must be of type </span><span class="se">\&#39;</span><span class="s2">str</span><span class="se">\&#39;</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="n">magdir</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span> <span class="ow">or</span> <span class="n">magdir</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span> <span class="ow">or</span> <span class="n">magdir</span> <span class="o">==</span> <span class="s1">&#39;z&#39;</span> <span class="ow">or</span> <span class="n">magdir</span> <span class="o">==</span> <span class="s1">&#39;0&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid input for </span><span class="se">\&#39;</span><span class="s2">magdir</span><span class="se">\&#39;</span><span class="s2">. Valid inputs are </span><span class="se">\&#39;</span><span class="s2">x</span><span class="se">\&#39;</span><span class="s2">,</span><span class="se">\&#39;</span><span class="s2">y</span><span class="se">\&#39;</span><span class="s2">,</span><span class="se">\&#39;</span><span class="s2">z</span><span class="se">\&#39;</span><span class="s2">, and </span><span class="se">\&#39;</span><span class="s2">0</span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_magdir</span> <span class="o">=</span> <span class="n">magdir</span>

    <span class="k">def</span> <span class="nf">_getSigma_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sigma</span>

    <span class="k">def</span> <span class="nf">_setSigma_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">Parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">sigma</span><span class="se">\&#39;</span><span class="s2"> must be an instance of class </span><span class="se">\&#39;</span><span class="s2">Parameters.Parameter</span><span class="se">\&#39;</span><span class="s2"> or of an derived class (e.g. </span><span class="se">\&#39;</span><span class="s2">Parameters.Fitparameter</span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sigma</span> <span class="o">=</span> <span class="n">sigma</span>

    <span class="c1"># public methods</span>
<div class="viewcode-block" id="LayerObject.getChi"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.LayerObject.getChi">[docs]</a>    <span class="k">def</span> <span class="nf">getChi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fitpararray</span><span class="p">,</span> <span class="n">energy</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the electric susceptibility tensor as a list of numbers for a certain **energy** corresponding to the parameter values in **fitpararray** (see :mod:`Parameters`).</span>
<span class="sd">    </span>
<span class="sd">        The returned list can be of length 1,3,4 or 9 (see :meth:`.__init__`).</span>
<span class="sd">        For the base implementation of :class:`.LayerObject` the parameter **energy** is not used. But it may be used by derived classes like :class:`.AtomLayerObject` and therefore needed for compatibility.l</span>
<span class="sd">        **energy** is measured in units of eV.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check tensor bevor giving it to the outside</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_chitensor</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_chitensor</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_chitensor</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_chitensor</span><span class="p">)</span> <span class="o">==</span> <span class="mi">9</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Chitensor must be either of length 1, 3, 4, or 9.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_chitensor</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_magdir</span> <span class="o">==</span> <span class="s2">&quot;0&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You have to define the direction of magnetization </span><span class="se">\&#39;</span><span class="s2">magdir</span><span class="se">\&#39;</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="c1"># return the checked list filled with actual values</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">getValue</span><span class="p">(</span><span class="n">fitpararray</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chitensor</span><span class="p">]</span></div>

<div class="viewcode-block" id="LayerObject.getD"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.LayerObject.getD">[docs]</a>    <span class="k">def</span> <span class="nf">getD</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fitpararray</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the thickness of the layer as a number corresponding to the parameter values in **fitpararray** (see :mod:`Parameters`).</span>
<span class="sd">        </span>
<span class="sd">        The thickness is given in the unit of length you chose. You are free to choose whatever unit you want, but use the same for every length troughout the project.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="o">.</span><span class="n">getValue</span><span class="p">(</span><span class="n">fitpararray</span><span class="p">)</span></div>

<div class="viewcode-block" id="LayerObject.getSigma"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.LayerObject.getSigma">[docs]</a>    <span class="k">def</span> <span class="nf">getSigma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fitpararray</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the roughness of the upper surface of the layer as a number corresponding to the parameter values in **fitpararray** (see :mod:`Parameters`).</span>
<span class="sd">        </span>
<span class="sd">        The thickness is given in the unit of length you chose. You are free to choose whatever unit you want, but use the same for every length troughout the project.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sigma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sigma</span><span class="o">.</span><span class="n">getValue</span><span class="p">(</span><span class="n">fitpararray</span><span class="p">)</span></div>

<div class="viewcode-block" id="LayerObject.getMagDir"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.LayerObject.getMagDir">[docs]</a>    <span class="k">def</span> <span class="nf">getMagDir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fitpararray</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return magnetization direction</span>
<span class="sd">        </span>
<span class="sd">        **fitpararray** is not used and just there to give a common interface. Maybe a derived classes will have a benefit from it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_magdir</span></div>

    <span class="c1"># exposed properties (feel like instance variables but are protected via getter and setter methods)</span>
    <span class="c1"># BEWARE: theese properties contain the &quot;Parameter&quot; objects. E.g. to get a certain value for the thicknes do this: &quot;layer.d.getValue(parameterarray)&quot;</span>
    <span class="n">d</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getd_</span><span class="p">,</span> <span class="n">_setd_</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;Thickness of the layer. Unit is the same as for every other length used throughout the project and is not predefined. E.g. wavelength.&quot;&quot;&quot;</span>
    <span class="n">chitensor</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getChitensor_</span><span class="p">,</span> <span class="n">_setChitensor_</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;Electric susceptibility tensor of the layer. See :meth:`.__init__` for details.&quot;&quot;&quot;</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getSigma_</span><span class="p">,</span> <span class="n">_setSigma_</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;Roughness of the upper surface of the layer. Unit is the same as for every other length used throughout the project and is not predefined. E.g. wavelength.&quot;&quot;&quot;</span>
    <span class="n">magdir</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getMagdir_</span><span class="p">,</span> <span class="n">_setMagdir_</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;Magnetization direction for MOKE. Possible values are *\&quot;x\&quot;*, *\&quot;y\&quot;*, *\&quot;z\&quot;* and *\&quot;0\&quot;* (no magnetization).&quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="MagneticLayerObject"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.MagneticLayerObject">[docs]</a><span class="k">class</span> <span class="nc">MagneticLayerObject</span><span class="p">(</span><span class="n">LayerObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Specialized layer to deal with a magnetic layer without energy-dependence. </span>
<span class="sd">    </span>
<span class="sd">    The electrical suszeptibility tensor (Chi) consists of an energy-independent diagonal part and of off-diagonal elements which are given as a magnetization and their direction (angles).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
<div class="viewcode-block" id="MagneticLayerObject.__init__"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.MagneticLayerObject.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chi_diag</span><span class="p">,</span> <span class="n">m_prime</span><span class="p">,</span> <span class="n">m_primeprime</span><span class="p">,</span> <span class="n">theta_M</span><span class="p">,</span> <span class="n">phi_M</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>       
        <span class="sd">&quot;&quot;&quot;Initializes the MagneticLayerObject with both diagonal-elements and off-diagonal elements given as magnetic terms **m_prime** and **m_primeprime** and the angles **theta_M** and **phi_M** which describe the direction of the magnetization.</span>
<span class="sd">        </span>
<span class="sd">        See *Macke and Goering 2014, J.Phys.: Condens. Matter 26, 363201.* Eq. 11-14 for details.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        chi_diag : list of :class:`Parameters.Parameter`</span>
<span class="sd">            Diagonal elements of electric susceptibility tensor of the layer.</span>
<span class="sd">            </span>
<span class="sd">            * *[chi]* sets *chi_xx = chi_yy = chi_zz = chi*</span>
<span class="sd">            * *[chi_xx,chi_yy,chi_z]* sets *chi_xx,chi_yy,chi_zz*</span>
<span class="sd">            </span>
<span class="sd">        m_prime : :class:`Parameters.Parameter`</span>
<span class="sd">        m_primeprime : :class:`Parameters.Parameter`</span>
<span class="sd">            Real and imaginary parts of the magnetic term. </span>
<span class="sd">        theta_M : :class:`Parameters.Parameter`</span>
<span class="sd">        phi_M : :class:`Parameters.Parameter`</span>
<span class="sd">            Angles which describe the direction of the magnetization measured in degrees. See also :doc:`/definitions/coordinate_systems`.</span>
<span class="sd">        d : :class:`Parameters.Parameter`</span>
<span class="sd">            Thickness. Unit is the same as for every other length used throughout the project and is not predefined. E.g. wavelength.</span>
<span class="sd">            *None* or *0* mean infinitively thick.</span>
<span class="sd">        sigma : :class:`Parameters.Parameter`</span>
<span class="sd">            The roughness of the upper surface of the layer. Has dimension of length. Unit: see **d**.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check parameters</span>
        <span class="k">if</span> <span class="n">chi_diag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chi_diag</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">chi_diag</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">chi_diag</span><span class="se">\&#39;</span><span class="s2"> must be either of length 1 or length 3&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">chi_diag</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">Parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s2">&quot;Elements of </span><span class="se">\&#39;</span><span class="s2">chi_diag </span><span class="se">\&#39;</span><span class="s2"> must be instances of class </span><span class="se">\&#39;</span><span class="s2">Parameters.Parameter</span><span class="se">\&#39;</span><span class="s2"> or of an derived class (e.g. </span><span class="se">\&#39;</span><span class="s2">Parameters.Fitparameter</span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m_prime</span><span class="p">,</span> <span class="n">Parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">m_prime</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">m_prime</span><span class="se">\&#39;</span><span class="s2"> must be an instance of class </span><span class="se">\&#39;</span><span class="s2">Parameters.Parameter</span><span class="se">\&#39;</span><span class="s2"> or of an derived class (e.g. </span><span class="se">\&#39;</span><span class="s2">Parameters.Fitparameter</span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m_primeprime</span><span class="p">,</span> <span class="n">Parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">m_primeprime</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">m_primeprime</span><span class="se">\&#39;</span><span class="s2"> must be an instance of class </span><span class="se">\&#39;</span><span class="s2">Parameters.Parameter</span><span class="se">\&#39;</span><span class="s2"> or of an derived class (e.g. </span><span class="se">\&#39;</span><span class="s2">Parameters.Fitparameter</span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">theta_M</span><span class="p">,</span> <span class="n">Parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">theta_M</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">theta_M</span><span class="se">\&#39;</span><span class="s2"> must be an instance of class </span><span class="se">\&#39;</span><span class="s2">Parameters.Parameter</span><span class="se">\&#39;</span><span class="s2"> or of an derived class (e.g. </span><span class="se">\&#39;</span><span class="s2">Parameters.Fitparameter</span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">phi_M</span><span class="p">,</span> <span class="n">Parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">phi_M</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">phi_M</span><span class="se">\&#39;</span><span class="s2"> must be an instance of class </span><span class="se">\&#39;</span><span class="s2">Parameters.Parameter</span><span class="se">\&#39;</span><span class="s2"> or of an derived class (e.g. </span><span class="se">\&#39;</span><span class="s2">Parameters.Fitparameter</span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="p">)</span>
 

        <span class="c1">#create chitensor with off-diagonal elements as derived parameters of m_prime, m_primeprime, theta_M and phi_M</span>
        <span class="c1">#diagonal elements first</span>
        <span class="n">chitensor</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">Parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">Parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                              <span class="n">Parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">Parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">Parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                              <span class="n">Parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">Parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">Parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="mi">0</span><span class="p">)])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chi_diag</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">chitensor</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">chitensor</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">=</span><span class="n">chitensor</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="o">=</span><span class="n">chi_diag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">chi_diag</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
            <span class="n">chitensor</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">chi_diag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">chitensor</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">=</span><span class="n">chi_diag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">chitensor</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="o">=</span><span class="n">chi_diag</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        
            
        <span class="c1">#now off-diagonal elements    </span>
        <span class="n">theta_M</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">180.0</span> <span class="o">*</span> <span class="n">theta_M</span>  <span class="c1">#in Bogenmass umwandeln (es entstehen abgeleitete Parameter)</span>
        <span class="n">phi_M</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">180.0</span> <span class="o">*</span> <span class="n">phi_M</span>
        <span class="n">off_chitensor</span><span class="o">=</span>  <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> 
                           <span class="n">Parameters</span><span class="o">.</span><span class="n">DerivedParameter</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">cos</span> <span class="p">,</span> <span class="n">theta_M</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">m_prime</span> <span class="o">-</span> <span class="n">m_primeprime</span><span class="p">),</span>
                           <span class="o">-</span><span class="n">Parameters</span><span class="o">.</span><span class="n">DerivedParameter</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span><span class="n">theta_M</span><span class="p">)</span> <span class="o">*</span> <span class="n">Parameters</span><span class="o">.</span><span class="n">DerivedParameter</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span><span class="n">phi_M</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">m_prime</span> <span class="o">-</span> <span class="n">m_primeprime</span><span class="p">),</span>
                           <span class="o">-</span><span class="n">Parameters</span><span class="o">.</span><span class="n">DerivedParameter</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">,</span><span class="n">theta_M</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">m_prime</span> <span class="o">-</span> <span class="n">m_primeprime</span><span class="p">),</span>
                           <span class="n">Parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                           <span class="n">Parameters</span><span class="o">.</span><span class="n">DerivedParameter</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span><span class="n">theta_M</span><span class="p">)</span> <span class="o">*</span> <span class="n">Parameters</span><span class="o">.</span><span class="n">DerivedParameter</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">,</span><span class="n">phi_M</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">m_prime</span> <span class="o">-</span> <span class="n">m_primeprime</span><span class="p">),</span>
                           <span class="n">Parameters</span><span class="o">.</span><span class="n">DerivedParameter</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span><span class="n">theta_M</span><span class="p">)</span> <span class="o">*</span> <span class="n">Parameters</span><span class="o">.</span><span class="n">DerivedParameter</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span><span class="n">phi_M</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">m_prime</span> <span class="o">-</span> <span class="n">m_primeprime</span><span class="p">),</span>
                           <span class="o">-</span><span class="n">Parameters</span><span class="o">.</span><span class="n">DerivedParameter</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span><span class="n">theta_M</span><span class="p">)</span> <span class="o">*</span> <span class="n">Parameters</span><span class="o">.</span><span class="n">DerivedParameter</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">,</span><span class="n">phi_M</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">m_prime</span> <span class="o">-</span> <span class="n">m_primeprime</span><span class="p">),</span>
                           <span class="n">Parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="mi">0</span><span class="p">)])</span>
        
        <span class="n">chitensor</span><span class="o">=</span><span class="n">chitensor</span> <span class="o">+</span> <span class="n">off_chitensor</span>
                    
        <span class="c1"># call constructor of the base class</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">chitensor</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ModelChiLayerObject"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.ModelChiLayerObject">[docs]</a><span class="k">class</span> <span class="nc">ModelChiLayerObject</span><span class="p">(</span><span class="n">LayerObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Speciallized layer to deal with an electrical suszeptibility tensor (Chi) which is modelled as function of energy.</span>
<span class="sd">    </span>
<span class="sd">    BEWARE: The inherited property :attr:`.chitensor` is now a function.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ModelChiLayerObject.__init__"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.ModelChiLayerObject.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chitensorfunction</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">magdir</span><span class="o">=</span><span class="s2">&quot;0&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        d : :class:`Parameters.Parameter`</span>
<span class="sd">            Thickness. Unit is the same as for every other length used throughout the project and is not predefined. E.g. wavelength.</span>
<span class="sd">            *None* or *0* mean infinitively thick.</span>
<span class="sd">        sigma : :class:`Parameters.Parameter`</span>
<span class="sd">            The roughness of the upper surface of the layer. Has dimension of length. Unit: see **d**.</span>
<span class="sd">        chitensorfunction : :class:`Parameters.ParametrizedFunction`</span>
<span class="sd">            Energy-dependent electric susceptibility tensor of the layer.</span>
<span class="sd">            A parametrized function of energy (see :class:`Parameters.ParametrizedFunction`) which reurns a list of either 1,3,4 or 9 real or complex numbers.</span>
<span class="sd">            See also documentation of :mod:`Pythonreflectivity`.</span>
<span class="sd">            </span>
<span class="sd">            * *[chi]* sets *chi_xx = chi_yy = chi_zz = chi*</span>
<span class="sd">            * *[chi_xx,chi_yy,chi_z]* sets *chi_xx,chi_yy,chi_zz*, others are zero</span>
<span class="sd">            * *[chi_xx,chi_yy,chi_z,chi_g]* sets  *chi_xx,chi_yy,chi_zz* and depending on **magdir**</span>
<span class="sd">              *chi_yz=-chi_zy=chi_g* (if *x*), *chi_xz=-chi_zx=chi_g* (if *y*) or *chi_xz=-chi_zx=chi_g* (if *z*)</span>
<span class="sd">            * *[chi_xx,chi_xy,chi_xz,chi_yx,chi_yy,chi_yz,chi_zx,chi_zy,chi_zz]* sets all the corresdonding elements</span>
<span class="sd">            </span>
<span class="sd">        magdir : str</span>
<span class="sd">            Gives the magnetization direction for MOKE. Possible values are *\&quot;x\&quot;*, *\&quot;y\&quot;*, *\&quot;z\&quot;* and *\&quot;0\&quot;* (no magnetization).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check parameters</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">chitensorfunction</span><span class="p">,</span> <span class="n">Parameters</span><span class="o">.</span><span class="n">ParametrizedFunction</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">chitensorfunction</span><span class="se">\&#39;</span><span class="s2"> has to be an instance of \`Parameters.ParametrizedFunction\`.&quot;</span><span class="p">)</span>
        <span class="c1"># asign members</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_chitensorfunction</span> <span class="o">=</span> <span class="n">chitensorfunction</span>
        <span class="c1"># call constructor of the base class</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">magdir</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_getChitensor_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chitensorfunction</span>

    <span class="k">def</span> <span class="nf">_setChitensor_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chitensorfunction</span><span class="p">):</span>
        <span class="c1"># check parameters</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">chitensorfunction</span><span class="p">,</span> <span class="n">Parameters</span><span class="o">.</span><span class="n">ParametrizedFunction</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">chitensorfunction</span><span class="se">\&#39;</span><span class="s2"> has to be an instance of \`Parameters.ParametrizedFunction\`.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_chitensorfunction</span> <span class="o">=</span> <span class="n">chitensorfunction</span>

    <span class="c1"># public methods</span>
<div class="viewcode-block" id="ModelChiLayerObject.getChi"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.ModelChiLayerObject.getChi">[docs]</a>    <span class="k">def</span> <span class="nf">getChi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fitpararray</span><span class="p">,</span> <span class="n">energy</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the electric susceptibility tensor as a list of numbers for a certain **energy** corresponding to the parameter values in **fitpararray** (see :mod:`Parameters`).</span>
<span class="sd">    </span>
<span class="sd">        **energy** is measured in units of eV.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get chitensor from chitensorfunction</span>
        <span class="n">chitensor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chitensorfunction</span><span class="o">.</span><span class="n">getValue</span><span class="p">(</span><span class="n">energy</span><span class="p">,</span> <span class="n">fitpararray</span><span class="p">)</span>
        <span class="c1"># check tensor bevor giving it to the outside</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chitensor</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">chitensor</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">chitensor</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">chitensor</span><span class="p">)</span> <span class="o">==</span> <span class="mi">9</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">chitensorfunction</span><span class="se">\&#39;</span><span class="s2"> must return an array of length 1, 3, 4, or 9.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chitensor</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_magdir</span> <span class="o">==</span> <span class="s2">&quot;0&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;You have to define the direction of magnetization </span><span class="se">\&#39;</span><span class="s2">magdir</span><span class="se">\&#39;</span><span class="s2"> if the \`chitensorfunction\` delivers a 4-element array.&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">chitensor</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Elements of the array returnd by </span><span class="se">\&#39;</span><span class="s2">chitensorfunction</span><span class="se">\&#39;</span><span class="s2"> have to be numbers.&quot;</span><span class="p">)</span>
        <span class="c1"># return the checked list</span>
        <span class="k">return</span> <span class="n">chitensor</span></div>
    
    <span class="c1"># exposed properties (feel like instance variables but are protected via getter and setter methods)</span>
    <span class="n">chitensor</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getChitensor_</span><span class="p">,</span> <span class="n">_setChitensor_</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;Electric susceptibility tensor of the layer. Is an instance of :class:`Parameters.ParametrizedFunction`. See :meth:`.__init__` for details.&quot;&quot;&quot;</span></div>
    
<div class="viewcode-block" id="AtomLayerObject"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.AtomLayerObject">[docs]</a><span class="k">class</span> <span class="nc">AtomLayerObject</span><span class="p">(</span><span class="n">LayerObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Speciallized layer class to deal with compositions of atoms and their energy dependent formfactors (which can be obtained from absorption spectra).</span>
<span class="sd">    </span>
<span class="sd">    Especially usefull to deal with atomic layers, but can also be used for bulk.</span>
<span class="sd">    The atoms and their formfactors have to be registered a the class (with registerAtom) before they can be used to instantiate a new AtomLayerObject.</span>
<span class="sd">    The atom density can be plotted with :func:`.plotAtomDensity`.</span>
<span class="sd">    Density is measured in mol/cm$^3$ (as long as no **densityunitfactor** is applied)</span>
<span class="sd">    </span>
<span class="sd">    Used formfactors can also be &quot;magnetic formfactors&quot; which only deal with diagonal elements of a formfactor tensor and simulate magnetic moments. See :class:`MagneticFormfactor` and derived classes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="AtomLayerObject.__init__"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.AtomLayerObject.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">densitydict</span><span class="o">=</span><span class="p">{},</span> <span class="n">d</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">magdir</span><span class="o">=</span><span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="n">densityunitfactor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        densitydict :</span>
<span class="sd">            a dictionary which contains atom names (strings, must agree with before registered atoms) and densities (must be instances of :class:`Parameters.Parameter` or of a derived class).</span>
<span class="sd">        d : :class:`Parameters.Parameter`</span>
<span class="sd">            Thickness. Unit is the same as for every other length used throughout the project and is not predefined. E.g. wavelength.</span>
<span class="sd">            *None* or *0* mean infinitively thick.</span>
<span class="sd">        sigma : :class:`Parameters.Parameter`</span>
<span class="sd">            The roughness of the upper surface of the layer. Has dimension of length. Unit: see **d**.</span>
<span class="sd">        densityunitfactor : float</span>
<span class="sd">            If the densities in densitydict are measured in another unit than mol/cm^3, state this value which translates your generic density to the one used internally.</span>
<span class="sd">            I.e.::</span>
<span class="sd">            </span>
<span class="sd">                rho_in_mol_per_cubiccm = densityunitfactor * rho_in_whateverunityouwant</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">densitydict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">densitydict</span><span class="se">\&#39;</span><span class="s2"> has to be a dictionary.&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">atomname</span> <span class="ow">in</span> <span class="n">densitydict</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atomname</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The keys of the </span><span class="se">\&#39;</span><span class="s2">densitydict</span><span class="se">\&#39;</span><span class="s2"> dictionary have to be stings.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">densitydict</span><span class="p">[</span><span class="n">atomname</span><span class="p">],</span> <span class="n">Parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;The values of the </span><span class="se">\&#39;</span><span class="s2">densitydict</span><span class="se">\&#39;</span><span class="s2"> dictionary have to be instances of the </span><span class="se">\&#39;</span><span class="s2">Parameter</span><span class="se">\&#39;</span><span class="s2"> class or of derived classes.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">atomname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_atomdict</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">registerAtom</span><span class="p">(</span><span class="n">atomname</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">LookupError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">Exeption</span><span class="p">(</span>
                        <span class="s2">&quot;Element </span><span class="se">\&#39;</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">atomname</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2"> cannot be found in the Chantler tables and has not been registered yet.&quot;</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">raise</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">densityunitfactor</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Real</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">densityunitfactor</span><span class="se">\&#39;</span><span class="s2"> has to be a real number.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_densityunitfactor</span> <span class="o">=</span> <span class="n">densityunitfactor</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_densitydict</span> <span class="o">=</span> <span class="n">densitydict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># The usage of &quot;copy&quot; creates a copy of the dictionary. By this, we ensure, that changes of the original dictionary outside the object will not affect the AtomLayerObject</span>

        <span class="c1"># call constructor of the base class</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span>
                                              <span class="n">magdir</span><span class="o">=</span><span class="s2">&quot;0&quot;</span><span class="p">)</span>  <span class="c1"># magdir is not used; the magnetization and their direction should be handled within the corresponding Formfactor classes</span></div>

<div class="viewcode-block" id="AtomLayerObject.getDensitydict"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.AtomLayerObject.getDensitydict">[docs]</a>    <span class="k">def</span> <span class="nf">getDensitydict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fitpararray</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the density dictionary either with evaluated paramters (needs **fitpararray**) or with the raw :class:`Parameters.Parameter` objects (use **fitparraray** = *None*).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fitpararray</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_densitydict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fitpararray</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">fitparray</span><span class="se">\&#39;</span><span class="s2"> has to be a list, tuple or numpy array.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_densitydict</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span> <span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">getValue</span><span class="p">(</span><span class="n">fitpararray</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span>
                                                       <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_densitydict</span><span class="o">.</span><span class="n">values</span><span class="p">())])))</span>  <span class="c1"># pack new dictionary from atomnames and &quot;unpacked&quot; parameters (actual values instead of abstract parameter)</span></div>

<div class="viewcode-block" id="AtomLayerObject.getChi"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.AtomLayerObject.getChi">[docs]</a>    <span class="k">def</span> <span class="nf">getChi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fitpararray</span><span class="p">,</span> <span class="n">energy</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the electric susceptibility tensor as a list of numbers for a certain **energy** corresponding to the parameter values in **fitpararray** (see :mod:`Parameters`).</span>
<span class="sd">    </span>
<span class="sd">        **energy** is measured in units of eV.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># gehe alle Items in self._densitydict durch, item[1].getValue(fitpararray) liefert Dichte der Atomsorte, (type(self)._atomdict[item[0]]).getFF(fitpararray) liefert Formfaktor der Atomsorte, beides wird multipliziert und alles zusammen aufsummiert</span>
        <span class="c1"># ffsum = sum_i( number_density_atom_i * ff_tensor_atom_i)</span>
        <span class="n">ffsum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">getValue</span><span class="p">(</span><span class="n">fitpararray</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_densityunitfactor</span> <span class="o">*</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_atomdict</span><span class="p">[</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span><span class="o">.</span><span class="n">getFF</span><span class="p">(</span><span class="n">energy</span><span class="p">,</span> <span class="n">fitpararray</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_densitydict</span><span class="o">.</span><span class="n">items</span><span class="p">())])</span>
        

        <span class="c1"># Return the susceptibility tensor chi</span>
        <span class="c1"># As chi is very small, the linear approximation can be used.</span>
        <span class="c1"># If there is no densityunitfactor defined, the densities are assumed to be in units of mol/cm^3.</span>
        <span class="c1"># Energy is assumed to be in units of eV.</span>
        <span class="c1"># The susceptibility is given  as chi = 4*pi/k_0^2*r_e*ffsum  (see Macke and Goering 2014, J.Pyhs.:Condens.Matter 26 363201, Eq.15)</span>
        <span class="c1"># With k_0=E/(h_bar*c), energy in eV, h_bar in eV*s, c in m r_e in m, densities in mol/cm^2 (and therefore also ffsum)</span>
        <span class="c1"># Th susceptibility can be calculated as: chi= 4* pi * h_bar^2 [eV*s]^2 * c^2 [m/s]^2 * r_e [m] * N_A [1/mol] * (100cm)^3/m^3 * ffsum (mol/cm^3) / E^2 (eV)^2</span>
        <span class="c1"># N_A: Arvogardros number, r_e: thomson scattering length/classical electron radius</span>
        <span class="c1"># With values:</span>
        <span class="c1"># h_bar = 6.582119514e-16</span>
        <span class="c1"># c = 299792458</span>
        <span class="c1"># r_e = 2.8179403227e-15</span>
        <span class="c1"># N_A= 6.02214086e+23</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">ffsum</span> <span class="o">*</span> <span class="mf">830.3582374351398</span> <span class="o">/</span> <span class="n">energy</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>      </div>


        <span class="c1"># classvariables</span>

    <span class="n">_atomdict</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># classmethods                                               #are not related to an instance of a class and are here used to deal with the collection of all registered atoms</span>
<div class="viewcode-block" id="AtomLayerObject.registerAtom"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.AtomLayerObject.registerAtom">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">registerAtom</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">formfactor</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Register an atom called **name** for later use to instantiate an AtomLayerObject.</span>
<span class="sd">        </span>
<span class="sd">        **formfactor** as to be an instance of :class:`.Formfactor` or of a derived class.</span>
<span class="sd">        If no formfactor object is given, an instance of :class:`.FFfromChantler` will be created with **name** as element name. </span>
<span class="sd">        This can be used for an easy registration of atoms with just their tabulated formfactors from the Chantler tables.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The atom </span><span class="se">\&#39;</span><span class="s2">name</span><span class="se">\&#39;</span><span class="s2"> has to be a string.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">formfactor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">formfactor</span><span class="p">,</span> <span class="n">Formfactor</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">formfactor</span><span class="se">\&#39;</span><span class="s2"> has to be an instance of </span><span class="se">\&#39;</span><span class="s2">Formfactor</span><span class="se">\&#39;</span><span class="s2"> or of a derived class.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">cls</span><span class="o">.</span><span class="n">_atomdict</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;WARNING: Atom </span><span class="se">\&#39;</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2"> is replaced.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">formfactor</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">formfactor</span> <span class="o">=</span> <span class="n">FFfromChantler</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">_atomdict</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">name</span><span class="p">:</span> <span class="n">formfactor</span><span class="p">})</span></div>

<div class="viewcode-block" id="AtomLayerObject.getAtom"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.AtomLayerObject.getAtom">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">getAtom</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the :class:`.Formfactor` object registered for atom **name**.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The atom </span><span class="se">\&#39;</span><span class="s2">name</span><span class="se">\&#39;</span><span class="s2"> has to be a string.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cls</span><span class="o">.</span><span class="n">_atomdict</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The atom </span><span class="se">\&#39;</span><span class="s2">name</span><span class="se">\&#39;</span><span class="s2"> is not registered.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">_atomdict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span></div>

<div class="viewcode-block" id="AtomLayerObject.getAtomNames"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.AtomLayerObject.getAtomNames">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">getAtomNames</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of names of registered atoms.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">_atomdict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div></div>


<span class="c1"># -----------------------------------------------------------------------------------------------------------------------------</span>
<span class="c1"># Formfactor classes</span>

<div class="viewcode-block" id="Formfactor"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.Formfactor">[docs]</a><span class="k">class</span> <span class="nc">Formfactor</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class to deal with energy-dependent atomic form-factors.</span>
<span class="sd">    </span>
<span class="sd">    This base class is an abstract class an cannot be used directly.</span>
<span class="sd">    The user should derive from this class if he wants to build his own models.</span>
<span class="sd">    </span>
<span class="sd">    See :doc:`/definitions/formfactors` for sign conventions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Formfactor.__init__"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.Formfactor.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="Formfactor.getFF"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.Formfactor.getFF">[docs]</a>    <span class="k">def</span> <span class="nf">getFF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">energy</span><span class="p">,</span> <span class="n">fitpararray</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the formfactor for **energy** corresponding to **fitpararray** (if it depends on it) as 9-element Numpy array of complex numbers.</span>
<span class="sd">        </span>
<span class="sd">        **energy** is measured in units of eV.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

    <span class="k">def</span> <span class="nf">_getMinE</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">_getMaxE</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

<div class="viewcode-block" id="Formfactor.plotFF"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.Formfactor.plotFF">[docs]</a>    <span class="k">def</span> <span class="nf">plotFF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fitpararray</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">energies</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the energy-dependent formfactor with the energies (in eV) listed in the list/array **energies**. If this array is not given the plot covers the hole existing energy-range.</span>
<span class="sd">        The **fitpararray** has only to be given in cases where the formfactor depends on a fitparamter, e.g. for class:`FFfromScaledAbsorption`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">energies</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">energies</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxE</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span>
        <span class="n">ff</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">energies</span><span class="p">:</span>
            <span class="n">ff</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getFF</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">fitpararray</span><span class="p">))</span>
        <span class="n">ff</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ff</span><span class="p">)</span>
        <span class="n">ff</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">ff</span><span class="p">)</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">331</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">):</span>
            <span class="n">axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">330</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sharey</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;energy (eV)&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">locator_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">nbins</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
            <span class="n">l1</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">energies</span><span class="p">,</span> <span class="n">ff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;real&quot;</span><span class="p">)</span>
            <span class="n">l2</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">energies</span><span class="p">,</span> <span class="n">ff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;imaginary&quot;</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>  <span class="c1"># only place a legend in the lower left element. Not nice, but works.</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>

    <span class="c1"># properties</span>
    <span class="n">maxE</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getMaxE</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;Upper limit of stored energy range. Read-only.&quot;&quot;&quot;</span>
    <span class="n">minE</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getMinE</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;Lower limit of stored energy range. Read-only.&quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="FFfromFile"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.FFfromFile">[docs]</a><span class="k">class</span> <span class="nc">FFfromFile</span><span class="p">(</span><span class="n">Formfactor</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class to deal with energy-dependent atomic form-factors (entire tensor) which are tabulated in files. See :doc:`/definitions/formfactors` for sign conventions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="FFfromFile.__init__"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.FFfromFile.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">linereaderfunction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">energyshift</span><span class="o">=</span><span class="n">Parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="mi">0</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;Initializes the FFfromFile object with an energy-dependent formfactor given as file.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str</span>
<span class="sd">            Path to the text file which contains the formfactor.       </span>
<span class="sd">        linereaderfunction : callable</span>
<span class="sd">            This function is used to convert one line from the text file to data.</span>
<span class="sd">            It should be a function which takes a string and returns a tuple or list of 10 values: ``(energy,f_xx,f_xy,f_xz,f_yx,f_yy,f_yz,f_zx,f_zy,f_zz)``,</span>
<span class="sd">            where `energy` is measured in units of `eV` and formfactors are complex values in units of `e/atom` (dimensionless).</span>
<span class="sd">            It can also return `None` if it detects a comment line.</span>
<span class="sd">            You can use :meth:`FFfromFile.createLinereader` to get a standard function, which just reads this array as whitespace seperated from the line.</span>
<span class="sd">        energyshift : :class:`Parameters.Parameter`</span>
<span class="sd">            Species a fittable energyshift between the energy-dependent formfactor from **filename** and the `real` one in the reflectivity measurement.</span>
<span class="sd">            So the formfactor delivered from :meth:`FFfromFile.getFF` will not be `formfactor_from_file(E)` but `formfactor_from_file(E-energyshift)`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">filename</span><span class="se">\&#39;</span><span class="s2"> needs to be a string.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">linereaderfunction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">linereaderfunction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">createLinereader</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">linereaderfunction</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">linereaderfunction</span><span class="se">\&#39;</span><span class="s2"> needs to be a callable object.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;File </span><span class="se">\&#39;</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2"> does not exist.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">energyshift</span><span class="p">,</span> <span class="n">Parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">energyshift</span><span class="se">\&#39;</span><span class="s2"> has to be of type Parameters.Parameter.&quot;</span><span class="p">)</span>

        <span class="n">energies</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">formfactors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">linereaderoutput</span> <span class="o">=</span> <span class="n">linereaderfunction</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">linereaderoutput</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">linereaderoutput</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Linereader function has to return a list/tuple.&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">linereaderoutput</span><span class="p">)</span> <span class="o">==</span> <span class="mi">10</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Linereader function hast to return a list/tuple with 10 elements.&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">linereaderoutput</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Linereader function hast to return a list/tuple of numbers.&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">linereaderoutput</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">complex</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Linereader function hast to return a real value for the energy.&quot;</span><span class="p">)</span>
                <span class="n">energies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linereaderoutput</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># store energies in one list</span>
                <span class="n">formfactors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linereaderoutput</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="c1"># store corresponding formfactors in another list</span>


        <span class="n">formfactors</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">formfactors</span><span class="p">)</span>  <span class="c1"># convert list formfactors to a numpy array for convinience</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_minE</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">energies</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_maxE</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">energies</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_energyshift</span> <span class="o">=</span> <span class="n">energyshift</span>  <span class="c1"># Attention: this is supposed to be an instance of &quot;Parameters.Parameter&quot;. So a value can be obtained with self._energyshift.getValue(fitparraray)</span>
        <span class="c1"># Create an interpolation function based on the given energie-formfactor-points. The formfactors are thererfore transformed to arrays of length 18 but with real values.</span>
        <span class="c1"># After that the array of N arrays of 18 element is transformed to an array of 18 arrays of N elements as needed by the interp1d function.</span>
        <span class="c1"># Therefore, this function will return an array of length 18 wich has to be transformed back to 9 complex valued elements.</span>
        <span class="c1"># Energies and formfactors don&#39;t have to be stored explicitly , because they are contained in the &quot;self._interpolator&quot; function.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_interpolator</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">energies</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">formfactors</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">formfactors</span><span class="o">.</span><span class="n">imag</span><span class="p">),</span> <span class="mi">1</span><span class="p">)))</span></div>

    <span class="k">def</span> <span class="nf">_getMinE</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_minE</span>

    <span class="k">def</span> <span class="nf">_getMaxE</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxE</span>

    <span class="c1"># public methods</span>

<div class="viewcode-block" id="FFfromFile.createLinereader"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.FFfromFile.createLinereader">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">createLinereader</span><span class="p">(</span><span class="n">complex_numbers</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the standard linereader function for usage with :meth:`FFfromFile.__init__`.</span>
<span class="sd">        </span>
<span class="sd">        This standard linereader function reads energy and complex elements of the formfactor tensor as a whitespace-seperated list (i.e. 10 numbers) and interpretes \&quot;#\&quot; as comment sign.</span>
<span class="sd">        If **complex_numbers** = *False* then the reader reads real and imaginary part of every element seperately, i.e. every line has to consist of 19 numbers seperated by whitespaces::</span>
<span class="sd">            </span>
<span class="sd">            energy f_xx_real ff_xx_im ... f_zy_real f_zy_im f_zz_real f_zz_im</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">commentsymbol</span> <span class="o">=</span> <span class="s1">&#39;#&#39;</span>
        <span class="k">if</span> <span class="n">complex_numbers</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">linereader</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">line</span><span class="se">\&#39;</span><span class="s2"> needs to be a string.&quot;</span><span class="p">)</span>
                <span class="n">line</span> <span class="o">=</span> <span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">commentsymbol</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># ignore everything behind the commentsymbol  #</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="o">.</span><span class="n">isspace</span><span class="p">()</span> <span class="ow">and</span> <span class="n">line</span><span class="p">:</span>  <span class="c1"># ignore empty lines</span>
                    <span class="n">linearray</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">linearray</span><span class="p">)</span> <span class="o">==</span> <span class="mi">10</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Formfactor file has wrong format.&quot;</span><span class="p">)</span>
                    <span class="n">linearray</span> <span class="o">=</span> <span class="p">[</span><span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">linearray</span><span class="p">]</span>
                    <span class="k">return</span> <span class="n">linearray</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">complex_numbers</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">linereader</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">line</span><span class="se">\&#39;</span><span class="s2"> needs to be a string.&quot;</span><span class="p">)</span>
                <span class="n">line</span> <span class="o">=</span> <span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">commentsymbol</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># ignore everything behind the commentsymbol  #</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="o">.</span><span class="n">isspace</span><span class="p">()</span> <span class="ow">and</span> <span class="n">line</span><span class="p">:</span>  <span class="c1"># ignore empty lines</span>
                    <span class="n">linearray</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">linearray</span><span class="p">)</span> <span class="o">==</span> <span class="mi">19</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Formfactor file has wrong format.&quot;</span><span class="p">)</span>
                    <span class="n">linearray</span> <span class="o">=</span> <span class="p">[</span><span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">linearray</span><span class="p">]</span>
                    <span class="k">return</span> <span class="p">[</span><span class="n">linearray</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">linearray</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">linearray</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">linearray</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">linearray</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
                            <span class="n">linearray</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">linearray</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">linearray</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">linearray</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span>
                            <span class="n">linearray</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">linearray</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span> <span class="n">linearray</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">linearray</span><span class="p">[</span><span class="mi">12</span><span class="p">],</span>
                            <span class="n">linearray</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">linearray</span><span class="p">[</span><span class="mi">14</span><span class="p">],</span> <span class="n">linearray</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">linearray</span><span class="p">[</span><span class="mi">16</span><span class="p">],</span>
                            <span class="n">linearray</span><span class="p">[</span><span class="mi">17</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">linearray</span><span class="p">[</span><span class="mi">18</span><span class="p">]]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">complex_numbers</span><span class="se">\&#39;</span><span class="s2"> has to be boolean.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">linereader</span>  <span class="c1"># here the FUNKTION linereader is returned</span></div>

<div class="viewcode-block" id="FFfromFile.getFF"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.FFfromFile.getFF">[docs]</a>    <span class="k">def</span> <span class="nf">getFF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">energy</span><span class="p">,</span> <span class="n">fitpararray</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the (energy-shifted )formfactor for **energy** as an interpolation between the stored values from file as 9-element 1-D numpy array of complex numbers.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        energy : float</span>
<span class="sd">            Measured in units of eV.</span>
<span class="sd">        fitpararray :</span>
<span class="sd">            Is actually only needed when an energyshift has been defined.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">energyshift</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_energyshift</span><span class="o">.</span><span class="n">getValue</span><span class="p">(</span><span class="n">fitpararray</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">energy</span> <span class="o">+</span> <span class="n">energyshift</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minE</span> <span class="ow">or</span> <span class="n">energy</span> <span class="o">-</span> <span class="n">energyshift</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxE</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">energy - energyshift = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; + &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">energyshift</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span>
                <span class="n">energy</span> <span class="o">-</span> <span class="n">energyshift</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2"> is out of range (&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minE</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;,&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxE</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;).&quot;</span><span class="p">)</span>
        <span class="n">FFallReal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interpolator</span><span class="p">(</span><span class="n">energy</span> <span class="o">-</span> <span class="n">energyshift</span><span class="p">)</span>
        <span class="c1"># return directly the numpy array, it is usefull further Calculation</span>
        <span class="k">return</span> <span class="n">FFallReal</span><span class="p">[:</span><span class="mi">9</span><span class="p">]</span> <span class="o">+</span> <span class="n">FFallReal</span><span class="p">[</span><span class="mi">9</span><span class="p">:]</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span></div>

    <span class="c1"># properties</span>
    <span class="n">maxE</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getMaxE</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;Upper limit of stored energy range. Read-only.&quot;&quot;&quot;</span>
    <span class="n">minE</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getMinE</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;Lower limit of stored energy range. Read-only.&quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="FFfromChantler"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.FFfromChantler">[docs]</a><span class="k">class</span> <span class="nc">FFfromChantler</span><span class="p">(</span><span class="n">FFfromFile</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class to create an atomic formfactor for an element from  Database (Chantler Tables taken from https://dx.doi.org/10.18434/T4HS32).</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="FFfromChantler.__init__"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.FFfromChantler.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element_symbol</span><span class="p">,</span> <span class="n">energyshift</span><span class="o">=</span><span class="n">Parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="mi">0</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;Initializes the FFfromChantler object with an energy-dependent formfactor corresponding to the element given with **element_symbol**.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        element_symbol : str</span>
<span class="sd">            Refers to the element of which the atomic formfactor should be looked up. (More specifically: name of the corresponding database file without suffix.)</span>
<span class="sd">        energyshift : :class:`Parameters.Parameter`</span>
<span class="sd">            Species a fittable energyshift between the energy-dependent formfactor from Chantler Tables and the `real` one in the reflectivity measurement.</span>
<span class="sd">            So the formfactor delivered from :meth:`FFfromChantler.getFF` will not be `formfactor_from_database(E)` but `formfactor_from_databayse(E-energyshift)`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element_symbol</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">element_symbol</span><span class="se">\&#39;</span><span class="s2"> needs to be a string.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">energyshift</span><span class="p">,</span> <span class="n">Parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">energyshift</span><span class="se">\&#39;</span><span class="s2"> has to be of type Parameters.Parameter.&quot;</span><span class="p">)</span>

        <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">package_directory</span><span class="p">,</span> <span class="n">chantler_directory</span><span class="p">,</span> <span class="n">element_symbol</span> <span class="o">+</span> <span class="n">chantler_suffix</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">LookupError</span><span class="p">(</span><span class="s2">&quot;No database entry for element </span><span class="se">\&#39;</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">element_symbol</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2"> existing.&quot;</span><span class="p">)</span>
        
        <span class="n">f_rel</span><span class="o">=</span> <span class="n">chantler_frel_reader</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="n">f_NT</span><span class="o">=</span> <span class="n">chantler_fNT_reader</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">chantler_linereader</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>  <span class="c1"># make use of the chantler_linereader deliverd with the Chantler tables</span>
            <span class="k">if</span> <span class="n">output</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1">#only diagonal elements with equal entries f</span>
                <span class="c1">#Re(f)= f1 + f_rel + f_NT ; Im(f)=f2</span>
                <span class="c1">#f1 and f2 are energy-dependent (read for each line), the corrections f_rel, f_NT are given in the header of the Chantler tables</span>
                <span class="c1">#See &quot;Chantler, Journal fo Physical and Chemical Reference Data 24,71 (1995)&quot; Eq.3 and following.</span>
                <span class="n">energy</span><span class="p">,</span><span class="n">f1</span><span class="p">,</span><span class="n">f2</span> <span class="o">=</span> <span class="n">output</span>
                <span class="n">f</span><span class="o">=-</span><span class="p">(</span><span class="n">f1</span><span class="o">+</span><span class="n">f_rel</span><span class="o">+</span><span class="n">f_NT</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">f2</span>           <span class="c1">#convert to the PyXMRTool sign convention. See :doc:`/definitions/formfactors` for details</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">energy</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">f</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">wrapper</span><span class="p">,</span> <span class="n">energyshift</span><span class="p">)</span>  <span class="c1"># call constructor of parent class (FFfromFile)</span></div></div>

<div class="viewcode-block" id="FFfromScaledAbsorption"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.FFfromScaledAbsorption">[docs]</a><span class="k">class</span> <span class="nc">FFfromScaledAbsorption</span><span class="p">(</span><span class="n">Formfactor</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A formfactor class which uses the imaginary part of the formfactor (experimentally determined absorption signal which has been fitted to off-resonant values) given as a file, scales it with a fittable factor and calculates the real part by the Kramers-Kronig transformation. It realizes the procedure described in section 3.3 of Martin Zwiebler PhD-Thesis.</span>
<span class="sd">    It thereby deals only with the diagonal elements of the formfactor tensor. For the off-diagonal elements, the magnetic formfactors classes are used.</span>
<span class="sd">    </span>
<span class="sd">    See :doc:`/definitions/formfactors` for sign conventions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="FFfromScaledAbsorption.__init__"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.FFfromScaledAbsorption.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element_symbol</span><span class="p">,</span> <span class="n">E1</span><span class="p">,</span> <span class="n">E2</span><span class="p">,</span> <span class="n">E3</span><span class="p">,</span> <span class="n">scaling_factor</span><span class="p">,</span> <span class="n">absorption_filename</span><span class="p">,</span> <span class="n">absorption_linereaderfunction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">energyshift</span><span class="o">=</span><span class="n">Parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">autofitfunction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">autofitrange</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tabulated_filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tabulated_linereaderfunction</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initializes the FFfromScaledAbsorption object with an energy-dependent imaginary part of the formfactor given as file.</span>
<span class="sd">        </span>
<span class="sd">        To perform the Kramers-Kronig transformation without integrating to infinity, theoretical/tabulated formfactors (Chantler tabels from https://dx.doi.org/10.18434/T4HS32) are used. Their imaginary part differs only close to resonance from the measured absorption and should have been used before to perform the fit of the measured absorption to off-resonant values. </span>
<span class="sd">                    </span>
<span class="sd">        </span>
<span class="sd">        The imaginary part of each element of the formfactor is:</span>
<span class="sd">        </span>
<span class="sd">        * the value given by **Im_f0_E1**, for energy &lt; **E1**.</span>
<span class="sd">        * the value given by the file scaled by **scaling_factor** (roughly, see PhD Thesis of Martin Zwiebler,section 3.3, for details), for E1 &lt;= energy &lt;= E2</span>
<span class="sd">        * linear inperpolation between the scaled value at E2 and the value given for E3 by **Im_f0_E3**, for E2 &lt; energy &lt; E3</span>
<span class="sd">        * the value given by **Im_f0_E3**, for E3 &lt; energy       </span>
<span class="sd">        </span>
<span class="sd">        The Kramers-Kronig transformation to obtain the real part is done only once during instantiation. Therefore, it does not have to be repeated with every value of the **scaling_factor** and fitting is fast.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        element_symbol : string</span>
<span class="sd">            States the chemical element for which this formfactor is created as usual short version of its name. It is important to lookup the tabulated/theoretical reference formfactors from the Chantler tables. If you want to use your own formfactor as reference (see arguments **tabulated_filename** and **tabulated_linereaderfunction**) just enter an empty string here.</span>
<span class="sd">        E1 : float</span>
<span class="sd">            Energy in eV. From this energy on the energy-dependent imaginary part of the formfactor given as file is used and scaled.</span>
<span class="sd">        E2 : float</span>
<span class="sd">            Energy in eV. From this energy on the imaginary part of the formfactor is linearly interpolated.</span>
<span class="sd">        E3 : float</span>
<span class="sd">            Energy in eV. From this energy on the imaginary part of the formactor is constant **Im_f_E3**.</span>
<span class="sd">        scaling_factor : :class:`Parameter.Parameter`</span>
<span class="sd">            Specifies the fittable scaling factor (called *a* in Martin Zwiebler PhD Thesis).</span>
<span class="sd">        absorption_filename : str</span>
<span class="sd">            Path to the text file which contains the imaginary part of the formfactor which results from an apsorption measurement and a subsequent fit to off-resonant tabulated values.</span>
<span class="sd">        absorption_linereaderfunction : callable</span>
<span class="sd">            This function is used to convert one line from the *absorption* text file to data.</span>
<span class="sd">            It should be a function which takes a string and returns a tuple or list of 4 values: ``(energy, Im f_xx, Im f_yy, Im f_zz)``,</span>
<span class="sd">            where `energy` is measured in units of `eV` and imaginary parts of formfactors are real values in units of `e/atom` (dimensionless).</span>
<span class="sd">            It can also return `None` if it detects a comment line.</span>
<span class="sd">            You can use :meth:`FFfromScaledAbsorption.createAbsorptionLinereader` to get a standard function, which just reads this array as whitespace seperated from the line. This is actually the default if you give &#39;None&#39;.</span>
<span class="sd">        energyshift : :class:`Parameters.Parameter`</span>
<span class="sd">            Species a fittable energyshift between the energy-dependent formfactor calculated by the whole above mentioned procedure and the `real` one in the reflectivity measurement.</span>
<span class="sd">            As a consequence the peak but also E1,E2 and E3 are shifted.</span>
<span class="sd">        autofitfunction : callable</span>
<span class="sd">        autofitrange : float</span>
<span class="sd">            If given together with **autofitfunction**, the absorbtion from **absorbtion_filename** will be fitted to the imaginary part of the formfactors from Chantler tables or **tabulated_filename** just below/above **E1**/**E3** in a range given by **autofitrange** in eV.</span>
<span class="sd">            More specifically **autofifunction** will be fitted to the f2 of the Chantler tables.</span>
<span class="sd">            **autofitfunction** must work as following *f2=func(energy,absorbtion,a,b,c,...)*. *absorbtion* is the measured absorbtion/TEY/FY/... at a certain *energy* and *a*,*b*,*c*, ... are an arbitrary number of parameters.</span>
<span class="sd">            The parameters will be fitted such that the return values fit best to the f2 of the Chantler tables in the given energy-range.</span>
<span class="sd">            E.g. a standard fitfunction would be: *f2(E) = absorbtion*energy*a + b + c* energy. (see Martin Zwiebler PhD-Thesis, section 3.3)</span>
<span class="sd">        tabulated_filename : str</span>
<span class="sd">            Path to the text file which contains the tabulated/theoretical formfactor for the corresponding element.</span>
<span class="sd">            You can use this argument if you dont&#39;t want to use the standard Chantler tables. But therefore **element_symbol** has to be an empty string</span>
<span class="sd">        tabulated_linereaderfunction : callable</span>
<span class="sd">            This function is used to convert one line from the *tabulated* text file to data.</span>
<span class="sd">            It should be a function which takes a string and returns a tuple or list of 2 values: ``(energy,f)``,</span>
<span class="sd">            where `energy` is measured in units of `eV` and the formfactor `f` is a complex value in units of `e/atom` (dimensionless).</span>
<span class="sd">            It can also return `None` if it detects a comment line.</span>
<span class="sd">            You can use :meth:`FFfromScaledAbsorption.createTabulatedLinereader` to get a standard function, which just reads this array as whitespace separated from the line. This is actually the default if you give &#39;None&#39;.</span>
<span class="sd">            You can use this argument if you dont&#39;t want to use the standard Chantler tables and want to create your own linereader.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check parameters</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element_symbol</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">element_symbol</span><span class="se">\&#39;</span><span class="s2"> needs to be a string.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">E1</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Real</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">E1</span><span class="se">\&#39;</span><span class="s2"> needs to be a real number.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">E2</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Real</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">E2</span><span class="se">\&#39;</span><span class="s2"> needs to be a real number.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">E3</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Real</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">E3</span><span class="se">\&#39;</span><span class="s2"> needs to be a real number.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">E1</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">E2</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">E3</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Energies </span><span class="se">\&#39;</span><span class="s2">E1</span><span class="se">\&#39;</span><span class="s2">, </span><span class="se">\&#39;</span><span class="s2">E2</span><span class="se">\&#39;</span><span class="s2"> and </span><span class="se">\&#39;</span><span class="s2">E3</span><span class="se">\&#39;</span><span class="s2"> have to be greater than zero.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">[</span><span class="n">E1</span><span class="p">,</span> <span class="n">E2</span><span class="p">,</span> <span class="n">E3</span><span class="p">]</span> <span class="o">==</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">E1</span><span class="p">,</span> <span class="n">E2</span><span class="p">,</span> <span class="n">E3</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Energies </span><span class="se">\&#39;</span><span class="s2">E1</span><span class="se">\&#39;</span><span class="s2">, </span><span class="se">\&#39;</span><span class="s2">E2</span><span class="se">\&#39;</span><span class="s2"> and </span><span class="se">\&#39;</span><span class="s2">E3</span><span class="se">\&#39;</span><span class="s2"> have to have ascending values.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scaling_factor</span><span class="p">,</span> <span class="n">Parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">scaling_factor</span><span class="se">\&#39;</span><span class="s2"> has to be of type Parameters.Parameter.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">absorption_filename</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">absorption_filename</span><span class="se">\&#39;</span><span class="s2"> needs to be a string.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">absorption_filename</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;File </span><span class="se">\&#39;</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">absorption_filename</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2"> does not exist.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">absorption_linereaderfunction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">absorption_linereaderfunction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">createAbsorptionLinereader</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">absorption_linereaderfunction</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">absorption_linereaderfunction</span><span class="se">\&#39;</span><span class="s2"> needs to be a callable object.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">energyshift</span><span class="p">,</span> <span class="n">Parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">energyshift</span><span class="se">\&#39;</span><span class="s2"> has to be of type Parameters.Parameter.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">autofitrange</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">autofitfunction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">autofitrange</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">autofitfunction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You have to give both, </span><span class="se">\&#39;</span><span class="s2">autofitfunction</span><span class="se">\&#39;</span><span class="s2"> and </span><span class="se">\&#39;</span><span class="s2">autofitrange</span><span class="se">\&#39;</span><span class="s2"> or none of them.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">autofitrange</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>  <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">autofitrange</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Real</span><span class="p">)</span> <span class="ow">or</span> <span class="n">autofitrange</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">autofitrange</span><span class="se">\&#39;</span><span class="s2"> must be a positive real number.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">autofitfunction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">autofitfunction</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">absorption_linereaderfunction</span><span class="se">\&#39;</span><span class="s2"> needs to be a callable object.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="n">element_symbol</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span> <span class="ow">and</span> <span class="n">tabulated_filename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="n">element_symbol</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span> <span class="ow">and</span> <span class="n">tabulated_filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Either </span><span class="se">\&#39;</span><span class="s2">tabulated_filename</span><span class="se">\&#39;</span><span class="s2"> has to be None or </span><span class="se">\&#39;</span><span class="s2">element_symbol</span><span class="se">\&#39;</span><span class="s2"> has to be an empty string.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tabulated_filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tabulated_filename</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">tabulated_filename</span><span class="se">\&#39;</span><span class="s2"> needs to be a string.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">tabulated_filename</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;File </span><span class="se">\&#39;</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">tabulated_filename</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2"> does not exist.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">tabulated_linereaderfunction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">tabulated_linereaderfunction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">createTabulatedLinereader</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">tabulated_linereaderfunction</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">tabulated_linereaderfunction</span><span class="se">\&#39;</span><span class="s2"> needs to be a callable object.&quot;</span><span class="p">)</span>

        <span class="c1"># store parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_E1</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">E1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_E2</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">E2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_E3</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">E3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scaling_factor</span> <span class="o">=</span> <span class="n">scaling_factor</span>  <span class="c1"># Attention: this is supposed to be an instance of &quot;Parameters.Parameter&quot;. So a value can be obtained with self._scaling_factor.getValue(fitparraray)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_energyshift</span> <span class="o">=</span> <span class="n">energyshift</span>  <span class="c1"># Attention: this is supposed to be an instance of &quot;Parameters.Parameter&quot;. So a value can be obtained with self._energyshift.getValue(fitparraray)</span>

        <span class="c1"># setup acces to Chantler if neccessary</span>
        <span class="k">if</span> <span class="n">element_symbol</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="c1">#use Chantler tables from database and the functions delivered with it to read them</span>
            <span class="n">tabulated_filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">package_directory</span><span class="p">,</span> <span class="n">chantler_directory</span><span class="p">,</span><span class="n">element_symbol</span> <span class="o">+</span> <span class="n">chantler_suffix</span><span class="p">)</span>  <span class="c1"># filename of corresponding Chantler Table</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">tabulated_filename</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">LookupError</span><span class="p">(</span><span class="s2">&quot;No database entry for element </span><span class="se">\&#39;</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">element_symbol</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2"> existing.&quot;</span><span class="p">)</span>
            
            <span class="n">f_rel</span><span class="o">=</span> <span class="n">chantler_frel_reader</span><span class="p">(</span><span class="n">tabulated_filename</span><span class="p">)</span>
            <span class="n">f_NT</span><span class="o">=</span> <span class="n">chantler_fNT_reader</span><span class="p">(</span><span class="n">tabulated_filename</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
                <span class="n">output</span> <span class="o">=</span> <span class="n">chantler_linereader</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>  <span class="c1"># make use of the chantler_linereader deliverd with the Chantler tables</span>
                <span class="k">if</span> <span class="n">output</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1">#only diagonal elements with equal entries f</span>
                    <span class="c1">#Re(f)= f1 + f_rel + f_NT ; Im(f)=f2</span>
                    <span class="c1">#f1 and f2 are energy-dependent (read for each line), the corrections f_rel, f_NT are given in the header of the Chantler tables</span>
                    <span class="c1">#See &quot;Chantler, Journal fo Physical and Chemical Reference Data 24,71 (1995)&quot; Eq.3 and following.</span>
                    <span class="n">energy</span><span class="p">,</span><span class="n">f1</span><span class="p">,</span><span class="n">f2</span> <span class="o">=</span> <span class="n">output</span>
                    <span class="n">f</span><span class="o">=-</span><span class="p">(</span><span class="n">f1</span><span class="o">+</span><span class="n">f_rel</span><span class="o">+</span><span class="n">f_NT</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">f2</span>   <span class="c1">#convert to the PyXMRTool sign convention. See :doc:`/definitions/formfactors`</span>
                    <span class="k">return</span> <span class="p">[</span><span class="n">energy</span><span class="p">,</span> <span class="n">f</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>            
            <span class="n">tabulated_linereaderfunction</span> <span class="o">=</span> <span class="n">wrapper</span>


        <span class="c1"># read theoretica/tabulated formfactors from file</span>
        <span class="n">tab_energies</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">tab_formfactors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">tabulated_filename</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">linereaderoutput</span> <span class="o">=</span> <span class="n">tabulated_linereaderfunction</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">linereaderoutput</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">linereaderoutput</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Linereader function has to return a list/tuple.&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">linereaderoutput</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Linereader function hast to return a list/tuple with 2 elements.&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">linereaderoutput</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Linereader function hast to return a list/tuple of numbers.&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">linereaderoutput</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">complex</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Linereader function hast to return a real value for the energy.&quot;</span><span class="p">)</span>
                <span class="n">tab_energies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linereaderoutput</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># store energies in one list</span>
                <span class="n">tab_formfactors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linereaderoutput</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># store corresponding formfactors in another list</span>

        <span class="n">tab_formfactors</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tab_formfactors</span><span class="p">)</span>  <span class="c1"># convert list formfactors to a numpy array for convinience</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_minE</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">tab_energies</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_maxE</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">tab_energies</span><span class="p">)</span>
        <span class="c1"># Create an interpolation function based on the given energie-formfactor-points. The formfactors are thererfore transformed to arrays of length 2 but with real values.</span>
        <span class="c1"># After that the array of N arrays of 2 element is transformed to an array of 2 arrays of N elements as needed by the interp1d function.</span>
        <span class="c1"># Therefore, this function will return an array of length 2 wich has to be transformed back to 1 complex valued elements.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tab_interpolator</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">tab_energies</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">numpy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">tab_formfactors</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">tab_formfactors</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))),</span> <span class="mi">1</span><span class="p">)))</span>

        <span class="c1"># read imaginary part of formfactor from file</span>
        <span class="n">abs_energies</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">abs_im_formfactors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">absorption_filename</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">linereaderoutput</span> <span class="o">=</span> <span class="n">absorption_linereaderfunction</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">linereaderoutput</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">linereaderoutput</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Linereader function has to return a list/tuple.&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">linereaderoutput</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Linereader function hast to return a list/tuple with 4 elements.&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">linereaderoutput</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Real</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Linereader function hast to return a list/tuple of real numbers.&quot;</span><span class="p">)</span>
                <span class="n">abs_energies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linereaderoutput</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># store energies in one list</span>
                <span class="n">abs_im_formfactors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linereaderoutput</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>  <span class="c1"># store corresponding formfactors in another list</span>
        <span class="n">abs_im_formfactors</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">abs_im_formfactors</span><span class="p">)</span>  <span class="c1"># convert list formfactors to a numpy array for convinience</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_abs_minE</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">abs_energies</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_abs_maxE</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">abs_energies</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_E1</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_abs_minE</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_E2</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_abs_maxE</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Given absorption data does not cover needed range between E1 and E2.&quot;</span><span class="p">)</span>
        <span class="c1"># Create an interpolation function based on the given energie-imag_formfactor-points.</span>
        <span class="c1"># Therefore, the array of N arrays of 3 element is transformed to an array of 3 arrays of N elements as needed by the interp1d function.</span>
        <span class="c1"># This function will return an array of length 3 which is the interpolated imaginary part of the formfactor at the requested energy.</span>
        <span class="c1"># Energies and formfactors don&#39;t have to be stored explicitly , because they are contained in the &quot;self._interpolator&quot; function.</span>
        <span class="n">abs_interpolator</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">abs_energies</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">abs_im_formfactors</span><span class="p">))</span>
        
        <span class="c1">#perform autofit if autofitrange is given</span>
        <span class="n">abs_energies</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">abs_energies</span><span class="p">)</span>
        <span class="n">abs_im_formfactors_transposed</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">if</span> <span class="n">autofitfunction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">autofitrange</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">autofitrange</span><span class="p">)</span>
            <span class="n">N_fitfunction_arguments</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">getargspec</span><span class="p">(</span><span class="n">autofitfunction</span><span class="p">)</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
            <span class="c1">#select energy-range</span>
            <span class="n">tab_energies</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tab_energies</span><span class="p">)</span>
            <span class="n">tab_formfactors</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tab_formfactors</span><span class="p">)</span>
            <span class="n">fit_indices</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span> <span class="n">tab_energies</span><span class="o">&gt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">_E1</span><span class="o">-</span><span class="n">autofitrange</span> <span class="p">,</span> <span class="n">tab_energies</span><span class="o">&lt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">_E1</span> <span class="p">)</span> <span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">tab_energies</span><span class="o">&gt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">_E3</span> <span class="p">,</span> <span class="n">tab_energies</span><span class="o">&lt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">_E3</span><span class="o">+</span><span class="n">autofitrange</span><span class="p">))[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">fit_tab_energies</span><span class="o">=</span><span class="n">tab_energies</span><span class="p">[</span><span class="n">fit_indices</span><span class="p">]</span>
            <span class="n">fit_tab_formfactors_imag</span><span class="o">=</span><span class="n">tab_formfactors</span><span class="p">[</span><span class="n">fit_indices</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fit_tab_energies</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">N_fitfunction_arguments</span><span class="p">:</span>      <span class="c1">#check for the case that there are none or not enough values for f&#39;&#39; within the autofitrange and interpolate if neccessary</span>
                <span class="n">fit_tab_energies</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span> <span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_E1</span><span class="o">-</span><span class="n">autofitrange</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_E1</span><span class="p">,</span> <span class="n">N_fitfunction_arguments</span><span class="p">)</span> <span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_E3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_E3</span><span class="o">+</span><span class="n">autofitrange</span><span class="p">,</span> <span class="n">N_fitfunction_arguments</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
                <span class="n">fit_tab_formfactors_imag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tab_interpolator</span><span class="p">(</span><span class="n">fit_tab_energies</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="k">def</span> <span class="nf">f2_wrapper</span><span class="p">(</span><span class="n">energy</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">autofitfunction</span><span class="p">(</span><span class="n">energy</span><span class="p">,</span><span class="n">abs_interpolator</span><span class="p">(</span><span class="n">energy</span><span class="p">)[</span><span class="n">i</span><span class="p">],</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> 
                <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">curve_fit</span><span class="p">(</span><span class="n">f2_wrapper</span><span class="p">,</span><span class="n">fit_tab_energies</span><span class="p">,</span><span class="n">fit_tab_formfactors_imag</span><span class="p">,</span><span class="n">p0</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N_fitfunction_arguments</span><span class="p">))</span>
                <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span> <span class="o">=</span> <span class="n">popt</span>
                <span class="c1">#overwrite absorption and redo interpolation</span>
                <span class="n">abs_im_formfactors_transposed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f2_wrapper</span><span class="p">(</span><span class="n">abs_energies</span><span class="p">,</span> <span class="o">*</span><span class="n">popt</span><span class="p">))</span>
            <span class="n">abs_im_formfactors_transposed</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">abs_im_formfactors_transposed</span><span class="p">)</span>
            <span class="n">abs_im_formfactors</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">abs_im_formfactors_transposed</span><span class="p">)</span>
            <span class="n">abs_interpolator</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">abs_energies</span><span class="p">,</span> <span class="n">abs_im_formfactors_transposed</span><span class="p">)</span>
            
            

        <span class="c1"># create array of energies and different arrays of 3-element tensor to calculate the actual formfactors</span>
        <span class="c1"># &quot;im_f1&quot;: imaginary part of formfactors for scaling_factor (a) = 1</span>
        <span class="c1"># &quot;d_im_f1&quot;: derivative with respect to a of the imaginary part of formfactors</span>
        <span class="c1"># &quot;diff_im_f1&quot;: difference between &quot;im_f1&quot; and tabulated formfactors</span>
        <span class="c1"># &quot;kk_diff_im_f1&quot;: Kramers-Kronig transformed &quot;diff_im_f1</span>
        <span class="c1"># &quot;kk_d_im_f1&quot;: Kramers-Kronig transformed &quot;d_im_f1&quot;</span>
        <span class="n">energies</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">im_f1</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">d_im_f1</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">diff_im_f1</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">im_f1_E2</span> <span class="o">=</span> <span class="n">abs_interpolator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_E2</span><span class="p">)</span>  <span class="c1"># imaginary part of formfactors for scaling_factor (a) = 1 at E2</span>
        <span class="n">re</span><span class="p">,</span> <span class="n">im</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tab_interpolator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_E1</span><span class="p">)</span>
        <span class="n">im_f0_E1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">im</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">im</span><span class="p">])</span>  <span class="c1"># imaginary part of formfactors  at E1  (does not depend on &quot;a&quot;)</span>
        <span class="n">re</span><span class="p">,</span> <span class="n">im</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tab_interpolator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_E3</span><span class="p">)</span>
        <span class="n">im_f0_E3</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">im</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">im</span><span class="p">])</span>  <span class="c1"># imaginary part of formfactors  at E3  (does not depend on &quot;a&quot;)</span>
        <span class="n">tab_i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">energy</span> <span class="ow">in</span> <span class="n">tab_energies</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">energy</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_E1</span><span class="p">:</span>
                <span class="n">energies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span>
                <span class="n">im_f1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tab_formfactors</span><span class="p">[</span><span class="n">tab_i</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="n">tab_formfactors</span><span class="p">[</span><span class="n">tab_i</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="n">tab_formfactors</span><span class="p">[</span><span class="n">tab_i</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="p">]))</span>  <span class="c1"># below E1, formfactor tensor is a diagonal tensor, values are the given &quot;tabulated&quot; ones</span>
                <span class="n">d_im_f1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
                <span class="n">diff_im_f1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
            <span class="n">tab_i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">abs_i</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">energy</span> <span class="ow">in</span> <span class="n">abs_energies</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">energy</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_E1</span> <span class="ow">and</span> <span class="n">energy</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_E2</span><span class="p">:</span>
                <span class="n">energies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span>
                <span class="n">im_f1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">abs_im_formfactors</span><span class="p">[</span><span class="n">abs_i</span><span class="p">])</span>  <span class="c1"># between E1 and E2, it is just the measured imaginary part of the formfactor</span>
                <span class="n">d_im_f1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">abs_im_formfactors</span><span class="p">[</span><span class="n">abs_i</span><span class="p">]</span> <span class="o">-</span> <span class="n">im_f0_E1</span><span class="p">)</span>  <span class="c1"># between E1 and E2, the derivative is the difference between &quot;measured&quot; imaginary part of the formfactor and the &quot;tabulated&quot; value at E1</span>
                <span class="n">re</span><span class="p">,</span> <span class="n">im</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tab_interpolator</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span>
                <span class="n">diff_im_f1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">abs_im_formfactors</span><span class="p">[</span><span class="n">abs_i</span><span class="p">]</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">im</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">im</span><span class="p">]))</span>  <span class="c1"># between E1 and E2, just the difference between &quot;measured&quot; imaginary part of the formfactor and the &quot;tabulated&quot; value</span>
            <span class="n">abs_i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">tab_i</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">energy</span> <span class="ow">in</span> <span class="n">tab_energies</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">energy</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_E2</span><span class="p">:</span>
                <span class="n">energies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">energy</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_E2</span> <span class="ow">and</span> <span class="n">energy</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_E3</span><span class="p">:</span>
                <span class="n">im_f1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">im_f1_E2</span> <span class="o">+</span> <span class="p">(</span><span class="n">energy</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_E2</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_E3</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_E2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">im_f0_E3</span> <span class="o">-</span> <span class="n">im_f1_E2</span><span class="p">))</span>  <span class="c1"># between E2 and E3, it is a linear interpolation</span>
                <span class="n">d_im_f1</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_E3</span> <span class="o">-</span> <span class="n">energy</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_E3</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_E2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">im_f1_E2</span> <span class="o">-</span> <span class="n">im_f0_E1</span><span class="p">))</span>  <span class="c1"># between E2 and E3, the imaginary part is a linear interpolation, the derivative correspondingly</span>
                <span class="n">diff_im_f1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">im_f1</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tab_formfactors</span><span class="p">[</span><span class="n">tab_i</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="n">tab_formfactors</span><span class="p">[</span><span class="n">tab_i</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span><span class="n">tab_formfactors</span><span class="p">[</span><span class="n">tab_i</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="p">]))</span>  <span class="c1"># between E1 and E2, just the difference between linearly interpolated imaginary part of the formfactor and the &quot;tabulated&quot; value</span>
            <span class="k">elif</span> <span class="n">energy</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_E3</span><span class="p">:</span>
                <span class="n">im_f1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tab_formfactors</span><span class="p">[</span><span class="n">tab_i</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="n">tab_formfactors</span><span class="p">[</span><span class="n">tab_i</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span><span class="n">tab_formfactors</span><span class="p">[</span><span class="n">tab_i</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="p">]))</span>  <span class="c1"># above E3, values are the given &quot;tabulated&quot; ones</span>
                <span class="n">d_im_f1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
                <span class="n">diff_im_f1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
            <span class="n">tab_i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">im_f1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">im_f1</span><span class="p">)</span>
        <span class="n">d_im_f1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">d_im_f1</span><span class="p">)</span>
        <span class="n">diff_im_f1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">diff_im_f1</span><span class="p">)</span>

        <span class="c1"># perform Kramers-Kronig transformations to obtain &quot;kk_diff_im_f1&quot; and &quot;kk_d_im_f1&quot;</span>
        <span class="c1"># therefore one array for every position of the tensors is needed, which can be obtained with &quot;transpose&quot;</span>
        <span class="n">trans_diff_im_f1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">diff_im_f1</span><span class="p">)</span>
        <span class="n">trans_d_im_f1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">d_im_f1</span><span class="p">)</span>
        <span class="n">trans_kk_diff_im_f1</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">trans_kk_d_im_f1</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">trans_kk_diff_im_f1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">KramersKronig</span><span class="p">(</span><span class="n">energies</span><span class="p">,</span> <span class="n">trans_diff_im_f1</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>               <span class="c1">#somehow it is necessary to use negative KramersKronig. Don&#39;t know why, but works nice.</span>
            <span class="n">trans_kk_d_im_f1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">KramersKronig</span><span class="p">(</span><span class="n">energies</span><span class="p">,</span> <span class="n">trans_d_im_f1</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        <span class="n">trans_kk_diff_im_f1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">trans_kk_diff_im_f1</span><span class="p">)</span>
        <span class="n">trans_kk_d_im_f1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">trans_kk_d_im_f1</span><span class="p">)</span>

        <span class="c1"># inflate 3-element arrays (just diagonals of formfactor tensor) to 9-element arrays, by adding zeros as off-diogonals</span>
        <span class="n">im_f1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">im_f1</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">trans_d_im_f1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">trans_d_im_f1</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">trans_kk_diff_im_f1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">trans_kk_diff_im_f1</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">trans_kk_d_im_f1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">trans_kk_d_im_f1</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Create interpolation functions for the above created arrays for later use with &quot;getFF&quot;</span>
        <span class="c1"># For this the arrays of N arrays of 9 elements are transposed to arrays of 9 arras of N elements as needed by the interp1d function (trans_kk_diff_im_f1 and trans_kk_d_im_f1 are already transposed)</span>
        <span class="c1"># The functions will return arrays of length 9 for the corresponding energy as interpolation.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_im_f1_interpolator</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">energies</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">im_f1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_d_im_f1_interpolator</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">energies</span><span class="p">,</span> <span class="n">trans_d_im_f1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kk_diff_im_f1_interpolator</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">energies</span><span class="p">,</span> <span class="n">trans_kk_diff_im_f1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kk_d_im_f1_interpolator</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">energies</span><span class="p">,</span> <span class="n">trans_kk_d_im_f1</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_getMinE</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_minE</span>

    <span class="k">def</span> <span class="nf">_getMaxE</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxE</span>

    <span class="c1"># public methods</span>

<div class="viewcode-block" id="FFfromScaledAbsorption.createAbsorptionLinereader"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.FFfromScaledAbsorption.createAbsorptionLinereader">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">createAbsorptionLinereader</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the standard linereader function for absorption files for usage with :meth:`FFfromScaledAbsorption.__init__`.</span>
<span class="sd">        </span>
<span class="sd">        This standard linereader function reads energy and elements of the imaginary part of the formfactor tensor as a whitespace-seperated list (i.e. 4 numbers) and interpretes \&quot;#\&quot; as comment sign.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">commentsymbol</span> <span class="o">=</span> <span class="s1">&#39;#&#39;</span>

        <span class="k">def</span> <span class="nf">linereader</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">line</span><span class="se">\&#39;</span><span class="s2"> needs to be a string.&quot;</span><span class="p">)</span>
            <span class="n">line</span> <span class="o">=</span> <span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">commentsymbol</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># ignore everything behind the commentsymbol  #</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="o">.</span><span class="n">isspace</span><span class="p">()</span> <span class="ow">and</span> <span class="n">line</span><span class="p">:</span>  <span class="c1"># ignore empty lines</span>
                <span class="n">linearray</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">linearray</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Absorption file has wrong format.&quot;</span><span class="p">)</span>
                <span class="n">linearray</span> <span class="o">=</span> <span class="p">[</span><span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">linearray</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">linearray</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">linereader</span>  <span class="c1"># here the FUNKTION linereader is returned</span></div>

<div class="viewcode-block" id="FFfromScaledAbsorption.createTabulatedLinereader"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.FFfromScaledAbsorption.createTabulatedLinereader">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">createTabulatedLinereader</span><span class="p">(</span><span class="n">complex_numbers</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the standard linereader function for tabulated formfactor files for usage with :meth:`FFfromScaledAbsorption.__init__`.</span>
<span class="sd">        </span>
<span class="sd">        This standard linereader function reads energy and the complex formfactor as a whitespace-seperated list (i.e. 2 numbers) and interpretes \&quot;#\&quot; as comment sign.</span>
<span class="sd">        If **complex_numbers** = *False* then the reader reads real and imaginary part of the formfactor seperately, i.e. every line has to consist of 3 numbers seperated by whitespaces::</span>
<span class="sd">            </span>
<span class="sd">            energy ff_real ff_im </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">commentsymbol</span> <span class="o">=</span> <span class="s1">&#39;#&#39;</span>
        <span class="k">if</span> <span class="n">complex_numbers</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">linereader</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">line</span><span class="se">\&#39;</span><span class="s2"> needs to be a string.&quot;</span><span class="p">)</span>
                <span class="n">line</span> <span class="o">=</span> <span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">commentsymbol</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># ignore everything behind the commentsymbol  #</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="o">.</span><span class="n">isspace</span><span class="p">()</span> <span class="ow">and</span> <span class="n">line</span><span class="p">:</span>  <span class="c1"># ignore empty lines</span>
                    <span class="n">linearray</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">linearray</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;File for tabulated formfactor has wrong format.&quot;</span><span class="p">)</span>
                    <span class="n">linearray</span> <span class="o">=</span> <span class="p">[</span><span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">linearray</span><span class="p">]</span>
                    <span class="k">return</span> <span class="n">linearray</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">complex_numbers</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">linereader</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">line</span><span class="se">\&#39;</span><span class="s2"> needs to be a string.&quot;</span><span class="p">)</span>
                <span class="n">line</span> <span class="o">=</span> <span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">commentsymbol</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># ignore everything behind the commentsymbol  #</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="o">.</span><span class="n">isspace</span><span class="p">()</span> <span class="ow">and</span> <span class="n">line</span><span class="p">:</span>  <span class="c1"># ignore empty lines</span>
                    <span class="n">linearray</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">linearray</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;File for tabulated formfactor file has wrong format.&quot;</span><span class="p">)</span>
                    <span class="n">linearray</span> <span class="o">=</span> <span class="p">[</span><span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">linearray</span><span class="p">]</span>
                    <span class="k">return</span> <span class="p">[</span><span class="n">linearray</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">linearray</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">linearray</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">complex_numbers</span><span class="se">\&#39;</span><span class="s2"> has to be boolean.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">linereader</span></div>

<div class="viewcode-block" id="FFfromScaledAbsorption.getFF"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.FFfromScaledAbsorption.getFF">[docs]</a>    <span class="k">def</span> <span class="nf">getFF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">energy</span><span class="p">,</span> <span class="n">fitpararray</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the (energy-shifted )formfactor for **energy** as an interpolation between the stored values from file as 9-element 1-D numpy array of complex numbers.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        energy : float</span>
<span class="sd">            Measured in units of eV.</span>
<span class="sd">        fitpararray :</span>
<span class="sd">            Is needed for the scaling factor \&#39;a\&#39; and an energy shift if defined.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scaling_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scaling_factor</span><span class="o">.</span><span class="n">getValue</span><span class="p">(</span><span class="n">fitpararray</span><span class="p">)</span>
        <span class="n">energyshift</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_energyshift</span><span class="o">.</span><span class="n">getValue</span><span class="p">(</span><span class="n">fitpararray</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">energy</span> <span class="o">-</span> <span class="n">energyshift</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minE</span> <span class="ow">or</span> <span class="n">energy</span> <span class="o">-</span> <span class="n">energyshift</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxE</span><span class="p">:</span>  <span class="c1"># use this strange construction with numpy arrays to allow &quot;energy&quot; to be a numpy array of energies</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">energy + energyshift = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; - &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">energyshift</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">energy</span> <span class="o">-</span> <span class="n">energyshift</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2"> is out of range (&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minE</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;,&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxE</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;).&quot;</span><span class="p">)</span>

        <span class="n">energy</span> <span class="o">=</span> <span class="n">energy</span> <span class="o">-</span> <span class="n">energyshift</span>  <span class="c1"># apply energyshift</span>

        <span class="n">ImFF</span> <span class="o">=</span> <span class="p">(</span><span class="n">scaling_factor</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d_im_f1_interpolator</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_im_f1_interpolator</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span>
        <span class="n">tab_real</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tab_interpolator</span><span class="p">(</span><span class="n">energy</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1">#RealFF = numpy.array([tab_real, 0, 0, 0, tab_real, 0, 0, 0, tab_real]) + self._kk_diff_im_f1_interpolator(energy) + (scaling_factor - 1) * self._kk_d_im_f1_interpolator(energy)</span>
        <span class="n">RealFF</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tab_real</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tab_real</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tab_real</span><span class="p">])</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kk_diff_im_f1_interpolator</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">scaling_factor</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kk_d_im_f1_interpolator</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">RealFF</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">ImFF</span></div>

    <span class="c1"># properties</span>
    <span class="n">maxE</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getMaxE</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;Upper limit of stored energy range. Read-only.&quot;&quot;&quot;</span>
    <span class="n">minE</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getMinE</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;Lower limit of stored energy range. Read-only.&quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="FFfromFitableModel"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.FFfromFitableModel">[docs]</a><span class="k">class</span> <span class="nc">FFfromFitableModel</span><span class="p">(</span><span class="n">Formfactor</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Formfactor class which can used to implement a fittable model for the formfactor as e.g. a Kramers-Kronig variational approach with triangles (see Stone et al., PRB 86, 024102 (2012).</span>
<span class="sd">    </span>
<span class="sd">    The class just take the complex formfactor tensor as :class:`Parameters.ParametrizedFunction`, which is a function dependent on fitparameters.</span>
<span class="sd">    </span>
<span class="sd">    See :doc:`/definitions/formfactors` for sign conventions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="FFfromFitableModel.__init__"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.FFfromFitableModel.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ff_tensor_function</span><span class="p">,</span> <span class="n">minE</span><span class="p">,</span> <span class="n">maxE</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ff_tensor_function : :class:`Parameters.ParametrizedFunction`</span>
<span class="sd">            Energy-dependent complex formfactor tensor. A parametrized funtion of energy  (see :class:`Parameters.ParametrizedFunction`) which reurns a list of 9 complex numbers.</span>
<span class="sd">        minE : float</span>
<span class="sd">        maxE : float</span>
<span class="sd">            Gives the boundaries of the valid energy-range of the given ff_tensor_function.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check parameters</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ff_tensor_function</span><span class="p">,</span> <span class="n">Parameters</span><span class="o">.</span><span class="n">ParametrizedFunction</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">ff_tensor_function</span><span class="se">\&#39;</span><span class="s2"> has to be an instance of \`Parameters.ParametrizedFunction\`.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">minE</span> <span class="o">&lt;</span> <span class="n">maxE</span> <span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">minE</span><span class="se">\&#39;</span><span class="s2"> has to be smaller than </span><span class="se">\&#39;</span><span class="s2">maxE</span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="c1"># asign members</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ff_tensor_function</span> <span class="o">=</span> <span class="n">ff_tensor_function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_minE</span><span class="o">=</span><span class="n">minE</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_maxE</span><span class="o">=</span><span class="n">maxE</span></div>


<div class="viewcode-block" id="FFfromFitableModel.getFF"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.FFfromFitableModel.getFF">[docs]</a>    <span class="k">def</span> <span class="nf">getFF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">energy</span><span class="p">,</span> <span class="n">fitpararray</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the formfactor for **energy** corresponding to **fitpararray** (if it depends on it) as 9-element Numpy array of complex numbers.</span>
<span class="sd">        </span>
<span class="sd">        **energy** is measured in units of eV.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">energy</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minE</span> <span class="ow">or</span> <span class="n">energy</span>  <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxE</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">energy  = &quot;</span>  <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">energy</span> <span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2"> is out of range (&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minE</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;,&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxE</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;).&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ff_tensor_function</span><span class="o">.</span><span class="n">getValue</span><span class="p">(</span><span class="n">energy</span><span class="p">,</span><span class="n">fitpararray</span><span class="p">)</span>   <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_getMinE</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_minE</span>

    <span class="k">def</span> <span class="nf">_getMaxE</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxE</span>

    <span class="c1"># properties</span>
    <span class="n">maxE</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getMaxE</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;Upper limit of stored energy range. Read-only.&quot;&quot;&quot;</span>
    <span class="n">minE</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getMinE</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;Lower limit of stored energy range. Read-only.&quot;&quot;&quot;</span></div>



<span class="c1"># -----------------------------------------------------------------------------------------------------------------------------</span>
<span class="c1"># Magnetic Formfactor classes</span>

<div class="viewcode-block" id="MagneticFormfactor"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.MagneticFormfactor">[docs]</a><span class="k">class</span> <span class="nc">MagneticFormfactor</span><span class="p">(</span><span class="n">Formfactor</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class to deal with energy-dependent magnetic form-factors, i.e. only off-diagonal elements of a formfactor tensor originating from the magnetization.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="MagneticFormfactor.__init__"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.MagneticFormfactor.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m_prime</span><span class="p">,</span> <span class="n">m_primeprime</span><span class="p">,</span> <span class="n">theta_M</span><span class="p">,</span> <span class="n">phi_M</span><span class="p">,</span> <span class="n">minE</span><span class="p">,</span> <span class="n">maxE</span><span class="p">,</span> <span class="n">energyshift</span><span class="o">=</span><span class="n">Parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="mi">0</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;Initializes the MagneticFormfactor with energy-dependent magnetic terms **m_prime** and **m_primeprime** and the angles **theta_M** and **phi_M** which describe the direction of the magnetization.</span>
<span class="sd">        </span>
<span class="sd">        See *Macke and Goering 2014, J.Phys.: Condens. Matter 26, 363201.* Eq. 11-14 for details.</span>
<span class="sd">               </span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        m_prime : :class:Parameters.ParametrizedFunction</span>
<span class="sd">        m_primeprime : :class:Parameters.ParametrizedFunction</span>
<span class="sd">            Real and imaginary parts of the magnetic term. Given as parametrized functions of energy. See also :doc:`/definitions/coordinate_systems`.</span>
<span class="sd">        theta_M : :class:`Parameters.Parameter`</span>
<span class="sd">        phi_M : :class:`Parameters.Parameter`</span>
<span class="sd">            Angles which describe the direction of the magnetization measured in degrees.</span>
<span class="sd">        minE : float</span>
<span class="sd">        maxE : float</span>
<span class="sd">            Lower and upper limits of the energy range for which the formfactor is defined.</span>
<span class="sd">        energyshift : :class:`Parameters.Parameter`</span>
<span class="sd">            Species a fittable energyshift between the energy-dependent formfactor created from the XMCD measurement and the `real` one in the reflectivity measurement.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check parameters</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m_prime</span><span class="p">,</span> <span class="n">Parameters</span><span class="o">.</span><span class="n">ParametrizedFunction</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">m_prime</span><span class="se">\&#39;</span><span class="s2"> has to be an instance of </span><span class="se">\&#39;</span><span class="s2">Parameters.ParametrizedFunction</span><span class="se">\&#39;</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m_primeprime</span><span class="p">,</span> <span class="n">Parameters</span><span class="o">.</span><span class="n">ParametrizedFunction</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">m_primeprime</span><span class="se">\&#39;</span><span class="s2"> has to be an instance of </span><span class="se">\&#39;</span><span class="s2">Parameters.ParametrizedFunction</span><span class="se">\&#39;</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">theta_M</span><span class="p">,</span> <span class="n">Parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">theta_M</span><span class="se">\&#39;</span><span class="s2"> has to be an instance of </span><span class="se">\&#39;</span><span class="s2">Parameters.Parameter</span><span class="se">\&#39;</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">phi_M</span><span class="p">,</span> <span class="n">Parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">phi_M</span><span class="se">\&#39;</span><span class="s2"> has to be an instance of </span><span class="se">\&#39;</span><span class="s2">Parameters.Parameter</span><span class="se">\&#39;</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">minE</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Real</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">minE</span><span class="se">\&#39;</span><span class="s2"> has to be a real number.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">maxE</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Real</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">maxE</span><span class="se">\&#39;</span><span class="s2"> has to be a real number.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">minE</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">maxE</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">minE</span><span class="se">\&#39;</span><span class="s2"> and </span><span class="se">\&#39;</span><span class="s2">maxE</span><span class="se">\&#39;</span><span class="s2"> have to be greater than zero.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">minE</span> <span class="o">&gt;=</span> <span class="n">maxE</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">minE</span><span class="se">\&#39;</span><span class="s2"> has to be smaller than </span><span class="se">\&#39;</span><span class="s2">maxE</span><span class="se">\&#39;</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">energyshift</span><span class="p">,</span> <span class="n">Parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">energyshift</span><span class="se">\&#39;</span><span class="s2"> has to be of type Parameters.Parameter.&quot;</span><span class="p">)</span>

        <span class="c1"># store parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mp</span> <span class="o">=</span> <span class="n">m_prime</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mpp</span> <span class="o">=</span> <span class="n">m_primeprime</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_theta_M</span> <span class="o">=</span> <span class="n">theta_M</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_phi_M</span> <span class="o">=</span> <span class="n">phi_M</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_minE</span> <span class="o">=</span> <span class="n">minE</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_maxE</span> <span class="o">=</span> <span class="n">maxE</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_energyshift</span> <span class="o">=</span> <span class="n">energyshift</span></div>

    <span class="c1"># private methods</span>
    <span class="k">def</span> <span class="nf">_getMinE</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_minE</span>

    <span class="k">def</span> <span class="nf">_getMaxE</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxE</span>

    <span class="c1"># public methods</span>
<div class="viewcode-block" id="MagneticFormfactor.getFF"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.MagneticFormfactor.getFF">[docs]</a>    <span class="k">def</span> <span class="nf">getFF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">energy</span><span class="p">,</span> <span class="n">fitpararray</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the magnetic part of the formfactor for **energy** corresponding to **fitpararray** (if it depends on it) as 9-element list of complex numbers.</span>
<span class="sd">        </span>
<span class="sd">        The diagonal elements are all zero here.</span>
<span class="sd">        </span>
<span class="sd">        **energy** is measured in units of eV.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">theta_M</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">180.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta_M</span><span class="o">.</span><span class="n">getValue</span><span class="p">(</span><span class="n">fitpararray</span><span class="p">)</span>
        <span class="n">phi_M</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">180.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phi_M</span><span class="o">.</span><span class="n">getValue</span><span class="p">(</span><span class="n">fitpararray</span><span class="p">)</span>

        <span class="n">energyshift</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_energyshift</span><span class="o">.</span><span class="n">getValue</span><span class="p">(</span><span class="n">fitpararray</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">energy</span> <span class="o">-</span> <span class="n">energyshift</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minE</span> <span class="ow">or</span> <span class="n">energy</span> <span class="o">-</span> <span class="n">energyshift</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxE</span><span class="p">:</span>  <span class="c1"># use this strange construction with numpy arrays to allow &quot;energy&quot; to be a numpy array of energies</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">energy + energyshift = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; - &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">energyshift</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">energy</span> <span class="o">-</span> <span class="n">energyshift</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2"> is out of range (&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minE</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;,&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxE</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;).&quot;</span><span class="p">)</span>

        <span class="n">energy</span> <span class="o">=</span> <span class="n">energy</span> <span class="o">-</span> <span class="n">energyshift</span>  <span class="c1"># apply energyshift</span>

        <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mp</span><span class="o">.</span><span class="n">getValue</span><span class="p">(</span><span class="n">energy</span><span class="p">,</span> <span class="n">fitpararray</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mpp</span><span class="o">.</span><span class="n">getValue</span><span class="p">(</span><span class="n">energy</span><span class="p">,</span> <span class="n">fitpararray</span><span class="p">))</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta_M</span><span class="p">),</span> <span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta_M</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi_M</span><span class="p">),</span> <span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta_M</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta_M</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi_M</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta_M</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi_M</span><span class="p">),</span> <span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta_M</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi_M</span><span class="p">),</span> <span class="mi">0</span><span class="p">])</span></div>

    <span class="c1"># properties</span>
    <span class="n">maxE</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getMaxE</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;Upper limit of stored energy range. Read-only.&quot;&quot;&quot;</span>
    <span class="n">minE</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getMinE</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;Lower limit of stored energy range. Read-only.&quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="MFFfromXMCD"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.MFFfromXMCD">[docs]</a><span class="k">class</span> <span class="nc">MFFfromXMCD</span><span class="p">(</span><span class="n">MagneticFormfactor</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class to deal with a magnetic formfactor (MFF) derived from an XMCD measurement.</span>
<span class="sd">    </span>
<span class="sd">    BEWARE: The absolut values are only correct if you scaled the XMCD signal to tabulated absorbtion data. But usually it is enough to get relative values, which can give you magnetization profiles.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="MFFfromXMCD.__init__"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.MFFfromXMCD.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta_M</span><span class="p">,</span> <span class="n">phi_M</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">linereaderfunction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">energyshift</span><span class="o">=</span><span class="n">Parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="mi">0</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;Initializes the MFF from an XMCD measurement given as textfile.</span>
<span class="sd">        </span>
<span class="sd">        The XMCD values are directly used to create the **m_primeprime** function.</span>
<span class="sd">        </span>
<span class="sd">        The **m_prime** function is found as Kramers-Kronig transformation of **m_primeprime**.</span>
<span class="sd">        </span>

<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        theta_M, phi_M : :class:`Parameters.Parameter`</span>
<span class="sd">            Angles which describe the direction of the magnetization measured in degrees. See also :doc:`/definitions/coordinate_systems`.</span>
<span class="sd">        filename : str</span>
<span class="sd">            Path to the text file which contains the XMCD signal as function of energy.</span>
<span class="sd">        linereaderfunction : callable</span>
<span class="sd">            This function is used to convert one line from the *xmcd* text file to data.</span>
<span class="sd">            It should be a function which takes a string and returns a tuple or list of 2 values: ``(energy, xmcd)``,</span>
<span class="sd">            where `energy` is measured in units of `eV` and &#39;xmcd&#39; is a real value in units of `e/atom` (dimensionless) (if it is scaled correctly).</span>
<span class="sd">            It can also return `None` if it detects a comment line.</span>
<span class="sd">            You can use :meth:`MFFfromXMCD.createLinereader` to get a standard function, which just reads this array as whitespace seperated from the line.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check parameters</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">filename</span><span class="se">\&#39;</span><span class="s2"> needs to be a string.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;File </span><span class="se">\&#39;</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2"> does not exist.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">linereaderfunction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">linereaderfunction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">createLinereader</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">linereaderfunction</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">linereaderfunction</span><span class="se">\&#39;</span><span class="s2"> needs to be a callable object.&quot;</span><span class="p">)</span>
        

        <span class="c1"># read theoretica/tabulated formfactors from file</span>
        <span class="n">energies</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">xmcd</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">linereaderoutput</span> <span class="o">=</span> <span class="n">linereaderfunction</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">linereaderoutput</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">linereaderoutput</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Linereader function has to return a list/tuple.&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">linereaderoutput</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Linereader function hast to return a list/tuple with 2 elements.&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">linereaderoutput</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Real</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Linereader function hast to return a list/tuple of real numbers.&quot;</span><span class="p">)</span>
                <span class="n">energies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linereaderoutput</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># store energies in one list</span>
                <span class="n">xmcd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linereaderoutput</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># store corresponding formfactors in another list</span>


        <span class="n">xmcd</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xmcd</span><span class="p">)</span>  <span class="c1"># convert list xmcd to a numpy array for convinience</span>
        <span class="n">minE</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">energies</span><span class="p">)</span>
        <span class="n">maxE</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">energies</span><span class="p">)</span>

        <span class="c1"># Create an interpolation function based on the given energie-xmcd-points and plug it into a parametrized Function (even thogh theire are no parameters; but it is easy to use the base class) (buying simplicity with speed here).</span>
        <span class="n">mpp</span> <span class="o">=</span> <span class="n">Parameters</span><span class="o">.</span><span class="n">ParametrizedFunction</span><span class="p">(</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">energies</span><span class="p">,</span> <span class="n">xmcd</span><span class="p">))</span>

        <span class="c1"># perform Kramers-Kronig transformation</span>
        <span class="n">m_prime</span> <span class="o">=</span> <span class="n">KramersKronig</span><span class="p">(</span><span class="n">energies</span><span class="p">,</span> <span class="n">xmcd</span><span class="p">)</span>
        <span class="c1"># Create an interpolation function based on m_prime</span>
        <span class="n">mp</span> <span class="o">=</span> <span class="n">Parameters</span><span class="o">.</span><span class="n">ParametrizedFunction</span><span class="p">(</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">energies</span><span class="p">,</span> <span class="n">m_prime</span><span class="p">))</span>

        <span class="c1"># call constructor of base class</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">mpp</span><span class="p">,</span> <span class="n">theta_M</span><span class="p">,</span> <span class="n">phi_M</span><span class="p">,</span> <span class="n">minE</span><span class="p">,</span> <span class="n">maxE</span><span class="p">,</span> <span class="n">energyshift</span><span class="p">)</span></div>

    <span class="c1"># static methods</span>
<div class="viewcode-block" id="MFFfromXMCD.createLinereader"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.MFFfromXMCD.createLinereader">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">createLinereader</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the standard linereader function for xmcd files for usage with :meth:`MFFfromXMCD.__init__`.</span>
<span class="sd">        </span>
<span class="sd">        This standard linereader function reads energy and xmcd value as a whitespace-seperated list (i.e. 2 numbers) and interpretes \&quot;#\&quot; as comment sign.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">commentsymbol</span> <span class="o">=</span> <span class="s1">&#39;#&#39;</span>

        <span class="k">def</span> <span class="nf">linereader</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">line</span><span class="se">\&#39;</span><span class="s2"> needs to be a string.&quot;</span><span class="p">)</span>
            <span class="n">line</span> <span class="o">=</span> <span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">commentsymbol</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># ignore everything behind the commentsymbol  #</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="o">.</span><span class="n">isspace</span><span class="p">()</span> <span class="ow">and</span> <span class="n">line</span><span class="p">:</span>  <span class="c1"># ignore empty lines</span>
                <span class="n">linearray</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">linearray</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;XMCD file has wrong format.&quot;</span><span class="p">)</span>
                <span class="n">linearray</span> <span class="o">=</span> <span class="p">[</span><span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">linearray</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">linearray</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">linereader</span></div>

        <span class="c1"># private methods</span>

    <span class="k">def</span> <span class="nf">_getMinE</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_minE</span>

    <span class="k">def</span> <span class="nf">_getMaxE</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxE</span>

    <span class="c1"># properties</span>
    <span class="n">maxE</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getMaxE</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;Upper limit of stored energy range. Read-only.&quot;&quot;&quot;</span>
    <span class="n">minE</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getMinE</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;Lower limit of stored energy range. Read-only.&quot;&quot;&quot;</span></div>


<span class="c1"># -----------------------------------------------------------------------------------------------------------------------------</span>
<span class="c1"># Density Profil classes</span>

<div class="viewcode-block" id="DensityProfile"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.DensityProfile">[docs]</a><span class="k">class</span> <span class="nc">DensityProfile</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class can be used to generate arbitrary density profiles within a stack of several :class:`.AtomLayerObject` of equal thicknesses.</span>
<span class="sd">    </span>
<span class="sd">    The idea is to collect all information regarding the density profile in an object of this class and to generate entries for the *densitydict* of the single :class:`.AtomLayerObject` instances from it.</span>
<span class="sd">    This means that the class :class:`.DensityProfile` does not really talk to the layers, but is only a higher level convinience class to set up the interconnected densities of the atoms within the layers as instances of :class:`Parameters.DerivedParameter`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="DensityProfile.__init__"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.DensityProfile.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_layer_idx</span><span class="p">,</span> <span class="n">end_layer_idx</span><span class="p">,</span> <span class="n">layer_thickness</span><span class="p">,</span> <span class="n">profile_function</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start_layer_idx : int</span>
<span class="sd">            Index of the first layer in the scope of the density profile.</span>
<span class="sd">        end_layer_idx : int</span>
<span class="sd">            Index of the last layer in the scope of the density profile.</span>
<span class="sd">        layer_thickness : :class:`Parameters.Parameter`</span>
<span class="sd">            Thickness of the individual layers. The Unit is the same as for every other length used throughout the project and is not predefined. E.g. wavelength.</span>
<span class="sd">        profile_function  : :class:`Parameters.ParametrizedFunction`</span>
<span class="sd">            The density of the corresponding atom as function of the distance **z** from the lower surface of start layer parametrized by arbitrary parameters (see :class:`Parameters.ParametrizedFunction` for details). </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># type checking</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start_layer_idx</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">start_layer_idx</span><span class="se">\&#39;</span><span class="s2"> has to be an integer number.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">end_layer_idx</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">end_layer_idx</span><span class="se">\&#39;</span><span class="s2"> has to be an integer number.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">layer_thickness</span><span class="p">,</span> <span class="n">Parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">layer_thickness</span><span class="se">\&#39;</span><span class="s2"> has to be an instance of class </span><span class="se">\&#39;</span><span class="s2">Parameters.Parameter</span><span class="se">\&#39;</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">profile_function</span><span class="p">,</span> <span class="n">Parameters</span><span class="o">.</span><span class="n">ParametrizedFunction</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">profile_function</span><span class="se">\&#39;</span><span class="s2"> has to be an instance of \`Parameters.ParametrizedFunction\`.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_start_layer_idx</span> <span class="o">=</span> <span class="n">start_layer_idx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_end_layer_idx</span> <span class="o">=</span> <span class="n">end_layer_idx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_layer_thickness</span> <span class="o">=</span> <span class="n">layer_thickness</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_profile_function</span> <span class="o">=</span> <span class="n">profile_function</span></div>

<div class="viewcode-block" id="DensityProfile.getDensityPar"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.DensityProfile.getDensityPar">[docs]</a>    <span class="k">def</span> <span class="nf">getDensityPar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">layer_idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the density parameter as instance of :class:`Parameters.DerivedParameter` for the layer with index **idx** coresponding to the defined density profile.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># parameter checking</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">layer_idx</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">start_layer_idx</span><span class="se">\&#39;</span><span class="s2"> has to be an integer number.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">layer_idx</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start_layer_idx</span> <span class="ow">or</span> <span class="n">layer_idx</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_end_layer_idx</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Density Profile is only defined from layer index &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_start_layer_idx</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; to &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_end_layer_idx</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;. </span><span class="se">\&#39;</span><span class="s2">layer_idx=&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">layer_idx</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2"> is out of range.&quot;</span><span class="p">)</span>

        <span class="c1"># create and return the corresponding derived parameter object</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_profile_function</span><span class="o">.</span><span class="n">getParameter</span><span class="p">((</span><span class="n">layer_idx</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start_layer_idx</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_layer_thickness</span><span class="p">)</span></div>

<div class="viewcode-block" id="DensityProfile.getDensity"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.DensityProfile.getDensity">[docs]</a>    <span class="k">def</span> <span class="nf">getDensity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">fitpararray</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the density at a certain distance **z** from the lower surface of start layer corresponding to the fit parameter values given by **fitpararray**.</span>
<span class="sd">        </span>
<span class="sd">        Might be used for plotting the resulting density profile etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># parameter checking</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Real</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">z</span><span class="se">\&#39;</span><span class="s2"> has to be a real number.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fitpararray</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">fitparray</span><span class="se">\&#39;</span><span class="s2"> has to be a list, tuple or numpy array.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_profile_function</span><span class="o">.</span><span class="n">getValue</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">fitpararray</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="DensityProfile_erf"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.DensityProfile_erf">[docs]</a><span class="k">class</span> <span class="nc">DensityProfile_erf</span><span class="p">(</span><span class="n">DensityProfile</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Specialized :class:`DensityProfile` class.</span>
<span class="sd">    Realizes a density profile with the function </span>
<span class="sd">    </span>
<span class="sd">    ``f(z) = 0.5*maximum*(1+erf( (z-position) / (sigma*sqrt(2)) ) )``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="DensityProfile_erf.__init__"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.DensityProfile_erf.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_layer_idx</span><span class="p">,</span> <span class="n">end_layer_idx</span><span class="p">,</span> <span class="n">layer_thickness</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">maximum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start_layer_idx : int</span>
<span class="sd">            Index of the first layer of the density profile.</span>
<span class="sd">        end_layer_idx : int</span>
<span class="sd">            Index of the last layer of the density profile.</span>
<span class="sd">        layer_thickness : :class:`Parameters.Parameter`</span>
<span class="sd">            Thickness of the individual layers. The Unit is the same as for every other length used throughout the project and is not predefined. E.g. wavelength.</span>
<span class="sd">        position : :class:`Parameters.Parameter`</span>
<span class="sd">            Center position of the transition. Measured from the bottom of the start layer. The Unit is the same as for every other length used throughout the project and is not predefined. E.g. wavelength.</span>
<span class="sd">        sigma : :class:`Parameters.Parameter`</span>
<span class="sd">            Width of the transition. Unit: see above.</span>
<span class="sd">        maximum : :class:`Parameters.Parameter`</span>
<span class="sd">            Maximum value of the function. Should usually be measured in mol/cm^3. For other units you have to take care with the **densityunitfactor** at :class:`.AtomLayerObject`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># type checking</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start_layer_idx</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">start_layer_idx</span><span class="se">\&#39;</span><span class="s2"> has to be an integer number.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">end_layer_idx</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">end_layer_idx</span><span class="se">\&#39;</span><span class="s2"> has to be an integer number.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">layer_thickness</span><span class="p">,</span> <span class="n">Parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">layer_thickness</span><span class="se">\&#39;</span><span class="s2"> has to be an instance of class </span><span class="se">\&#39;</span><span class="s2">Parameters.Parameter</span><span class="se">\&#39;</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">Parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">position</span><span class="se">\&#39;</span><span class="s2"> has to be an instance of class </span><span class="se">\&#39;</span><span class="s2">Parameters.Parameter</span><span class="se">\&#39;</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">maximum</span><span class="p">,</span> <span class="n">Parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">maximum</span><span class="se">\&#39;</span><span class="s2"> has to be an instance of class </span><span class="se">\&#39;</span><span class="s2">Parameters.Parameter</span><span class="se">\&#39;</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">Parameters</span><span class="o">.</span><span class="n">Parameter</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">sigma</span><span class="se">\&#39;</span><span class="s2"> has to be an instance of class </span><span class="se">\&#39;</span><span class="s2">Parameters.Parameter</span><span class="se">\&#39;</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_start_layer_idx</span> <span class="o">=</span> <span class="n">start_layer_idx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_end_layer_idx</span> <span class="o">=</span> <span class="n">end_layer_idx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_layer_thickness</span> <span class="o">=</span> <span class="n">layer_thickness</span>

        <span class="c1"># define profile function</span>
        <span class="k">def</span> <span class="nf">erf_profile</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
            <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">erf</span><span class="p">((</span><span class="n">z</span> <span class="o">-</span> <span class="n">pos</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">sig</span><span class="p">)))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_profile_function</span> <span class="o">=</span> <span class="n">Parameters</span><span class="o">.</span><span class="n">ParametrizedFunction</span><span class="p">(</span><span class="n">erf_profile</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">maximum</span><span class="p">)</span></div></div>


<span class="c1"># --------------------------------------------------------------------------------------------------------------------------</span>
<span class="c1"># convenience functions</span>

<div class="viewcode-block" id="plotAtomDensity"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.plotAtomDensity">[docs]</a><span class="k">def</span> <span class="nf">plotAtomDensity</span><span class="p">(</span><span class="n">hs</span><span class="p">,</span> <span class="n">fitpararray</span><span class="p">,</span> <span class="n">colormap</span><span class="o">=</span><span class="p">[],</span> <span class="n">atomnames</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convenience function. Create a bar plot of the atom densities of all instances of :class:`.AtomLayerObject` contained in the :class:`.Heterostructure` object **hs** corresdonding to the **fitpararray** (see :mod:`Parameters`) and return the plotted information as dictionary.</span>
<span class="sd">    </span>
<span class="sd">    This plot is only usefull for stacks of layers with equal widths as the widths are not taken into account for the plots</span>
<span class="sd">    </span>
<span class="sd">    You can  define the colors of the bars with **colormap**. Just give a list of matplotlib color names. They will be used in the given order.</span>
<span class="sd">    You can define which atoms you want to plot or in which order. Give **atomnames** as a list of strings. If **atomnames** is not given, the bars will have different width, such that overlapped bars can be seen.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hs</span><span class="p">,</span> <span class="n">Heterostructure</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">hs</span><span class="se">\&#39;</span><span class="s2"> has to be of type </span><span class="se">\&#39;</span><span class="s2">SampleRepresentation.Heterostructure</span><span class="se">\&#39;</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fitpararray</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">fitparray</span><span class="se">\&#39;</span><span class="s2"> has to be a list, tuple or numpy array.&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">colormap</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">colormap</span><span class="se">\&#39;</span><span class="s2"> has to be a list.&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">atomnames</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="n">atomnames</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">atomnames</span><span class="se">\&#39;</span><span class="s2"> has to be a list.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">atomnames</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">atomnames</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">atomnames</span><span class="se">\&#39;</span><span class="s2"> has to be a list of strings.&quot;</span><span class="p">)</span>

    <span class="n">number_of_layers</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">N_total</span>
    <span class="k">if</span> <span class="n">atomnames</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">atomnames</span> <span class="o">=</span> <span class="n">AtomLayerObject</span><span class="o">.</span><span class="n">getAtomNames</span><span class="p">()</span>
        <span class="n">widthstep</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span>
            <span class="n">atomnames</span><span class="p">)</span>  <span class="c1"># if no order is given plot each set of bar with smaller width to not cover the underlying bar</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">widthstep</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">if</span> <span class="n">atomnames</span> <span class="o">==</span> <span class="p">[]:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No atoms registered.&quot;</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="n">densitylistdict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">atomnames</span><span class="p">:</span>
        <span class="n">densitylistdict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="n">number_of_layers</span><span class="p">)</span>  <span class="c1"># create dictionary, which has an entry for every atom, with its name as key and as value a list. These lists are as long as there are numbers of layers and filled with zeros.</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">hs</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
        <span class="n">layer</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">getLayer</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>  <span class="c1"># go through all layers in the heterostructure</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span>
                      <span class="n">AtomLayerObject</span><span class="p">):</span>  <span class="c1"># if it is an instance of AtomLayerObject (i.e. contains information about atom densities)</span>
            <span class="n">densitydict</span> <span class="o">=</span> <span class="n">layer</span><span class="o">.</span><span class="n">getDensitydict</span><span class="p">(</span>
                <span class="n">fitpararray</span><span class="p">)</span>  <span class="c1"># get the density dictionary from this layer with the parameters evaluated (i.e. take the value contained in fitpararray)</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">atomnames</span><span class="p">:</span>  <span class="c1"># if atom with a certain name is contained within this layer, ad its density to the corresponding list in densitylistdict</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">densitydict</span><span class="p">:</span>
                    <span class="n">densitylistdict</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">densitydict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

    <span class="n">colorindex</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">w</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">atomnames</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">colorindex</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">colormap</span><span class="p">):</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">number_of_layers</span><span class="p">)),</span> <span class="n">densitylistdict</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">align</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                                  <span class="n">color</span><span class="o">=</span><span class="n">colormap</span><span class="p">[</span><span class="n">colorindex</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.9</span><span class="p">)</span>
            <span class="n">colorindex</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">number_of_layers</span><span class="p">)),</span> <span class="n">densitylistdict</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">align</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                                  <span class="n">alpha</span><span class="o">=</span><span class="mf">0.9</span><span class="p">)</span>
        <span class="n">w</span> <span class="o">-=</span> <span class="n">widthstep</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Layer number&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">r&#39;Density in mol/cm$^3$&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">number_of_layers</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">densitylistdict</span>  <span class="c1"># contains a dictionary, which has an entry for every atom, with its name as key and as value a list. These lists are as long as there are numbers of layers and filled with</span></div>


<div class="viewcode-block" id="KramersKronig"><a class="viewcode-back" href="../modules-api/samplerepresentation.html#SampleRepresentation.KramersKronig">[docs]</a><span class="k">def</span> <span class="nf">KramersKronig</span><span class="p">(</span><span class="n">energy</span><span class="p">,</span> <span class="n">f_imag</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convinience funtion. Performs the Kramers Kronig transformation</span>
<span class="sd">    </span>
<span class="sd">    .. math::</span>
<span class="sd">        f^\\prime(E)= - \\frac{2}{\\pi}\\mathrm{CH}\\int_0^\\infty \\frac{\\eta \\cdot f^{\\prime\\prime}(\\eta)}{\\eta^2-E^2} \\, d\\eta</span>
<span class="sd">        </span>
<span class="sd">    It is just a wrapper for :func:`Pythonreflectivity.KramersKroning` from Martins Zwieblers :mod:`Pythonreflectivity` package.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    energy : </span>
<span class="sd">        an ordered list/array of L energies (in eV). The energies do not have to be envenly spaced, but they should be ordered.</span>
<span class="sd">    f_imag :</span>
<span class="sd">        a list/array of real numbers and length L with absorption data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">Pythonreflectivity</span><span class="o">.</span><span class="n">KramersKronig</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">energy</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f_imag</span><span class="p">))</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PyXMRTool 0.9 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Yannic Utz.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.
    </div>
  </body>
</html>