
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Module Fitters &#8212; PyXMRTool 0.9 documentation</title>
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Hints" href="../hints.html" />
    <link rel="prev" title="Module Experiment" href="experiment.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../hints.html" title="Hints"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="experiment.html" title="Module Experiment"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PyXMRTool 0.9 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../api.html" accesskey="U">API</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h3><a href="../index.html">Table of Contents</a></h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html">PyXMRTool’s documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">Overview</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../api.html">API</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="parameters.html">Module <cite>Parameters</cite></a></li>
<li class="toctree-l2"><a class="reference internal" href="samplerepresentation.html">Module <cite>SampleRepresentation</cite></a></li>
<li class="toctree-l2"><a class="reference internal" href="experiment.html">Module <cite>Experiment</cite></a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Module <cite>Fitters</cite></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../hints.html">Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../definitions.html">Terms and Definitions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../development.html">Developement</a></li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="experiment.html"
                        title="previous chapter">Module <cite>Experiment</cite></a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../hints.html"
                        title="next chapter">Hints</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/modules-api/fitters.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-Fitters">
<span id="module-fitters"></span><h1>Module <cite>Fitters</cite><a class="headerlink" href="#module-Fitters" title="Permalink to this headline">¶</a></h1>
<p>Contains different optimization algorithms designed to fit reflectivity data.
They take advantage of parallelization to be used on multiprocessor system.</p>
<p>The algorithms are developed by Martin Zwiebel and I just adopted them with slight changes to PyXMRTool.
More information can be found in the PhD thesis of Martin Zwiebler.</p>
<p>The algorithms are not well developed yet. It is better to use existing optimizers. E.g. <em>scipy.optimize.least_squares</em>.</p>
<p>Only <a class="reference internal" href="#Fitters.Explore" title="Fitters.Explore"><code class="xref py py-func docutils literal notranslate"><span class="pre">Explore()</span></code></a> and related functions are recommended to use.
<a class="reference internal" href="#Fitters.Explore" title="Fitters.Explore"><code class="xref py py-func docutils literal notranslate"><span class="pre">Explore()</span></code></a> uses <em>scipy.optimize.least_squares</em> to explore the complete parameter range and <a class="reference internal" href="#Fitters.list_clusters" title="Fitters.list_clusters"><code class="xref py py-func docutils literal notranslate"><span class="pre">list_clusters()</span></code></a>, <a class="reference internal" href="#Fitters.plot_clusters_onepar" title="Fitters.plot_clusters_onepar"><code class="xref py py-func docutils literal notranslate"><span class="pre">plot_clusters_onepar()</span></code></a>, <a class="reference internal" href="#Fitters.plot_clusters_allpars" title="Fitters.plot_clusters_allpars"><code class="xref py py-func docutils literal notranslate"><span class="pre">plot_clusters_allpars()</span></code></a> and <a class="reference internal" href="#Fitters.plot_fixpoints_allpars" title="Fitters.plot_fixpoints_allpars"><code class="xref py py-func docutils literal notranslate"><span class="pre">plot_fixpoints_allpars()</span></code></a> are used to visualize the result.</p>
<dl class="function">
<dt id="Fitters.Explore">
<code class="descclassname">Fitters.</code><code class="descname">Explore</code><span class="sig-paren">(</span><em>residualsfunction</em>, <em>parameter_settings</em>, <em>number_of_seeds</em>, <em>verbose=2</em>, <em>number_of_clusters=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/Fitters.html#Explore"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Fitters.Explore" title="Permalink to this definition">¶</a></dt>
<dd><p>A scanning function which should be usefull to explore the parameter space.</p>
<p>It chooses <strong>number_of_seeds</strong> different random start parameter vectors (seeds) within the given paramteter range. Each seed is used as start parameter set for a least_square fitter to find the minimum of the sum of squared residuals (<em>ssr</em>) (using <code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.optimize.least_squares()</span></code> with the <em>trust region reflective algorithm). This will lead to **number_of_seeds*</em> fixpoints. They will then be analysed with a (k-means) clustering algorithm to group these fixpoint in <strong>number_of_clusters</strong> different clusters. If <strong>number_of_clusters</strong> = <em>None</em> (default), the clustering with the best sillouette coefficient will be used. These clusters will then be analysed: What is the SSR corresponding to the cluster centers? How many seeds lead to the corresponding clusters? What are the means and spreads of parameter values within each cluster?</p>
<p>The return value will be a structure containing the results.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>residualsfunction</strong> (<em>callable</em>) – A function which returns the differences between simulated and measured data points (residuals) as list/array. It should usally be the method <code class="xref py py-meth docutils literal notranslate"><span class="pre">SampleRepresentation.ReflDataSimulator.getResiduals'</span> <span class="pre">of</span> <span class="pre">an</span> <span class="pre">instance</span> <span class="pre">of</span> <span class="pre">:class:`SampleRepresentation.ReflDataSimulator()</span></code>.</li>
<li><strong>parameter_settings</strong> (<em>tuple of lists/arrays of floats</em>) – Sets start values, lower and upper limit of the parameters as <em>(startfitparameters, lower_limits, upper_limits )</em>, where each of the entries is an list/array of values of same length. The <em>startfitparameters</em> are not used (can be <em>None</em>) and just necessaray for compatibility.</li>
<li><strong>number_of_seeds</strong> (<em>int</em>) – number of random seeds which should be generated</li>
<li><strong>verbose</strong> (<em>{0</em><em>, </em><em>1</em><em>, </em><em>2}</em>) – <dl class="docutils">
<dt>determines the level of the optimizer’s algorithm’s verbosity:</dt><dd>0 : work silently.
1 : display a termination report for each seed.
2 (default) : display progress during iterations.</dd>
</dl>
</li>
<li><strong>number_of_clusters</strong> (<em>int</em>) – number of clusters in which the resulting fixpoints shall be grouped</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Fitters.Cluster">
<code class="descclassname">Fitters.</code><code class="descname">Cluster</code><span class="sig-paren">(</span><em>scan_output</em>, <em>ssrfunction</em>, <em>number_of_clusters=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/Fitters.html#Cluster"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Fitters.Cluster" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to deal with output of <a class="reference internal" href="#Fitters.Explore" title="Fitters.Explore"><code class="xref py py-func docutils literal notranslate"><span class="pre">Explore()</span></code></a>.</p>
<p>Clusters the found fixpoints and returns the result as structure in the same format as <a class="reference internal" href="#Fitters.Explore" title="Fitters.Explore"><code class="xref py py-func docutils literal notranslate"><span class="pre">Explore()</span></code></a>. Actually, it is used by <a class="reference internal" href="#Fitters.Explore" title="Fitters.Explore"><code class="xref py py-func docutils literal notranslate"><span class="pre">Explore()</span></code></a> internally.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>scan_output</strong> (<em>struct</em>) – return value of <a class="reference internal" href="#Fitters.Explore" title="Fitters.Explore"><code class="xref py py-func docutils literal notranslate"><span class="pre">Explore()</span></code></a></li>
<li><strong>ssrfunction</strong> (<em>callable</em>) – A function which returns the sum of squared residuals between simulated and measured data points (ssr). It should usally be the method <code class="xref py py-meth docutils literal notranslate"><span class="pre">SampleRepresentation.ReflDataSimulator.getSSR()</span></code> of an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">SampleRepresentation.ReflDataSimulator</span></code>.</li>
<li><strong>number_of_clusters</strong> (<em>int</em>) – number of clusters in which the resulting fixpoints shall be grouped</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Fitters.list_clusters">
<code class="descclassname">Fitters.</code><code class="descname">list_clusters</code><span class="sig-paren">(</span><em>scan_output</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/Fitters.html#list_clusters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Fitters.list_clusters" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to deal with output of <a class="reference internal" href="#Fitters.Explore" title="Fitters.Explore"><code class="xref py py-func docutils literal notranslate"><span class="pre">Explore()</span></code></a>.</p>
<p>Lists all found clusters (which should correspond to fixpoints) and their properties.</p>
</dd></dl>

<dl class="function">
<dt id="Fitters.plot_clusters_onepar">
<code class="descclassname">Fitters.</code><code class="descname">plot_clusters_onepar</code><span class="sig-paren">(</span><em>scan_output</em>, <em>p</em>, <em>parameter_pool=None</em>, <em>ssr_lim=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/Fitters.html#plot_clusters_onepar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Fitters.plot_clusters_onepar" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to deal with output of <a class="reference internal" href="#Fitters.Explore" title="Fitters.Explore"><code class="xref py py-func docutils literal notranslate"><span class="pre">Explore()</span></code></a> (<strong>scan_output</strong>).</p>
<p>Shows the parameter values of the centers of the found clusters of one parameter.
On the y axis the corresponding sum of squared residuals of the fit are shown.
The size (area) of the bubles corresponds to the ratio of seeds which converged to this fixpoint.
The bars show the range of parameter values which were assigned to this cluster/fixpoint.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>scan_output</strong> (<em>struct</em>) – Structure as returned by <a class="reference internal" href="#Fitters.Explore" title="Fitters.Explore"><code class="xref py py-func docutils literal notranslate"><span class="pre">Explore()</span></code></a>.</li>
<li><strong>p</strong> (<em>int</em><em> or </em><em>str</em>) – Selects the parameter. Either with its index or its name. In the second case <strong>parameter_pool</strong> has to be given.</li>
<li><strong>parameter_pool</strong> (<a class="reference internal" href="parameters.html#Parameters.ParameterPool" title="Parameters.ParameterPool"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters.ParameterPool</span></code></a>) – The paramter pool containing the parameters, which are under consideration. If given, parameter names are plotted and the x axis is adjusted to lower and upper limits stored in <strong>parameter_pool</strong>.</li>
<li><strong>ssr_lim</strong> (<em>list/tuple</em>) – lower and upper limit of y-axis (ssr)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Fitters.plot_clusters_allpars">
<code class="descclassname">Fitters.</code><code class="descname">plot_clusters_allpars</code><span class="sig-paren">(</span><em>scan_output</em>, <em>parameter_pool=None</em>, <em>ssr_lim=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/Fitters.html#plot_clusters_allpars"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Fitters.plot_clusters_allpars" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to deal with output of <a class="reference internal" href="#Fitters.Explore" title="Fitters.Explore"><code class="xref py py-func docutils literal notranslate"><span class="pre">Explore()</span></code></a> (<strong>scan_output</strong>).</p>
<p>Shows the parameter values of the centers of the found clusters of all parameter in a multiplot.
On the y axis the corresponding sum of squared residuals of the fit are shown.
The size (area) of the bubles corresponds to the ratio of seeds which converged to this fixpoint.
The bars show the range of parameter values which were assigned to this cluster/fixpoint.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>scan_output</strong> (<em>struct</em>) – Structure as returned by <a class="reference internal" href="#Fitters.Explore" title="Fitters.Explore"><code class="xref py py-func docutils literal notranslate"><span class="pre">Explore()</span></code></a>.</li>
<li><strong>parameter_pool</strong> (<a class="reference internal" href="parameters.html#Parameters.ParameterPool" title="Parameters.ParameterPool"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters.ParameterPool</span></code></a>) – The paramter pool containing the parameters, which are under consideration. If given, parameter names are plotted and the x axes are adjusted to lower and upper limits stored in <strong>parameter_pool</strong>.</li>
<li><strong>ssr_lim</strong> (<em>list/tuple</em>) – lower and upper limit of y-axis (ssr)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Fitters.plot_fixpoints_allpars">
<code class="descclassname">Fitters.</code><code class="descname">plot_fixpoints_allpars</code><span class="sig-paren">(</span><em>scan_output</em>, <em>parameter_pool=None</em>, <em>ssr_lim=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/Fitters.html#plot_fixpoints_allpars"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Fitters.plot_fixpoints_allpars" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to deal with output of <a class="reference internal" href="#Fitters.Explore" title="Fitters.Explore"><code class="xref py py-func docutils literal notranslate"><span class="pre">Explore()</span></code></a> (<strong>scan_output</strong>).</p>
<p>Shows the parameter values of the centers of the found clusters of all parameter in a multiplot.
On the y axis the corresponding sum of squared residuals of the fit are shown.
The size (area) of the bubles corresponds to the ratio of seeds which converged to this fixpoint.
The bars show the range of parameter values which were assigned to this cluster/fixpoint.
Additionally, all fixpoints are also shown, colored according to their cluster asscociated.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>scan_output</strong> (<em>struct</em>) – Structure as returned by <a class="reference internal" href="#Fitters.Explore" title="Fitters.Explore"><code class="xref py py-func docutils literal notranslate"><span class="pre">Explore()</span></code></a>.</li>
<li><strong>ssrfunction</strong> (<em>callable</em>) – A function which returns the sum of squared residuals between simulated and measured data points (ssr). It should usally be the method <code class="xref py py-meth docutils literal notranslate"><span class="pre">SampleRepresentation.ReflDataSimulator.getSSR()</span></code> of an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">SampleRepresentation.ReflDataSimulator</span></code>.</li>
<li><strong>parameter_pool</strong> (<a class="reference internal" href="parameters.html#Parameters.ParameterPool" title="Parameters.ParameterPool"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters.ParameterPool</span></code></a>) – The paramter pool containing the parameters, which are under consideration. If given, parameter names are plotted and the x axes are adjusted to lower and upper limits stored in <strong>parameter_pool</strong>.</li>
<li><strong>ssr_lim</strong> (<em>list/tuple</em>) – lower and upper limit of y-axis (ssr)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Fitters.Evolution">
<code class="descclassname">Fitters.</code><code class="descname">Evolution</code><span class="sig-paren">(</span><em>costfunction</em>, <em>parameter_settings</em>, <em>iterations</em>, <em>number_of_cores=1</em>, <em>generation_size=300</em>, <em>mutation_strength=0.01</em>, <em>elite=2</em>, <em>parent_percentage=0.25</em>, <em>control_file=None</em>, <em>plotfunction=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/Fitters.html#Evolution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Fitters.Evolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Evolutionary fit algorithm. Slow but good in finding the global minimum.
Return the optimized parameter set and the coresponding value of the costfunction.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>costfunction</strong> (<em>callable</em>) – <p>A function which returns a measure (cost) for the difference between measurement and simulated data according to the paramter set given as list of values. Usually the sum of squared residuals (SSR) is used as cost. It should usally be the method <code class="xref py py-meth docutils literal notranslate"><span class="pre">SampleRepresentation.ReflDataSimulator.getSSR()</span></code> of an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">SampleRepresentation.ReflDataSimulator</span></code> wrapped in a function. The wrapping is necessaray due to some implemetation issues connected to the parallelization.
Example for the wrapping:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">simu</span> <span class="o">=</span> <span class="n">SampleRepresentation</span><span class="o">.</span><span class="n">ReflDataSimulator</span><span class="p">(</span><span class="s2">&quot;l&quot;</span><span class="p">)</span>
<span class="o">...</span>
<span class="k">def</span> <span class="nf">cost</span><span class="p">(</span><span class="n">fitpararray</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">simu</span><span class="o">.</span><span class="n">getSSR</span><span class="p">(</span><span class="n">fitpararray</span><span class="p">)</span>
</pre></div>
</div>
<p>Pass then the function <em>cost</em> as <strong>costfunction</strong>. It can also be any other function which takes the array of fit parameters and returns one real value which should be minimized by <code class="xref py py-meth docutils literal notranslate"><span class="pre">Evolution()</span></code>.</p>
</li>
<li><strong>parameter_settings</strong> (<em>tuple of lists of floats</em>) – Sets start values, lower and upper limit of the parameters as <em>(startfitparameters, lower_limits, upper_limits )</em>, where each of the entries is an list/array of values of same length.</li>
<li><strong>iterations</strong> (<em>int</em>) – number of iterations/generations</li>
<li><strong>number_of_cores</strong> (<em>int</em>) – Number of jobs used in parallel. Best performance when set to the number of available cores on your computer.</li>
<li><strong>generation_size</strong> (<em>int</em>) – Generate this many individual fit parameter sets in each generation.</li>
<li><strong>mutation_strength</strong> (<em>float</em>) – Mutates children by adding this factor times (upper_limit - lower_limit)  –&gt; use rather small values</li>
<li><strong>elite</strong> (<em>int</em>) – Remember the best individuals for the next generation.</li>
<li><strong>parent_percentage</strong> (<em>flota</em>) – Use this fraction of a gereneration (the best) for reproduction.</li>
<li><strong>control_file</strong> (<em>str</em>) – Filename of a control file. If it is given, you can abort the optimization routine by writing “terminate 1” to the beginning of its first line.</li>
<li><strong>plotfunction</strong> (<em>callable</em>) – Function which is used to plot the current state of fitting (simulated data with currently best parameter set) after every iteration if given. It should take only one parameter: the array of fitparameters.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>This Evolutionary algorithm is mainly the same as Martins. Only the rule for mutation has changed:</p>
<div class="line-block">
<div class="line">Martin: <code class="docutils literal notranslate"><span class="pre">children[i]=children[i]</span> <span class="pre">*</span> <span class="pre">(1</span> <span class="pre">+</span> <span class="pre">s</span> <span class="pre">*</span> <span class="pre">random</span> <span class="pre">float(-1,1))</span></code></div>
<div class="line">I:      <code class="docutils literal notranslate"><span class="pre">children[i]=children[i]</span> <span class="pre">+</span> <span class="pre">s</span> <span class="pre">*</span> <span class="pre">random</span> <span class="pre">float(-1,1)*(upper_limits-lower_limits)</span></code></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Fitters.Levenberg_Marquardt_Fitter">
<code class="descclassname">Fitters.</code><code class="descname">Levenberg_Marquardt_Fitter</code><span class="sig-paren">(</span><em>residualandcostfunction</em>, <em>parameter_settings</em>, <em>parallel_points</em>, <em>number_of_cores=1</em>, <em>strict=True</em>, <em>convergence_criterium=1e-07</em>, <em>control_file=None</em>, <em>plotfunction=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/Fitters.html#Levenberg_Marquardt_Fitter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Fitters.Levenberg_Marquardt_Fitter" title="Permalink to this definition">¶</a></dt>
<dd><p>Modified Levenberg-Marquard algorithm (see PhD thesis of Martin Zwiebler). Good convergence, but might end up in a local mininum.
Return the optimized parameter set and the coresponding value of the costfunction.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>residualandcostfunction</strong> (<em>callable</em>) – <p>A function which returns the differences between simulated and measured data points (residuals) as list and a scalar measure (cost) for these differences in total according to the paramter set given as list of values. Usually the sum of squared residuals (SSR) is used as cost. It should usally be the method <code class="xref py py-meth docutils literal notranslate"><span class="pre">SampleRepresentation.ReflDataSimulator.getResidualsSSR()</span></code> of an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">SampleRepresentation.ReflDataSimulator</span></code> wrapped in a function. The wrapping is necessaray due to some implemetation issues connected to the parallelization.
Example for the wrapping:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">simu</span> <span class="o">=</span> <span class="n">SampleRepresentation</span><span class="o">.</span><span class="n">ReflDataSimulator</span><span class="p">(</span><span class="s2">&quot;l&quot;</span><span class="p">)</span>
<span class="o">...</span>
<span class="k">def</span> <span class="nf">rescost</span><span class="p">(</span><span class="n">fitpararray</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">simu</span><span class="o">.</span><span class="n">getResidualsSSR</span><span class="p">(</span><span class="n">fitpararray</span><span class="p">)</span>
</pre></div>
</div>
<p>Pass then the function <em>rescost</em> as <strong>costfunction</strong>. It can also be any other function which takes the array of fit parameters and returns a tuple of
1.) a list of residuals (will be used to determine derivatives) 2.) a value of the costfunction which should be minimized by <code class="xref py py-meth docutils literal notranslate"><span class="pre">Levenberg_Marquardt_Fitter()</span></code>.</p>
</li>
<li><strong>parameter_settings</strong> (<em>tuple of lists of floats</em>) – Sets start values, lower and upper limit of the parameters as <em>(startfitparameters, lower_limits, upper_limits )</em>, where each of the entries is an list/array of values of same length.</li>
<li><strong>parallel_points</strong> (<em>int</em>) – This should be something like the number of threads that can run in parallel/number of cores. The algorithm will first find a direction for a good descent and then check this number of points on the line. The best one will yield the new fit parameter set.</li>
<li><strong>number_of_cores</strong> (<em>int</em>) – Number of jobs used in parallel. Best performance when set to the number of available cores on your computer.</li>
<li><strong>strict</strong> (<em>bool</em>) – Usually this algorithm fails if the residuals are locally independent of one of the parameters. If you set <strong>stict</strong> = <em>False</em> this parameter will be neglected locally.</li>
<li><strong>convergence_criterium</strong> (<em>float</em>) – If the relative difference between the costs in two succeeding iterations is smaller than <strong>convergence_criterium</strong>, the fitting is defined as `converged`.</li>
<li><strong>control_file</strong> (<em>str</em>) – Filename of a control file. If it is given, you can abort the optimization routine by writing “terminate 1” to the beginning of its first line.</li>
<li><strong>plotfunction</strong> (<em>callable</em>) – Function which is used to plot the current state of fitting (simulated data with currently best parameter set) after every iteration if given. It should take only one parameter: the array of fitparameters.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../hints.html" title="Hints"
             >next</a> |</li>
        <li class="right" >
          <a href="experiment.html" title="Module Experiment"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PyXMRTool 0.9 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../api.html" >API</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Yannic Utz.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.0.1.
    </div>
  </body>
</html>